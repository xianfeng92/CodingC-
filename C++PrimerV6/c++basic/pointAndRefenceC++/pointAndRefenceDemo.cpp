
using namespace std;

// !! 1.引用与指针
// 1.引用： 必须初始化、不能为空、不能更换目标	
// 2.指针:  可以不初始化、可以为空、可以更换目标

// 引用必须初始化，而指针可以不初始化
int &r;    //不合法，没有初始化引用
int *p;    //合法，但 p 为野指针，使用需要小心

// 引用不能为空，而指针可以为空
// !! 由于引用不能为空，所以我们在使用引用的时候不需要测试其合法性，而在使用指针的时候需要首先判断指针是否为空指针，否则可能会引起程序崩溃

void test_p(int* p)
{
    if(p != null_ptr)   //对 p 所指对象赋值时需先判断p是否为空指针
    {
        *p = 3;
    }
    return;
}

void test_r(int& r)
{
    r = 3;    //由于引用不能为空，所以此处无需判断r的有效性就可以对r直接赋值
    return;
}

// !! 引用不能更换目标---->指针可以随时改变指向，但是引用只能指向初始化时指向的对象，无法改变


//!! 2.引用
// 左值引用 ----> 常规引用，一般表示对象的身份
// 右值引用 ----> 右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值
// 右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：
// 1. 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率
// 2. 能够更简洁明确地定义泛型函数

// C++ 的引用在减少了程序员自由度的同时提升了内存操作的安全性和语义的优美性。比如引用强制要求必须初始化，
// 可以让我们在使用引用的时候不用再去判断引用是否为空，让代码更加简洁优美，避免了指针满天飞的情形

//  !!引用型参数---> 使用 const reference 参数作为只读形参，这种情况下既可以避免参数拷贝还可以获得与传值参数一样的调用方式
void test(const vector<int> &data)
{
    //....
}

int main(int argc, char **argv)
{
    int a = 1;
    int b = 2;

    int &r = a;  //初始化引用r指向变量a
    int *p = &a; //初始化指针p指向变量a

    p = &b; //指针p指向了变量b
    r = b;  //引用r依然指向a，但a的值变成了b equals a = b

    vector<int> data{1,2,3,4,5,6,7,8};
    test(data);
}

// !! 3.总结¶

C++ 中引入了引用操作，在对引用的使用加了更多限制条件的情况下，保证了引用使用的安全性和便捷性，还可以保持代码的优雅性。在适合的情况使用适合的操作，
引用的使用可以一定程度避免“指针满天飞”的情况，对于提升程序稳定性也有一定的积极意义。最后，指针与引用底层实现都是一样的，不用担心两者的性能差距。

