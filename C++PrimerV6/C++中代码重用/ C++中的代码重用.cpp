// !! C++ 中的代码重用

'C++ 的一个主要目标是促进代码重用'。

公有继承是实现这种目标的机制之一，但并不是唯一的机制。本章将介绍其他方法，其中之一是使用这样的类成员: '本身是另一个类的对象'。这种方法称为包含(containment)、
组合(composition)或层次化(layering)。另一种方法是'使用私有或保护继承'。


通常，包含、私有继承和保护继承用于实现 has-a 关系，即新的类将包含另一个类的对象。例如，HomeTheater 类可能包含一个 BluRayPlayer 对象。'多重继承使得能够使
用两个或更多的基类派生出新的类，将基类的功能组合在一起'。

'本章将介绍类模板---另一种重用代码的方法'。类模板使我们能够使用通用术语定义类，然后使用模板来创建针对特定类型定义的特殊类。例如，可以定义一个通用的栈模板，然
后使用该模板创建一个用于表示 int 值栈的类和一个用于表示 double 值栈的类，甚至可以创建一个这样的类，即用于表示由栈组成的栈。


// !! 包含对象成员的类

'首先介绍包含对象成员的类'。

有一些类(如 string 类) 为表示类中的组件提供了方便的途径。下面来看一个具体的例子。

学生是什么？入学者？参加研究的人？ 残酷现实社会的避难者？ 有姓名和一系列考试分数的人？显然，最后一个定义完全没有表示出人的特征，但非常适合于简单的计算机表示。
因此，让我们根据该定义来开发 Student 类。

将学生简化成姓名和一组考试分数后，可以使用一个包含两个成员的类来表示它: 一个成员用于表示姓名, 另一个成员用于表示分数。

对于姓名:

1. 可以使用字符数组来表示, 但这将限制姓名的长度。当然，也可以使用 char 指针和动态内存分配，但正如第12章指出的，'这将要求提供大量的支持代码'

2. 一种更好的方法是，使用一个由他人开发好的类的对象来表示。例如，可以使用标准 C++ string类的对象来表示姓名。因为 C++ 库提供了这个类的所有实现代码，且其实
   现更完美。


对于考试分数，存在类似的选择:

1. 可以使用一个定长数组，这限制了数组的长度; 可以使用动态内存分配并提供大量的支持代码

2. 也可以设计一个使用动态内存分配的类来表示该数组

3. 还可以在标准 C++ 库中查找一个能够表示这种数据的类

当然，如果 C++ 库提供了合适的类，实现起来将更简单。C++ 库确实提供了一个这样的类，它就是 valarray。


'valarray 类简介'

valarray 类是由头文件 valarray 支持的。顾名思义，这个类用于处理数值(或具有类似特性的类)，它支持诸如将数组中所有元素的值相加以及在数组中找出最大和最小的值
等操作。'valarray 被定义为一个模板类，以便能够处理不同的数据类型'。


'模板特性意味着声明对象时，必须指定具体的数据类型'。因此，使用 valarray 类来声明一个对象时，需要在标识符 valarray 后面加上一对尖括号，并在其中包含所需的数
据类型:

valarray<int> q_values;
valarray<double> weights;

'类特性意味着要使用 valarray 对象，需要了解这个类的构造函数和其他类方法'。下面是几个使用其构造函数的例子:


double gpa[5] = {1.2, 1.3, 1.4, 1.5, 1.1};
valarray<double> v1;// an array of double size = 0
valarray<int> v2(8);// an array of 8 int elements
valarray<int> v3(10,8);// an array of 8 int elements, each element set to 10
valarray<double> v4(gpa,5);

从中可知，可以创建长度为零的空数组、指定长度的空数组、所有元素度被初始化为指定值的数组、用常规数组中的值进行初始化的数组。

下面是这个类的一些方法:


1. operator：让您能够访问各个元素
2. size()：返回包含的元素数
3. sum()：返回所有元素的总和
4. max()：返回最大的元素
5. min()：返回最小的元素

还有很多其他的方法，但就这个例子而言，上述方法足够了。


'Student 类的设计'

至此，已经确定了 Student 类的设计计划：使用一个 string 对象来表示姓名，使用一个 valarray<double> 来表示考试分数。

那么如何设计呢？您可能想以公有的方式从这两个类派生出 Student 类，这将是多重公有继承，C++ 允许这样做，但在这里并不合适，因为学生与这些类之间的关系不是 is-a 
模型。学生不是姓名，也不是一组考试成绩。这里的关系是 has-a，学生有姓名，也有一组考试分数。通常，用于建立 has-a 关系的 C++ 技术是组合(包含)，即创建一个包含
其他类对象的类。例如，可以将 Student 类声明为如下所示:

class Student
{
    private:
        std::string name;
        valarray<double> scores;
    public:
    ...
};

同样，上述类将数据成员声明为私有的。'这意味着 Student 类的成员函数可以使用 string 和 valarray<double> 类的公有接口来访问和修改 name 和 scores 对象'，但
在类的外面不能这样做，而只能通过 Student 类的公有接口访问 name 和 score。

对于这种情况，通常被描述为 Student 类获得了其成员对象的实现，但没有继承接口。

'对于 has-a 关系来说，类对象不能自动获得被包含对象的接口是一件好事'。例如，string 类将 + 运算符重载为将两个字符串连接起来；但从概念上说，将两个 Student 对象
串接起来是没有意义的。这也是这里不使用公有继承的原因之一。另一方面，被包含的类的接口部分对新类来说可能是有意义的。例如，可能希望使用 string 接口中的 
operator<() 方法将 Student 对象按姓名进行排序，为此可以定义 Student::Operator<() 成员函数，它在内部使用函数 string::Operator<()。


'Student 类示例'

现在需要提供 Student 类的定义，当然它应包含构造函数以及一些用作 Student 类接口的方法。

