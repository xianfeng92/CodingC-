// !! 内存模型和名称空间

C++ 为在内存中存储数据方面提供了多种选择。可以选择数据保留在内存中的时间长度(存储持续性)以及程序的哪一部分可以访问数据(作用域和链接)等。
可以使用 new 来动态地分配内存，而定位 new 运算符提供了这种技术的一种变种。C++ 名称空间是另一种控制访问权的方式。
通常，大型程序都由多个源代码文件组成，这些文件可能共享一些数据, 这样的程序涉及到程序文件的单独编译。

// !! 单独编译

和 C 语言一样，C++ 也允许甚至鼓励程序员将组件函数放在独立的文件中。可以单独编译这些文件，然后将它们链接成可执行的程序。'如果只修改了一个文件，则可以
只重新编译该文件，然后将它与其他文件的编译版本链接'。

这使得大程序的管理更便捷。另外，大多数 C++ 环境都提供了其他工具来帮助管理。例如，'UNIX 和 Linux 系统都具有 make 程序，可以跟踪程序依赖的文件以及这些文件
的最后修改时间。运行 make 时，如果它检测到上次编译后修改了源文件，make 将记住重新构建程序所需的步骤'。大多数集成开发环境(包括 Embarcadero C++ Builder、
Microsoft Visual C++、Apple Xcode 和 Freescale CodeWarrior) 都在 Project 菜单中提供了类似的工具。

谁希望出现更多的问题呢？

'C 和 C++ 的开发人员都不希望，因此他们提供了 #include 来处理这种情况。与其将结构声明加入到每一个文件中，不如将其放在头文件中，然后在每一个源代码文件中包
含该头文件'。这样，要修改结构声明时，只需在头文件中做一次改动即可。另外，也可以将函数原型放在头文件中。因此，可以将原来的程序分成三部分。

1. 头文件：包含结构声明和使用这些结构的函数的原型
2. 源代码文件：包含与结构有关的函数的代码
3. 源代码文件：包含调用与结构相关的函数的代码

'这是一种非常有用的组织程序的策略'。例如，如果编写另一个程序时，也需要使用这些函数，则只需包含头文件，并将函数文件添加到项目列表或 make 列表中即可。

另外，这种组织方式也与 OOP 方法一致。'一个文件（头文件）包含了用户定义类型的定义'；'另一个文件包含操纵用户定义类型的函数的代码'。这两个文件组成了一个软件包，
可用于各种程序中。


'请不要将函数定义或变量声明放到头文件中'。这样做对于简单的情况可能是可行的，但通常会引来麻烦。

下面列出了头文件中常包含的内容:

1. 函数原型

2. 使用 #define 或 const 定义的符号常量

3. 结构声明

4. 类声明

5. 模板声明

6. 内联函数


将结构声明放在头文件中是可以的，因为它们不创建变量，而'只是在源代码文件中声明结构变量时，告诉编译器如何创建该结构变量'。同样，'模板声明不是将被编译的代
码，它们指示编译器如何生成与源代码中的函数调用相匹配的函数定义'。

被声明为 const 的数据和内联函数有特殊的链接属性，因此可以将其放在头文件中，而不会引起问题。

程序 coordin.h、程序 file1.cpp 和程序 file2.cpp 是将程序分成几个独立部分后得到的结果。注意，在包含头文件时，我们使用 "coordin.h"，而不是 <coodin.h>。
'如果文件名包含在尖括号中，则 C++ 编译器将在存储标准头文件的主机系统的文件系统(/usr/include)中查找'；'但如果文件名包含在双引号中，则编译器将首先查找当前
的工作目录或源代码目录(或其他目录，这取决于编译器)。如果没有在那里找到头文件，则将在标准位置查找'。因此在包含自己的头文件时，应使用引号而不是尖括号。

另外，'不要使用 #include 来包含源代码文件，这样做将导致多重声明'。


1. 头文件管理

在同一个文件中只能将同一个头文件包含一次。记住这个规则很容易，但很可能在不知情的情况下将头文件包含多次。例如，可能使用包含了另外一个头文件的头文件。

有一种标准的 C/C++ 技术可以避免多次包含同一个头文件。它是'基于预处理器编译指令' #ifndef(即if not defined)的。

下面的代码片段意味着仅当以前没有使用预处理器编译指令 #define 定义名称 COORDINH 时，才处理 #ifndef 和 #endif 之间的语句:


将这两个源代码文件和新的头文件一起进行编译和链接，将生成一个可执行程序。顺便说一句，虽然我们讨论的是根据文件进行单独编译，但为保持通用性，C++ 标准使用了
术语翻译单元(translation unit)，而不是文件；文件并不是计算机组织信息时的唯一方式。出于简化的目的，本书使用术语文件，您可将其解释为翻译单元。


'多个库的链接'

C++ 标准允许每个编译器设计人员以他认为合适的方式实现名称修饰，因此由不同编译器创建的二进制模块(对象代码文件)很可能无法正确地链接。也就是说，'两个编译器将为
同一个函数生成不同的修饰名称'。名称的不同将使链接器无法将一个编译器生成的函数调用与另一个编译器生成的函数定义匹配。

'在链接编译模块时，请确保所有对象文件或库都是由同一个编译器生成的。如果有源代码，通常可以用自己的编译器重新编译源代码来消除链接错误'。


// !! 存储持续性、作用域和链接性

C++ 使用三种（在 C++11 中是四种）不同的方案来存储数据，这些方案的区别就在于数据保留在内存中的时间。

1.自动存储持续性：在函数定义中声明的变量(包括函数参数)的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，
  它们使用的内存被释放。C++ 有两种存储持续性为自动的变量。静态存储持续性: 在函数定义外定义的变量和使用关键字 static 定义的变量的存储持续性都为静态。
  它们在程序整个运行过程中都存在。C++ 有 3 种存储持续性为静态的变量。

2.线程存储持续性(C++11)：当前，多核处理器很常见，这些 CPU 可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字 
  thread_local 声明的，则其生命周期与所属的线程一样长。

3.动态存储持续性: 用 new 运算符分配的内存将一直存在，直到使用 delete 运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自由存储
 (free store)或堆(heap)。


// !! 作用域和链接

'作用域(scope) 描述了名称在文件(翻译单元)的多大范围内可见'。例如，函数中定义的变量可在该函数中使用，但不能在其他函数中使用; 而在文件中的函数定义之前定义
的变量则可在所有函数中使用。

链接性(linkage)描述了名称如何在不同单元间共享。'链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享'。自动变量的名称没有链接性，
因为它们不能共享。

C++ 变量的作用域有多种。作用域为局部的变量只在定义它的代码块中可用。代码块是由花括号括起的一系列语句。例如函数体就是代码块，但可以在函数体中嵌入其他代码块。
作用域为全局(也叫文件作用域)的变量在定义位置到文件结尾之间都可用。'自动变量的作用域为局部，静态变量的作用域是全局还是局部取决于它是如何被定义的'。在函数原型
作用域(function prototype scope)中使用的名称只在包含参数列表的括号内可用(这就是为什么这些名称是什么以及是否出现都不重要的原因)。'在类中声明的成员的作用域
为整个类'。'在名称空间中声明的变量的作用域为整个名称空间'(由于名称空间已经引入到 C++ 语言中，因此全局作用域是名称空间作用域的特例)。

C++ 函数的作用域可以是整个类或整个名称空间（包括全局的），但不能是局部的(因为不能在代码块内定义函数，如果函数的作用域为局部，则只对它自己是可见的，因此不能被
其他函数调用。这样的函数将无法运行)。

'不同的 C++ 存储方式是通过存储持续性、作用域和链接性来描述的'。

下面来看看各种 C++ 存储方式的这些特征。首先介绍引入名称空间之前的情况，然后看一看名称空间带来的影响。

// !! 自动存储持续性













