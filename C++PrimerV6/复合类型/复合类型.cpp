// !! 复合类型

假设您开发了一个名叫 User-Hostile 的计算机游戏，玩家需要用智慧来应对一个神秘、险恶的计算机界面。现在，必须编写一个程序来跟踪 5 年来游戏每月的销售量，或者希望盘
点一下与黑客英雄累积的较量回合。您很快发现，'需要一些比 C++ 的简单基本类型更复杂的东西，才能满足这些数据的要求，C++ 也提供了这样的东西—复合类型'。这种类型是基于
基本整型和浮点类型创建的。影响最为深远的复合类型是类，它是将学习的 OOP 的堡垒。然而，C++ 还支持几种更普通的复合类型，它们都来自 C 语言。

例如，数组可以存储多个同类型的值。一种特殊的数组可以存储一系列字符(字符串)。结构可以存储多个不同类型的值。而指针则是一种将数据所处位置告诉计算机的变量。

// !! 数组

数组（array）是一种数据格式，能够存储多个同类型的值。例如，数组可以存储 60 个 int 类型的值（这些值表示游戏 5 年来的销售量）、12 个 short 值（这些值表示每个月的天数）
或 365 个 float 值（这些值指出一年中每天在食物方面的开销）。

'每个值都存储在一个独立的数组元素中，计算机在内存中依次存储数组的各个元素。'

要创建数组，可使用声明语句。数组声明应指出以下三点:

1. 存储在每个元素中的值的类型

2. 数组名

3. 数组中的元素数

在 C++ 中，可以通过修改简单变量的声明，添加中括号（其中包含元素数目）来完成数组声明。

例如，下面的声明创建一个名为 months 的数组，该数组有 12 个元素，每个元素都可以存储一个 short 类型的值:

short months[12];// creat a array of 12 short

事实上，可以将数组中的每个元素看作是一个简单变量。

声明数组的通用格式如下：

typeName arrayName[arraySize];

表达式 arraySize 指定元素数目，它必须是整型常数（如10）或 const 值，也可以是常量表达式（如 8 * sizeof（int）），即其中所有的值在编译时都是已知的。
具体地说，arraySize 不能是变量，变量的值是在程序运行时设置的。

1. 作为复合类型的数组

数组之所以被称为复合类型，是因为它是使用其他类型来创建的。不能仅仅将某种东西声明为数组，它必须是特定类型的数组。没有通用的数组类型，但存在很多特定的数组类型，
如 char 数组或 long 数组。例如，请看下面的声明：

float loans[20];

loans 的类型不是数组，而是 float 数组 。这强调了 loans 组是使用 float 类型创建的。

数组的很多用途都是基于这样一个事实: 可以单独访问数组元素。方法是使用下标或索引来对元素进行编号。C++ 数组从 0 开始编号和。C++ 使用带索引的方括号表示法来指定数组
元素。例如，months[0] 是 months 数组的第一个元素，months[11] 是最后一个元素。注意，最后一个元素的索引比数组长度小 1。因此，数组声明能够使用一个声明创建大量的
变量，然后便可以用索引来标识和访问各个元素。

2. 有效下标值的重要性

'编译器不会检查使用的下标是否有效'。例如，如果将一个值赋给不存在的元素 months[101]，编译器并不会指出错误。但是程序运行后，这种赋值可能引发问题，它可能破坏数据或
代码，也可能导致程序异常终止。所以必须确保程序只使用有效的下标值。

程序 arrayone.cpp 中的马铃薯分析程序说明了数组的一些属性，包括声明数组、给数组元素赋值以及初始化数组。

// arrayone.cpp ---small array of integer


#include <iostream>

int main()
{
    using namespace std;
    int yams[3];// create array with 3 elements
    yams[0] = 7; // assign value to first elements
    yams[1] = 8; // assign value to second elements
    yams[2] = 6; // assign value to third elements

    int yamcost[3] = {20,30,5};// create a initialize array

    cout << "Total yams = " << endl;
    cout << yams[0] + yams[1] + yams[2] << endl;
    cout << "The packaged with " << yams[1] << " yams cost ";
    cout << yamcost[1] << " cents per yam.\n";

    int total = yams[0] * yamcost[0] + yams[1] * yamcost[1] + yams[2] * yamcost[2];
    cout << "The total yams cost " << total << "cents .\n";

    cout << "size of yams array is " << sizeof(yams);
    cout << "bytes.\n";
    cout << "size of one elements is " << sizeof(yams[0]);
    cout << "bytes.\n";
    return 0;
}

 » g++ --std=c++11 arrayone.cpp 
--------------------------------------------------------------------------------
 » ./a.out
Total yams = 
21
The packaged with 8 yams cost 30 cents per yam.
The total yams cost 410cents .
size of yams array is 12bytes.
size of one elements is 4bytes.

该程序首先创建一个名为 yams 的包含 3 个元素的数组。由于 yams 有 3 个元素，它们的编号为 0～2，因此 arrayone.cpp 使用索引 0～2 分别给这三个元素赋值。
'Yam 的每个元素都是 int，都有 int 类型的权力和特权'，因此 arrayone.cpp 能够将值赋给元素、将元素相加和相乘，并显示它们。

如果没有初始化函数中定义的数组，则其元素值将是不确定的，这意味着元素的值为以前驻留在该内存单元中的值。

如果将 sizeof 运算符用于数组名，得到的将是整个数组的字节数。如果将 sizeof 用于数组元素，则得到的将是元素的长度（单位为字节）。这表明 yams 是一个数组，
而 yams[1] 只是一个 int 变量。

3. 数组的初始化规则

C++ 有几条关于初始化数组的规则，它们限制了初始化的时刻，决定了数组的元素数目与初始化器中值的数目不相同时将发生的情况。我们来看看这些规则。
只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组：

int cards[4] = {1,2,3,4};
int hands[4];
hands[4] = {1,2,3,4};// not allowed
cards = hands; // not allowed

然而, 可以使用下标分别给数组中的元素赋值。

初始化数组时，提供的值可以少于数组的元素数目。例如，下面的语句只初始化 hotelTips 的前两个元素：

float hotelTips[4] = {5.0,2.5};

如果只对数组的一部分进行初始化，则编译器将把其他元素设置为 0。因此，将数组中所有的元素都初始化为 0 非常简单—只要显式地将第一个元素初始化为 0，然后让编译器将
其他元素都初始化为 0 即可：

long totals[1222] = {0};

如果初始化为 {1} 而不是 {0}，则第一个元素被设置为 1，其他元素都被设置为 0。

如果初始化数组时方括号内 [] 为空，C++ 编译器将计算元素个数。例如，对于下面的声明:

short things[] = {1,2,3,4};

编译器将使 things 数组包含 4 个元素。

4. 让编译器去做

通常，让编译器计算元素个数是种很糟的做法，因为其计数可能与您想象的不一样。例如，您可能不小心在列表中遗漏了一个值。然而，这种方法对于将字符数组初始化为一个
字符串来说比较安全，很快您将明白这一点。如果主要关心的问题是程序，而不是自己是否知道数组的大小，则可以这样做:

short things[] = {1,2,3,4};
int num_things = sizeof(things)/sizeof(things[0]);

这样做是有用还是偷懒取决于具体情况。


5.  C++11 数组初始化方法

C++11 将使用大括号的初始化（列表初始化）作为一种通用初始化方式，可用于所有类型。数组以前就可使用列表初始化，但 C++11 中的列表初始化新增了一些功能。
首先，初始化数组时，可省略等号（=）; 其次，可不在大括号内包含任何东西，这将把所有元素都设置为零; 第三，列表初始化禁止缩窄转换;

'C++ 标准模板库（STL）提供了一种数组替代品—模板类 vector，而 C++11 新增了模板类 array， 这些替代品比内置复合类型数组更复杂、更灵活。'


// !! 字符串

字符串是存储在内存的连续字节中的一系列字符。


// !! string 类简介

// !! 结构简介

// !! 共同体



