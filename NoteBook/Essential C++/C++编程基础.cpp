// !! C++ 编程基础

本章,我们将从一个小程序开始,通过它来练习 C++ 程序语言的基本组成。其中包括:

1. 一些基础数据类型: 布尔值(Boolean)、字符(character)、整数(integer)、浮点数(floating point)

2. 算术运算符、关系运算符以及逻辑运算符, 用以操作上述基础数据类型。这些运算符不仅包括一般常见的加法运算符、相等运算符（==）、小于等于(<=) 运算符以及赋值
   (assignment,=) 运算符, 也包含比较特殊的递增(++)运算符、条件运算符(?:) 以及复合赋值(+= 等)运算符

3. 条件分支和循环控制语句, 例如 if 语句和 while 循环, 可用来改变程序的控制流程

4. 一些复合类型, 例如指针及数组。指针可以让我们间接参考一个已存在的对象, 数组则用来定义一组具有相同数据类型的元素

5.一套标准的、通用的抽象化库, 例如字符串和向量(vector)



// !! 如何撰写 C++ 程序


// !! How to Write a C++ Program

此刻, 假设我们需要撰写一个简易程序, 必须能够将一段信息送至用户的终端(terminal)。信息的内容则是要求用户输入自己的名字。然后程序必须读取用户所输入的名字,将这个名
字储存起来,以便后续操作使用。最后，送出一个信息，以指名道姓的方式向用户打招呼。

那么, 该从何处着手呢？

每个 C++ 程序都是从一个名为 main 的函数开始执行, 我们就从这个地方着手吧! main 是个由用户自行撰写的函数, 其通用形式如下:

int main() {
    ...
}

int 是 C++ 程序语言的关键字。所谓关键字 (keyword), 就是程序语言预先定义的一些具有特殊意义的名称。int 用来表示语言内置的整数数据类型。

函数 (function) 是一块独立的程序代码序列(code sequence), 能够执行一些运算。它包含四个部分: 返回值类型(return type)、函数名称、参数列表(parameter list
), 以及函数体(function body)

下面依次简要介绍每一部分:

函数的返回值通常用来表示运算结果。main() 函数返回整数类型。main() 的返回值用来告诉调用者, 这个程序是否正确执行。'习惯上, 程序执行无误时我们令 main() 返回零'。
若返回一个非零值, 表示程序在执行过程中发生了错误。


函数的名称由程序员选定。'函数名最好能够提供某些信息, 让我们容易了解函数实际上在做些什么'。举例来说, min() 和 sort() 便是极佳的命名。f() 和 g() 就没有那么
好了。为什么? 因为后两个名称相形之下无法告诉我们函数的实际执行操作。


main 并非是程序语言定义的关键字。但是, '执行我们这个 C++ 程序的编译系统, 会假设程序中定义有 main() 函数。如果我们没有定义, 程序将无法执行'。

函数的参数列表 (parameter list)由两个括号括住, 置于函数名之后。空的参数列表,  如 main(), 表示函数不接受任何参数。


参数列表用来表示"函数执行时, 调用者可以传给函数的类型列表"。列表之中以逗号隔开各个类型(通常我们会说用户"调用(call 或是 invoke)"某个函数)


函数的主体 (body) 由大括号（{}）标出，其中含有"提供此函数之运算"的程序代码。


数据的输入与输出, 并非 C++ 程序语言本身定义的一部分, 而是'由 C++ 的一套面向对象的类层次体系(classes hierarchy) 提供支持, 并作为 C++ 标准库
(standard library) 的一员'。

'所谓类(class), 是用户自定义的数据类型(user-defined data type)'。class 机制让我们得以将数据类型加入我们的程序中, 并有能力识别它们。

面向对象的类层次体系(class hierarchy) 定义了整个家族体系的各相关类型, 例如终端与文件输入设备、终端与文件输出设备等。

class 机制, 赋予了我们"增加程序内之类型抽象化层次"的能力。


class的定义, 一般来说分为两部分, 分别写在不同的文件中。其中之一是所谓的"头文件(header file)", 用来声明该 class 所提供的各种操作行为(operation)。另一
个文件, 程序代码文件(program text), 则包含了这些操作行为的实现内容(implementation)。



欲使用 class, 我们必须先在程序中包含其头文件。头文件可以让程序知道 class 的定义。

C++ 标准的"输入/输出库"名为 iostream, 其中包含了相关的整套 class, 用以支持对终端和文件的输入与输出。我们必须包含 iostream 库的相关头文件, 才能够使用它:

#include <iostream>


我将利用已定义好的 cout (读作 see out) 对象, 将信息写到用户的终端中。output 运算符( << 可以将数据定向到 cout, 像下面这样:

cout << "Please enter your first name: ";

欲定义一个对象, 必须指定其数据类型, 再给定其标识符。

至目前, 我们已经用过  int 数据类型。但是要用它来储存某人的名字, 几乎是不可能的事。更适当的数据类型是标准库中的 string class:

std::string user_name;

如此一来我们便定义了一个名为 user_name 的对象, 它属于 string class。

这样的定义有个特别的名称, 称为"声明语句(declaration statement)"。单只写下这行语句还不行, 因为我们还必须让程序知道 string class 的定义。因此还必须在程序
中包含 string class 的头文件:

#include <string>

接下来便可利用已定义好的 cin (读作 see in) 对象来读取用户在终端上的输入内容。通过 input 运算符(>>)将输入内容定向到具有适当类型的对象身上:

cin >> user_name;

为了产生上述信息, 我们的第一个步骤便是将输出位置(屏幕上的光标)调到下一行起始处。将换行(newline) 字符常量写至 cout, 便可达到这个目的:

cout << '\n';

所谓字符常量 (character literal) 系由一组单引号括住。字符常量分为两类: 第一类是可打印字符,例如英文字母（'a'、'A'，等等）、数字、标点符号（';'、'-'，等等）
。另一类是不可打印字符, 例如换行符('\n') 或制表符 (tab, '\t')。由于不可打印字符并无直接的表示法,所以必须以两个字符所组成的字符序列来表示。


我们在自己的应用程序中定义了新的 class 时, 也应该为每一个 class 提供它们自己的 output 运算符。这么一来便可以让那些 class 的用户得以像面对内置类型一样地以
相同方式输出对象内容。


return 是 C++ 中的关键字。此例中的 0 是紧接于 return 之后的表达式, 也就是此函数的返回值。先前我曾说过, main() 返回  0 即表示程序执行成功。

using 和 namespace 都是 C++ 中的关键字。std 是标准库的 namespace 的名称。标准库所提供的任何事物(诸如 string class以及 cout、cin 这两个 iostream 
类对象) 都被封装在命名空间 std 内。

当然, 或许你接下来会问, 什么是命名空间?

'所谓命名空间 (namespace) 是一种将库名称封装起来的方法'。

通过这种方法,可以避免和应用程序发生命名冲突的问题(所谓命名冲突是指在应用程序内两个不同的实体 entity 具有相同名称, 导致程序无法区分两者。命名冲突发生时,程序必
须等到该命名冲突获得解析 resolve 之后, 才得以继续执行)。'命名空间像是在众多名称的可见范围之间竖起的一道道围墙'。

若要在程序中使用  string class 以及 cin、cout 这两个 iostream 类对象, 我们不仅需要包含 <string> 及 <iostream> 头文件,还得让命名空间 std 内的名称曝光。
而所谓的 using directive:

using namespace std;

便是让命名空间中的名称曝光的最简单方法。




// !! 对象的定义与初始化


为了定义对象, 我们必须为它命名, 并赋予它数据类型。对象名称可以是任何字母、数字、下画线(underscore)的组合。大小写字母是有所区分的, user_name、User_name、
uSeR_nAmE、user_Name 所代表的对象各不相同。

对象名称不能以数字开头。举例来说, 1_name  是不合法的名称, name_1 则合法。当然, "任何命名都不能和程序语言本身的关键字完全一致"。例如 delete 是语言关键字,就
不可以用于程序内的命名。


每个对象都属于某个特定的数据类型。对象名称如果设计得好，可以让我们直接联想到该对象的属性。'数据类型决定了对象所能持有的数值范围, 同时也决定了对象应该占用多少内存
空间'。


所谓 class, 便是程序员自行定义的数据类型。除此之外, C++ 还提供了一组内置的数据类型, 包括布尔值、整数、浮点数、字符。'每一个内置数据类型都有一个相应的关键字,
用于指定该类型'。


例如, 为了储存用户输入的值, 我们定义一个整数对象:

int usr_value;

在单一声明语句中一并定义多个对象, 其间以逗号分隔:

int x, y, z;


一般来说, 将每个对象初始化, 是个好主意--即使初值只用来表示该对象尚未具有真正有意义的值。我之所以不为 usr_val 设置初值, 是因为其值必须直接根据用户的输入加以设
定, 然后程序才能使用。

另外还有一种不同的初始化语法, 称为"构造函数语法(constructor syntax)":

int usr_val(0);

我知道你心中有疑问: 为什么需要两种不同的初始化语法呢? 为什么直到此刻才提起呢? 唔, 让我们看看下面这个解释能否回答其中一个问题, 甚至同时回答这两个问题。


"用 assignment运算符 (=) 进行初始化" 这个操作系沿袭自 C 语言。


如果对象属于内置类型, 或者对象可以单一值加以初始化, 这种方式就没有问题。例如以下的 string class:

std::string name = "alice";

但是如果对象需要多个初值，这种方式就没有办法完成任务了。

以标准库中的复数 (complex number) 类为例, 它就需要两个初值: 一为实部, 一为虚部。'于是便引入了用来处理"多值初始化"的构造函数初始化语法':

#include <complex>

std::complex<double> pure(0, 7);

出现于 complex 之后的尖括号, 表示 complex 是一个 template class 。

C++ 支持三种浮点数类型, 分别是以关键字 float 表示的单精度(single precision)浮点数, 以关键字 double 表示的双精度 (double precision)浮点数, 以及连续
两个关键字 long double 表示的长双精度(extended precision) 浮点数。

template class 机制使程序员得以直到使用 template class 时才决定真正的数据类型。程序员可以先插入一个代名, 稍后才绑定至实际的数据类型。

上例便是将 complex 类的成员绑定至 double 类型。


我知道, 这些说明带给你的只怕是疑问多过回答。然而, 这是因为, 当"内置数据类型"与"程序员自行定义的 class 类型"具备不同的初始化语法时, 我们无法编写出一个 
template 使它同时支持"内置类型"与"class 类型"。让语法统一, 可以简化 template 的设计。不幸的是, 解释这些语法似乎使事情益发复杂!


关键字 char 表示字符(character)类型。单引号括住的字符代表所谓的字符常量, 例如'a'、'7'、';'。此外还有一些特别的内置字符常量(有时也称为"转义字符
escape sequence")，例如：


'\n' 换行符 newline
'\t' 制表符 tab
'\'' 单引号
'\"' 双引号
'\\' 反斜杠

举个例子, 我们想要在打印用户姓名之前, 先换行并跳过一个制表符的 tab 距离, 下面这行就可以办到:

cout << '\n' << '\t';

另一种写法是将两个不同的字符合并为一个字符串:

cout << "\n\t";


C++ 提供了内置的 Boolean 类型, 用以表示真假值(true/false)。我们的程序中可以定义 Boolean 对象来控制是否要显示下一组数列:

bool go_for_it = false;


Boolean 对象系由关键字 bool 指出, 其值可为 true  或 false。

有时候我们需要一些用来表示常量的对象: 比如用户最多可猜多少次, 或者像圆周率这类永恒不变的值。'这种对象的内容在程序执行过程中不应该有所变动'。我们应当如何避免无
意间更改此类对象的值呢? C++ 的 const 关键字可以派上用场, 被定义为 const 的对象, 在获得初值之后, 无法再有任何变动。



// !!  撰写表达式


// !! 条件语句和循环语句

基本上, 从 main() 的第一行语句(statement) 开始, 程序里的每行语句都只会被依序执行一次。

if 语句让我们依据某个表达式的结果来决定是否执行一条或多条连续的语句。可有可无的 else 子句, 更可让我们连续检验多个测试条件。

至于循环 (loop) 语句, 可以让我们根据某个表达式结果, 重复执行单一或连续多条语句。



// !! 如何运用 Array 和 Vector

'C++ 允许我们以内置的 array 类型或标准库提供的 vector 类来定义容器'。一般而言, 我建议使用 vector 甚于 array。不过, 大量现存的程序代码都使用 array。 
因此, 了解如何善用这两种方式, 便相当重要。


要定义 array, 我们必须指定 array 的元素类型, 还得给予 array 一个名称, 并指定其尺度大小--亦即  array 所能储存的元素个数。array 的大小必须是个常量表达
式, 也就是一个不需要在运行时求值的表达式。

int ar[9];

至于定义 vector object, 我们首先必须包含 vector 头文件。vector 是个  template class, 所以我们必须在类名之后的尖括号内指定其元素类型,其大小则写在小括
号中; 此处所给予的大小并不一定得是个常量表达式。

无论 array 或 vector, 我们都可以指定容器中的某个位置，进而访问该位置上的元素。



// !! 指针带来弹性


指针为程序引入了一层间接性。我们可以操作指针(代表某特定内存地址), 而不再直接操作对象。

'在我们的程序中, 指针主要做两件事情。它可以增加程序本身的弹性, 但同时也增加了直接操作对象时所没有的复杂度'。


我们早已了解如何定义对象。以下语句将 ival 定义为一个 int 对象, 并给予初值 1024:

int ival = 1024;

'指针内含某特定类型对象的内存地址'。当我们要定义某个特定类型的指针时, 必须在类型名称之后加上 * 号:

int *pi;

pi 是个 int 类型对象的指针。我们应当如何为指针设定初值呢? 如果以对象名称来执行求值操作, 例如:

int ival = 1024;
int *pi = &ival;

'如果要访问一个由指针所指的对象, 我们必须对该指针进行  dereference操作'--也就是取得"位于该指针所指内存地址上"的对象。在指针之前使用 * 号, 便可以达到这个目
的:

int ival = 1024;
int *pi = &ival;
cout << *pi;

指针的复杂度, 如你所见, 源于其令人困惑的语法。本例中可能令人感到复杂的地方, 便是指针所具有的双重性质: 既可以让我们操作指针包含的的内存地址, 也可以让我们操作指针
所指的对象值。指针的第二个可能令人感到复杂的地方是, 指针可能并不指向任何对象。

当我们写 *pi 时, 这种写法可能会 (也可能不会)使程序在运行时产生错误。如果 pi 定位到某个对象, 则对 pi 进行 dereference 操作没有错误。但如果 pi不指向任何对
象, 则 dereference pi 会导致未知的执行结果。这意味着, 在使用指针时, 必须在提领之前先确定它的确指向某对象。该怎么做呢?

一个未指向任何对象的指针, 其地址值为 0。有时候我们称之为 null 指针。任何指针都可以被初始化,或是令其值为0。

使用 class object 的指针, 和使用内置类型的指针略有不同。这是因为 class object 关联了一组我们可以 invoke 的操作。



// !! 文件的读写

用户可能会一再执行这个程序。我们应该让用户的分数可以在不同的"会话 (session)"累计使用。为了达到这个目的, 我们必须:1 每次执行结束, 将用户的姓名及会话的某些
数据写入文件; 2. 在程序开启另一个会话时, 将数据从文件中读回。让我们看看这要怎么办到。

要对文件进行读写操作, 首先得包含 fstream 头文件:

#include <fstream>

为了打开一个可供输出的文件, 我们定义一个 ofstream (供输出用的file stream) 对象,并将文件名传入:

ofstream outfile("usr_data.txt");

声明 outfile 的同时, 会发生什么事? 如果指定的文件并不存在, 便会有一个文件被产生出来并打开供输出使用。如果指定的文件已经存在, 这个文件会被打开用于输出, 而文件
中原有的数据会被丢弃。

如果文件已经存在, 但我们并不希望丢弃其原有内容, 而是希望将新数据增加到该文件中, 那么我们必须以追加模式 append mode 打开这个文件。为此, 我们提供第二个参数 
ios_base::app 给 ofstream 对象。


ofstream outfile("usr_data.txt", ios_base::app);

文件有可能打开失败。在进行写入操作之前, 我们必须确定文件的确打开成功。最简单的方法便是检验 class object 的真伪:

if(!outFile){
    // open file failed
}else{
    outFile << "xforg" << " ";
    outFile << "100";
}

如果文件顺利打开, 我们便将输出信息定向到该文件, 就像将信息写入 cout 及 cerr 这两个 ostream 对象一样。

如果要打开一个可供读取的文件, 我们就定义一个 ifstream(供输入的 file stream)对象, 并将文件名传入。如果文件未能成功打开, 该 ifstream 对象就为 false。如果
成功, 该文件的写入位置会被设定在起始处。

std::string name;
int score;
ifstream infile("usr_data.txt");
if(!infile){
    std::cerr << "open file error " << std::endl;
}else{
    infile >> name >> score;
}

while 循环的每次迭代都会读取文件的下一行内容。这样的操作会持续到文件末才结束。


如果想要同时读写同一个文件, 我们得定义一个 fstream 对象。为了以追加模式 append mode 打开, 我们得传入第二参数值 ios_base::in|ios_base::app:

fstream iofile("usr_data.txt", ios_base::in | ios_base::app);


'当我们以追加模式来打开档案, 文件位置会位于末尾'。如果我们没有先重新定位, 就试着读取文件内容, 那么立刻就会遇上"文件结束"的状况。

seekg() 可将 iofile 重新定位至文件的起始处。由于此文件是以追加模式开启, 因此任何写入操作都会将数据添加在文件末尾。
















