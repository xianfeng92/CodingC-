// !! 面向过程的编程风格

我们将整个程序写在 main() 函数里头。但除非我们仅仅想编写规模不大的程序, 否则这是一种不切实际的做法。

通常我们会抽取通用的操作, 例如计算 Fibonacci 数列元素、产生随机数,等等, 将它们实现为独立函数。

将函数独立出来的做法可带来三个主要好处: 第一, 以一连串函数调用操作, 取代重复编写相同的程序代码, 可使程序更容易读懂。第二, 我们可以在不同的程序中使用这些函数。
第三, 我们可以更容易地将工作分配给协作开发团队。


// !! 如何编写函数


我将在这一节编写一个函数, 该函数返回 Fibonacci 数列中由用户指定的某个位置的元素。例如用户可以询问"Fibonacci 数列的第八个元素是什么? "我们的程序应该回答:21。
这个函数应当如何定义呢 ?

每一个函数必须定义以下四个部分:

1. 返回类型。本例将返回用户指定位置的元素值, 而元素类型是 int, 所以我们的函数返回类型也是 int。函数如果没有返回值, 其返回类型为 void

2. 函数名。foo() 是个常见的名称, 但却不是个好名称, 因为它无法帮助我们理解函数操作的实际内涵

3. 参数列表 parameter list。函数参数扮演着占位符(placeholder) 的角色, 它让用户在每次调用函数时,将要传入的值放在其中, 以便函数使用

4. 函数体。此即操作本身的工作逻辑的实现内容


函数必须先被声明, 然后才能被调用(被使用)。'函数的声明让编译器得以检查后续出现的使用方式是否正确'--是否有足够的参数、参数类型是否正确等等。函数声明不必提供函数
体, 但必须指明返回类型、函数名以及参数列表。此即所谓的函数原型 (function prototype)

int fib_elem(int pos);

'函数的定义则包括函数原型及函数体'。函数以 return 语句将值返回。

如果用户输入了一个不合理的位置值, 程序应该怎么处理呢? 最极端的做法就是终止整个程序。标准库的 exit() 函数可派上用场。我们必须传一个值给 exit(), 此值将成为程
序结束时的状态值。


if(pos < 0){
    exit(-1);
}


为了能使用 exit(), 必须先包含 cstdlib 头文件:

#include <cstdlib>



// !! Pass by Reference 语义

reference 扮演着外界与对象之间一个间接手柄的角色。只要在类型名称和 reference 名称之间插入 &  符号, 便是声明了一个reference:

int ival = 1024;
int & ref_val = ival;


C++ 不允许我们改变 reference 所代表的对象, 它们必须从一而终。

当我们以 by reference 方式将对象作为函数参数传入时, 对象本身并不会复制出另一份--复制的是对象的地址。函数中对该对象进行的任何操作,都相当于是对传入的对象进行
间接操作。

将参数声明为 reference 的理由之一是, 希望得以直接对所传入的对象进行修改。这个理由极为重要, 因为就像我们在前面的例子中所见, 不这么做的话, 程序无法正确工作。

将参数声明为 reference 的第二个理由是, 降低复制大型对象的额外负担。这个理由相比较起来不是那么重要, 因为对程序而言不过是效率问题罢了。


声明了一个 reference to const vector, 因为函数之中并不会更改 vector 的内容。少了 const 并不会造成错误。但加上 const 可以让阅读程序的人了解,我们以传址
的方式来传递 vector, 为的是避免复制操作, 而不是为了要在函数之中对它进行修改。

如果我们愿意, 也可以将 vector 以 pointer 形式传递。这和以 reference 传递的效果相同: 传递的是对象地址, 而不是整个对象的副本。唯一差别在于 reference 和
pointer 的用法不同。

pointer 参数和 reference 参数之间更重要的差异是, pointer 可能 (也可能不)指向某个实际对象。当我们提领 pointer 时, 一定要先确定其值并非 0。至于 reference
, 则必定会代表某个对象, 所以不需要做此检查。


// !! 作用域及范围


除了一个必要的例外(意指 static), 函数内定义的对象, 只存在于函数执行期间。如果将这些所谓局部对象 (local object) 的地址返回, 会导致运行时错误。

还记得吗, 函数是暂时位于程序栈 (内存内的一块特殊区域) 之上。局部对象就放在这块区域中。当函数执行完毕, 这块区域的内容便会被弃置。于是局部对象不复存在。一般而言,
对根本不存在的对象进行寻址操作, 是很不好的习惯。

对象在程序内的存活区域称为该对象的 scope。

'对象如果在函数以外声明, 具有所谓的 file scope'。对象如果拥有 file scope, 从其声明点至文件末尾都是可见的。file scope 内的对象也具备所谓的 static extent
,意即该对象的内存在 main() 开始执行之前便已经分配好了, 可以一直存在至程序结束。

内置类型的对象, 如果定义在 file scope 之内, 必定被初始化为 0。但如果它们被定义于 local scope 之内, 那么除非程序员指定其初值, 否则不会被初始化。



// !! 动态内存管理


不论 local scope 或 file scope, 对我们而言, 都是由系统自动管理。

第三种储存期形式称为 dynamic extent, 其内存系由程序的空闲空间 (free store) 分配而来, 有时也称为 heap memory。这种内存必须由程序员自行管理, 其分配系通
过 new 表达式来完成, 而其释放则通过 delete 表达式完成。


new 表达式的形式如下:

new Type;

此处的 Type 可为任意内置类型, 也可以是程序知道的  class 类型。

从 heap 分配而来的对象, 被称为具有 dynamic extent, 因为它们是在运行时通过 new 表达式分配来的, 因此可以持续存活, 直到以 delete 表达式加以释放为止。


下面的 delete 表达式会释放pi所指的对象:

delete pi;

如果要删除数组中的所有对象, 必须在数组指针和 delete 表达式之间, 加上一个空的下标运算符:

delete[] pia;


编译器会自动进行这项检查。如果因为某种原因, 程序员不想使用 delete 表达式, 由 heap 分配而来的对象就永远不会被释放, 这称为 memory leak



// !! 提供默认参数值

一般的程序编写法则是, 以"参数传递"作为函数间的沟通方式, 比"直接将对象定义于 file scope"更适当。理由之一是, 函数如果过度依赖定义于 file scope 内的对象, 就比
较难以在其他环境中重用, 也比较难以修改--我们不仅需要了解该函数的工作逻辑, 也必须了解定义于 file scope 中的那些对象的工作逻辑。

'C++ 允许我们为全部或部分参数设定默认值'。


通常, 函数声明会被放在头文件, 每个打算使用该函数的文件, 都会包含对应的头文件。还记得吗, 我们之所以包含 cstdlib 头文件, 正是为了要包含 exit() 函数声明。函数的
定义通常被放在程序代码文件, 该文件只被编译一次, 当我们想要使用该函数时, 会将它链接 (link) 到我们的程序来。


也就是说, 头文件可为函数带来更高的可见性 (visiblity)

为了更高的可见性, 我们决定将默认值放在函数声明处而非定义处。




// !! 使用局部静态对象

'局部对象会在每次调用函数时建立, 并在函数结束的同时被弃置'。如果将 vector 对象定义于 file scope 之中,又过于冒险。是的, 为了节省函数间的通信问题而将对象定义
于 file scope 内, 永远都是一种冒险。通常, file scope 对象会打乱不同函数间的独立性, 使它们难以理解。


// !! 声明 inline 函数

inline 函数的定义, 常常被放在头文件中。由于编译器必须在它被调用的时候加以展开, 所以这个时候其定义必须是有效的。


// !! 提供重载函数

Providing Overloaded Functions

现在, 我来提供一个通用的 display_message() 函数, 取代原先让每个函数自行产生调试信息的方式。

'我们是否可以传入不同类型甚至不同数量的参数给 display_message() 呢'? 可以。如何办到? 这必须通过所谓的函数重载 function overloading 机制。

参数列表(parameter list) 不相同 (可能是参数类型不同, 可能是参数个数不同) 的两个或多个函数, 可以拥有相同的函数名称。

既然名称相同, 编译器如何知道应该调用哪一个函数呢? 它会将调用者提供的实际参数拿来和每个重载函数的参数比对, 找出其中最适合的。这也就是每个重载函数的参数列表必
须和其他重载函数的不同的原因。

编译器无法根据函数返回类型来区分两个具有相同名称的函数。

为什么返回类型不足以将函数重载呢? 因为返回类型无法保证提供给我们一个足以区分不同重载函数的语境。

'将一组实现代码不同但工作内容相似的函数加以重载, 可以让函数用户更容易使用这些函数'。如果没有重载机制, 我们就得为每个函数提供不同的名称。


// !! 定义并使用模板函数

Defining and Using Template Functions

假设我的一个同事要求我增加三个 display_message() 函数, 分别用以处理元素类型为 int、double 和 string 的三种 vector:

void display_message(const std::string&, const std::vector<std::string>&);
void display_message(const std::string&, const std::vector<int>&);
void display_message(const std::string&, const std::vector<double>&);

完成这三个函数之后, 我们注意到, 每个函数的函数体都颇为相像。唯一的差别仅在于第二参数的类型:

我们没有理由以为其他同事不会跑来要求我们再写一些类似的函数来支持其他类型。'如果我们能够只定义一份函数内容, 而不是将同样的程序代码复制多份然后再针对每一份做点小
修改, 那么应当可以省下不少工夫'。为达到此目的, 需要一种机制, 让我们得以将单一函数的内容与希望显示的各种 vector 类型绑定 (bind) 起来。所谓 function 
template 便提供了这样的机制。

function template 将参数列表中指定的全部 (或部分) 参数的类型信息抽离了出来。

在 display_message() 例子中, 我们希望将 vector 所持元素的类型抽离出来, 这样就可以定义出一份不需要再有任何更改的模板 (template)。

不过, 这样还不完整, 因为我们遗漏了抽离出来的类型信息。这份类型信息系由用户提供--当他决定采用 function template 的某个实例时提供。

'function template 以关键字 template 开场, 其后紧接着以成对尖括号 (<>) 包围起来的一个或多个标识符'。

这些标识符用以表示我们希望推迟决定的数据类型。用户每次利用这一模板 template 产生函数,都必须提供确实的类型信息。'这些标识符事实上扮演着占位符的角色, 用来放
置函数参数列表及函数体中的某些实际数据类型'。

template<typename elemType>
void display_message(const std::string& msg, const std::vector<elemType>& vec){
    cout << msg << endl;
    for(std::size_t i = 0; i < vec.size(); i++){
        elemType t =  vec[i];
        cout << t << ' ';
    }
}

'关键字 typename 表示, elemType 在 display_message() 函数中是一个暂时放置类型的占位符'。

由于在这个例子中我们希望推迟指定要显示的  vector 的元素类型, 因此把 elemType 放在 vector 的尖括号内。

那么, 函数的第一个参数呢? 每次调用 display_message() 时, msg 的类型都不会改变, 它一直都是一个  const reference to string object, 所以没有必要将其
类型抽离出来。

function template 的参数列表通常都由两种类型构成, 一类是明确的类型, 另一类是暂缓决定的类型。


我们应当如何使用 function template? 使用方式看起来和普通函数极为相似。举个例子, 当我们写:

vector<int> coll;
string msg;
//...
display_message(msg, coll);

编译器会将 elemType 绑定 (bind) 为 int 类型, 然后产生一份 display_message() 函数实例, 于是其第二参数的类型即变成 vector<int>。
函数体内的局部对象的类型同样也变成了 int。同样道理,  当我们写:

vector<std::string> vec;
std::string msg;
//...
display_message(msg, vec);

elemType 会被绑定  bind 为 string 类型, 然后产生一份 display_message() 函数实例, 于是其第二参数的类型即变成 vector<string>。

function template 扮演的角色如同处方一般, 我们可以通过它产生无数函数, 其  elemType 可以被绑定为内置类型或用户自定义类型。

一般而言, 如果函数具备多种实现方式,我们可将它重载  overload,其每份实例提供的是相同的通用服务。如果我们希望让程序代码的主体不变, 仅仅改变其中用到的数据类
型, 可以通过 function template 达到目的。



// !! 函数指针带来更大的弹性


Pointers to Functions Add Flexibility

所谓函数指针 (pointer to function), 其形式相当复杂。它必须指明其所指函数的返回类型及参数列表

此外, 函数指针的定义必须将 * 放在某个位置, 表示这份定义所表现的是一个指针。


const vector<int>* (*seq_ptr)(int);

现在, seq_ptr 可以指向"具有所列返回类型及参数列表"的任何一个函数。

由函数指针指向的函数, 其调用方式和一般函数相同。也就是说:

const vector<int> *pseq = seq_ptr(pos);


会间接调用 seq_ptr 所指向的函数。我们不知道 (或者不在乎) 它所指向的函数是哪一个。更明智的做法是, 多付出一些检验操作, 确定它是否真的指到某个函数:

if(!seq_ptr){
    display_message("internal Error");
}

'我们可以给予函数指针初值。如果初值为 0, 表示并未指向任何函数':


const vector<int> *(*seq_ptr)(int) = 0;

也可以拿某个函数的地址作为函数指针的初值。问题是, 如何取得函数的地址呢? 这是 C++ 中最不复杂的操作了, 只要提供函数名称即可。


// !! 设定头文件

Setting Up a Header File

调用 seq_elem() 之前, 必须先声明它, 以使程序知道它的存在。如果它被五个程序文件调用, 就必须进行五次声明操作。为了不用分别在五个文件中声明 seq_elem(),我们把
函数声明放在头文件中, 并在每个程序代码文件内包含 include 这些函数声明。


使用这种编写习惯, 我们只需为函数维护一份声明即可。如果其参数列表或返回类型需要改变, 也只需更改这份声明即可--函数用户会包含更新后的函数声明。

'头文件的扩展名, 习惯上是 .h。标准库例外, 它们没有扩展名'。我把我们的头文件命名为 NumSeq.h, 并将与数列处理有关的所有函数的声明都放在该文件中

函数的定义只能有一份, 不过倒是可以有许多份声明。


"只定义一份"的规则有个例外: inline 函数的定义。为了能够扩展 inline 函数的内容, 在每个调用点上, 编译器都得取得其定义。

这意味着我们必须将 inline 函数的定义放在头文件中, 而不是把它放在各个不同的程序代码文件中。

在 file scope  内定义的对象, 如果可能被多个文件访问, 就应该被声明于头文件中。

举个例子, 如果 seq_array 被定义于 file scope, 我们可能会想要在 NumSeq.h 内提供它的声明。啊, 以下的首次尝试还是没有完全正确:

const seq_count = 6;
const vector<int>* (*seq_array seq_count)(int);

这并不正确, 因为它会被解读为 seq_array 的定义而非声明。就像函数一样, 一个对象只能在程序中被定义一次。对象的定义, 就像函数定义一样, 必须放在程序代码文件中。
只要在上述 seq_array 定义前加上关键字 extern, 它便成为一个声明:

extern const vector<int>* (*seq_array seq_count)(int);


为什么我们使用双引号而非尖括号 (<>) 将 NumSeq.h 括起来呢?


下面是个简略的回答: 如果头文件和包含此文件的程序代码文件位于同一个磁盘目录下,我们便使用双引号。如果在不同的磁盘目录下, 我们便使用尖括号。

更有技术含量的回答是,如果此文件被认定为标准的或项目专属的头文件,我们便以尖括号将文件名括住; 编译器搜索此文件时, 会先在某些默认的磁盘目录中寻找。如果文件名由成对
的双引号括住,此文件便被认为是一个用户提供的头文件; 搜索此文件时,会由要包含此文件的文件所在的磁盘目录开始找起。
































