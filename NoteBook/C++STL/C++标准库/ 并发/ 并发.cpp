// !! 并发

现代化体系结构 (modern system architecture) 通常支持同时执行多个任务(task)和多个线程(thread)。特别是如果采用多处理器内核(multiple processor core),
那么程序执行时间可在多线程情况下获得大幅改善。

然而, 并行(in parallel)处理也带来了新挑战:不再是完成一个语句后进行另一语句, 而是'多语句同时执行, 于是可能导致并发访问(concurrently accessing)同一资源,
造成创建、读取、涂写、删除等动作不在预期次序下发生，形成不可预测的结果'。事实上多线程并发访问数据很容易变成噩梦，带来诸如死锁之类的问题，而"线程之间彼此等待"只
能算是最单纯的一种情况。

在 C++11 之前,不论语言或标准库,对并发处理没有任何支持,纵使实现(implementation) 可自由给予若干承诺。 随着 C++11 到来, 这种情况有了改变, 不论语言自身或标
准库都得到强化, 可支持并发编程(concurrent programming):

1. 语言核心定义了一个内存模型,保证当你更改"被两个不同线程使用"的两个 object 时, 它们彼此独立, 并引入了一个新关键字 thread_local 用以定义"变量带有 thread
  专属值"

2. 标准库提供的支持允许你启动多线程, 包括得以传递实参、返回数值、跨线程边界传递异常、同步化(synchronize)等, 使我们能够对"控制流程"和"数据访问"实现同步化


标准库在不同的层面分别提供支持, 它提供一个高级接口, 允许你启动线程,包括传递实参、处理结果和异常, 而那是架构在若干与之对应的低层接口上。换句话说, 标准库也提供
一组低层接口, 像是 mutex 或 atomic, 用来对付放宽的内存次序(relaxed memory order, RMO)。


本章组织如下:

1. 首先介绍各式各样的多线程启动办法。介绍了高级和低层接口后, 开始介绍启动线程的细节

2. 对于同步化线程(synchronizing thread)所引发的问题提供了一份详细讨论。最主要的问题就是数据的并发访问(concurrent data access)

3. 最后, 探讨用以"同步化线程"和"并发数据访问"的各种特性:

   mutex 和 lock (互斥体和锁), 包括 call_once() 

   condition variable (条件变量)

   Atomic



// !! 高级接口: async() 和 Future



