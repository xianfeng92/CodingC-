## illegal instruction (SIGILL)

是 POSIX 标准中提供的一类错误。从名字上看，SIGILL 是启动的某个进程中的某一句不能被 CPU 识别成正确的指令。此类错误是由操作系统发送给进程的, 在进程试图执行一些形式错误、未知或者
特权指令时操作系统会使用 SIGILL 信号终止程序。 SIGILL 对应的常数是 4.

## 造成 SIGILL 的原因

typedef void(*FUNC)(void);
int main(void)
{
    const static unsigned char arr[4] = { 0xff, 0xff, 0xff, 0xff };
    FUNC function = (FUNC) arr;
    function();
}

### 将不正确的数据段写入代码段

进程在代码段中的数据是要被作为一个指令执行的。若不小心覆盖了已有的代码段, 可能会得到错误格式的指令。同样, 如果不小心覆盖了栈上活跃记录中的返回地址, 程序就可能根据这个错误地址, 执行没有
意义的内存中的数据,进而操作。进一步可以认为,任何导致数据错误的问题都可能带来 illegal instruction 问题。比如硬盘发生故障。


### 指令集的演进

比如 SIMD 指令, 自从奔腾 4 开始有 MMX, X86 的芯片就开始不停的增加和拓宽 SIMD 支持, SSE、SSE2、SSE3、SSE42、AVX、AVX2。 默认情况下, 很多编译器都在O2或者O3中开了自动向量化,
这就导致很多在新体系结构中编译的可执行程序, 在老机器上运行时会有 illegal instruction 问题。


### 工具链 BUG


### 错误排查方法

1. 程序中有没有特权指令、或者访问特权寄存器
2. 有没有将在较新 CPU 上编译得到的可执行文件拿到老 CPU 上运行
3. 程序中有没有嵌入式汇编，先检查。 >1.一般编译器很少会生成有这种问题的代码 >2.X86 平台上要尤其注意 64 位汇编指令和 32 位汇编指令的混用问题


