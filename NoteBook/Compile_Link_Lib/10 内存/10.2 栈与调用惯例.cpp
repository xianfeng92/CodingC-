
// !! 10.2　栈与调用惯例

// !! 10.2.1　什么是栈

'栈 (stack) 是现代计算机程序里最为重要的概念之一, 几乎每一个程序都使用了栈, 没有栈就没有函数, 没有局部变量, 也就没有我们如今能够看见的所有的计算机语言'。

在解释为什么栈会如此重要之前, 让我们来先了解一下传统的栈的定义:

在经典的计算机科学中, 栈被定义为一个特殊的容器, 用户可以将数据压入栈中 (入栈, push), 也可以将已经压入栈中的数据弹出 (出栈, pop), 但栈这个容器必须遵守一条规则:
先入栈的数据后出栈 (First In Last Out, FIFO), 多多少少像叠成一叠的书: 先叠上去的书在最下面, 因此要最后才能取出。

'在计算机系统中, 栈则是一个具有以上属性的动态内存区域'。程序可以将数据压入栈中, 也可以将数据从栈顶弹出。压栈操作使得栈增大, 而弹出操作使栈减小。

'在经典的操作系统里, 栈总是向下增长的'。在 i386 下, 栈顶由称为 esp 的寄存器进行定位。压栈的操作使栈顶的地址减小, 弹出的操作使栈顶地址增大。


图 10-3 是一个栈的实例。

这里栈底的地址是 0xbfffffff, 而 esp 寄存器标明了栈顶, 地址为 0xbffffff4。在栈上压入数据会导致 esp 减小, 弹出数据使得 esp 增大。相反, 直接减小 esp 的值也等效于在
栈上开辟空间, 直接增大 esp 的值等效于在栈上回收空间。

'栈在程序运行中具有举足轻重的地位'。

'最重要的, 栈保存了一个函数调用所需要的维护信息', 这常常被称为堆栈帧 (Stack Frame) 或活动记录 (Activate Record)。

堆栈帧一般包括如下几方面内容:

1. 函数的返回地址和参数

2. 临时变量: 包括函数的非静态局部变量以及编译器自动生成的其他临时变量

3. 保存的上下文: 包括在函数调用前后需要保持不变的寄存器


在 i386 中, 一个函数的活动记录用 ebp 和 esp 这两个寄存器划定范围。esp 寄存器始终指向栈的顶部, 同时也就指向了当前函数的活动记录的顶部。
而相对的, ebp 寄存器指向了函数活动记录的一个固定位置, ebp 寄存器又被称为帧指针 (Frame Pointer)。

一个很常见的活动记录示例如图 10-4 所示。

在参数之后的数据 (包括参数) 即是当前函数的活动记录, ebp 固定在图中所示的位置, 不随这个函数的执行而变化, 相反地, esp 始终指向栈顶, 因此随着函数的执行, esp 会不断变化。

'固定不变的 ebp 可以用来定位函数活动记录中的各个数据'。

在 ebp 之前首先是这个函数的返回地址, 它的地址是 ebp+4, 再往前是压入栈中的参数, 它们的地址分别是 ebp+8、ebp+12 等, 视参数数量和大小而定。

ebp 所直接指向的数据是调用该函数前 ebp 的值, 这样在函数返回的时候, ebp 可以通过读取这个值恢复到调用前的值。

之所以函数的活动记录会形成这样的结构, 是因为函数调用本身是如此书写的: 一个 i386 下的函数总是这样调用的:

1. 把所有或一部分参数压入栈中, 如果有其他参数没有入栈, 那么使用某些特定的寄存器传递

2. 把当前指令的下一条指令的地址压入栈中

3. 跳转到函数体执行

其中第 2 步和第 3 步由指令 call 一起执行。跳转到函数体之后即开始执行函数, '而 i386 函数体的"标准"开头是这样的':

• push ebp: 把 ebp 压入栈中 (称为 old ebp)

• mov ebp, esp:ebp = esp (这时 ebp 指向栈顶, 而此时栈顶就是old ebp)

•【可选】sub esp, XXX: 在栈上分配 XXX 字节的临时空间
 
•【可选】push XXX: 如有必要, 保存名为 XXX 寄存器 (可重复多个)

把 ebp 压入栈中, 是为了在函数返回的时候便于恢复以前的 ebp 值。而之所以可能要保存一些寄存器, 在于编译器可能要求某些寄存器在调用前后保持不变, 那么函数就可以在调用开始时
将这些寄存器的值压入栈中, 在结束后再取出。


不难想象, 在函数返回时, 所进行的"标准"结尾与"标准"开头正好相反:

•【可选】pop XXX: 如有必要, 恢复保存过的寄存器

• mov esp, ebp: 恢复 ESP 同时回收局部变量空间

• pop ebp: 从栈中恢复保存的 ebp 的值

• ret: 从栈中取得返回地址, 并跳转到该位置


GCC 编译器有一个参数叫做 -fomit-frame-pointer 可以取消帧指针, 即不使用任何帧指针, 而是通过 esp 直接计算帧上变量的位置。这么做的好处是可以多出一个 ebp 寄存器供使用, 
但是坏处却很多, 比如帧上寻址速度会变慢, 而且没有帧指针之后, 无法准确定函数的调用轨迹(Stack Trace)。所以除非你很清楚你在做什么, 否则请尽量不使用这个参数。


为了加深印象, 下面我们反汇编一个函数看看:

int foo() {
    return 123;
}

这个函数反汇编得到的结果如图 10-5 所示:


我们可以看到头两行保存了旧的 ebp, 并让 ebp 指向当前的栈顶。

接下来的一行指令:

004113A3  sub         esp,0C0h

将栈扩大了 0xC0 个字节, 其中多出来的空间的值并不确定。这么一大段多出来的空间可以存储局部变量、某些临时数据以及调试信息。在第 3 步里, 函数将 3 个寄存器保存在了栈上。这
 3 个寄存器在函数随后的执行中可能被修改, 所以要先保存一下这些寄存器原本的值, 以便在退出函数时恢复。

第 4 步的代码用于调试。

这段汇编大致等价于如下伪代码:

edi = ebp - 0x0C;
ecx = 0x30;
eax = 0xCCCCCCCC;
for (; ecx != 0; --ecx, edi+=4)
 *((int*)edi) = eax;

可以计算出, 0x30 * 4 = 0xC0。所以实际上这段代码将内存地址从 ebp-0xC0 到 ebp 这一段全部初始化为 0xCC。恰好就是第 2 步在栈上分配出来的空间。

在第 5 步, 函数将 0x7B (即 123) 赋值给 eax, 作为返回值传出。'在函数返回之后, 调用方可以通过读取 eax 寄存器来获取返回值'。

接下来的几步是函数的资源清理阶段, 从栈中恢复保存的寄存器、ebp 等。最后使用 ret 指令从函数返回。

以上介绍的是 i386 标准函数进入和退出指令序列, 它们基本的形式为:

push ebp
mov ebp, esp
sub esp, x
[push reg1]
...
[push regn]

函数实际内容

[pop regn]
...
[pop reg1]

mov esp, ebp
pop ebp
ret


其中 x 为栈上开辟出来的临时空间的字节数, reg1...regn 分别代表需要保存的 n 个寄存器。方括号部分为可选项。

不过在有些场合下, 编译器生成函数的进入和退出指令序列时并不按照标准的方式进行。例如一个满足如下要求的 C 函数:


• 函数被声明为 static (不可在此编译单元之外访问)

• 函数在本编译单元仅被直接调用, 没有显示或隐式取地址 (即没有任何函数指针指向过这个函数)

编译器可以确信满足这两条的函数不会在其他编译单元内被调用, 因此可以随意地修改这个函数的各个方面——包括进入和退出指令序列来达到优化的目的。



// !! 10.2.2 调用惯例


函数的调用方和被调用方对函数如何调用有着统一的理解, 例如它们双方都一致地认同函数的参数是按照某个固定的方式压入栈内。如果不这样的话, 函数将无法正确运行。这就好比我们说话时
需要双方对同一个声音有着一致的理解一样, 否则就会产生误解。


假设有一个 foo 函数:

int foo(int n, int m) {
    int a = 0, b = 0;
    ...
}

如果函数的调用方在传递参数时先压入参数 n, 再压入参数 m, 而 foo 函数却认为其调用方应该先压入参数 m, 后压入参数 n, 那么不难想象 foo 内部的 m 和 n 的值将会被交换。

再者如果函数的调用方决定利用寄存器传递参数, 而函数本身却仍然以为参数通过栈传递, 那么显然函数无法获取正确的参数。'因此, 毫无疑问函数的调用方和被调用方对于函数如何调用须要有
一个明确的约定, 只有双方都遵守同样的约定, 函数才能被正确地调用, 这样的约定就称为调用惯例 (Calling Convention)'。


一个调用惯例一般会规定如下几个方面的内容:

1. 函数参数的传递顺序和方式

   函数参数的传递有很多种方式, 最常见的一种是通过栈传递。函数的调用方将参数压入栈中, 函数自己再从栈中将参数取出。对于有多个参数的函数, 调用惯例要规定函数调用方将参数压栈
   的顺序: 是从左至右, 还是从右至左。'有些调用惯例还允许使用寄存器传递参数, 以提高性能'。


2. 栈的维护方式

   在函数将参数压栈之后, 函数被调用, 此后需要将被压入栈中的参数全部弹出, 以使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成, 也可以由函数本身来完成。


3. 名字修饰 (Name-mangling) 的策略

   为了链接的时候对调用惯例进行区分, 调用惯例要对函数本身的名字进行修饰。不同的调用惯例有不同的名字修饰策略。

事实上, 在 C 语言里, 存在着多个调用惯例, 而默认的调用惯例是 cdecl。'任何一个没有显式指定调用惯例的函数都默认是 cdecl 惯例'。

对于函数 foo 的声明, 它的完整形式是:

int _cdecl foo(int n, float m)

_cdecl 是非标准关键字, 在不同的编译器里可能有不同的写法, 例如在 gcc 里就不存在 _cdecl 这样的关键字, 而是使用:

__attribute__((cdecl))

cdecl 这个调用惯例是 C 语言默认的调用惯例, 它的内容如表 10-1 所示。


因此 foo 被修饰之后就变为 _foo。在调用 foo 的时候, 按照 cdecl 的参数传递方式, 具体的堆栈操作如下。


1. 将 m 压入栈

2. 将 n 压入栈

3. 调用 _foo, 此步又分为两个步骤

   a. 将返回地址 (即调用 _foo 之后的下一条指令的地址) 压入栈

   b. 跳转到 _foo 执行


当函数返回之后: sp = sp + 8 (参数出栈, 由于不需要得到出栈的数据, 所以直接调整栈顶位置就可以了)。

因此进入 foo 函数之后, 栈上大致是如图 10-9 所示。

然后在 foo 里面要保存一系列的寄存器, 包括函数调用方的 ebp 寄存器, 以及要为 a 和 b 两个局部变量分配空间。最终的栈的构成会如图 10-10 所示。

对于不同的编译器, 由于分配局部变量和保存寄存器的策略不同, 这个结果可能有出入。


当 foo 返回的时候, 程序首先会使用 pop 恢复保存在栈里的寄存器, 然后从栈里取得返回地址, 返回到调用方。调用方再调整 ESP 将堆栈恢复。

因此有如下代码:

void f(int x, int y){
    ...
    return ;
}

int main() {
    f(1,3);
    return 0;
}

实际执行的操作如图 10-11 所示。

其中虚线指向该指令执行后的栈状态, 实线表示程序的跳转状况。

同样, 对于多级调用, 如果我们有如下代码:

void f(int y){
     printf("y=%d", y);
}

int main(){
    int x = 1;
    f(x);
    return 0;
}


这些代码形成的堆栈格局如图 10-12 所示。

图 10-12 的箭头表示地址的指向关系, 而带下划线的代码表示当前执行的代码。


// !! 10.2.3　函数返回值传递

除了参数的传递之外, 函数与调用方的交互还有一个渠道就是返回值。

函数将返回值存储在 eax 中, 返回后函数的调用方再读取 eax。但是 eax 本身只有 4 个字节, 那么大于 4 字节的返回值是如何传递的呢?

'对于返回 5~8 字节对象的情况, 几乎所有的调用惯例都是采用 eax 和 edx 联合返回的方式进行的'。其中 eax 存储返回值要低 4 字节, 而 edx 存储返回值要高 1~4 字节。

而对于超过 8 字节的返回类型, 我们可以用下列代码来研究:

typedef struct big_thing {
    char buf[128];
} big_thing;

big_thing return_test(){
    big_thing b;
    b[0] = 1;
    return b;
}

int main() {
    big_thing n = return_test();
}

这段代码里的 return_test 的返回值类型是一个长度为 128 字节的结构, 因此无论如何也不可能直接用过 eax 传递。

1. 首先 main 函数在栈上额外开辟了一片空间, 并将这块空间的一部分作为传递返回值的临时对象, 这里称为 temp

2. 将 temp 对象的地址作为隐藏参数传递给 return_test 函数

3. return_test 函数将数据拷贝给 temp 对象, 并将 temp 对象的地址用 eax 传出


函数传递大尺寸的返回值所使用的方法并不是可移植的, 不同的编译器、不同的平台、不同的调用惯例甚至不同的编译参数都有权力采用不同的实现方法。



// !! 声名狼藉的 C++ 返回对象

正如我们看到的, 在 C++ 里返回一个对象的时候, 对象要经过 2 次拷贝构造函数的调用才能够完成返回对象的传递。1 次拷贝到栈上的临时对象里, 另一次把临时对象拷贝到存储返回值的
对象里。

这样带来的恶果就是返回一个较大对象会有非常多的额外开销。

因此 C++ 程序中都尽量避免返回对象。此外, 为了减小返回对象的开销, C++ 提出了返回值优化 (Return Value Optimization, RVO) 这样的技术, 可以将某些场合下的对象拷贝减
少 1 次

cpp_obj return_test(){
    return cpp_obj();
}

在这个例子中, 构造一个 cpp_obj 对象会调用一次 cpp_obj 的构造函数, 在返回这个对象时, 还会调用 cpp_obj 的拷贝构造函数。

C++ 的返回值优化可以将这两步合并, 直接将对象构造在传出时使用的临时对象上, 因此可以减少一次复制过程。



