// !! 10.3　堆与内存管理

// !! 10.3.1　什么是堆

光有栈对于面向过程的程序设计还远远不够, 因为栈上的数据在函数返回的时候就会被释放掉, 所以无法将数据传递至函数外部。而全局变量没有办法动态地产生, 只能在编译的时候定义,
有很多情况下缺乏表现力。在这种情况下, 堆 (Heap) 是唯一的选择。

'堆是一块巨大的内存空间, 常常占据整个虚拟空间的绝大部分'。在这片空间里, 程序可以请求一块连续内存, 并自由地使用, 这块内存在程序主动放弃之前都会一直保持有效。

下面是一个申请堆空间最简单的例子。

int main() {
    char* p = (char *) malloc(1000);
     /* use p as an array of size 1000*/
    free(p);
    return 0;
}

在第 3 行用 malloc 申请了 1000 个字节的空间之后, 程序可以自由地使用这 1000 个字节, 直到程序用 free 函数释放它。


那么 malloc 到底是怎么实现的呢?

有一种做法是, 把进程的内存管理交给操作系统内核去做, 既然内核管理着进程的地址空间, 那么如果它提供一个系统调用, 可以让程序使用这个系统调用申请内存, 不就可以了吗?

'当然这是一种理论上可行的做法,但实际上这样做的性能比较差, 因为每次程序申请或者释放堆空间都需要进行系统调用'。

我们知道系统调用的性能开销是很大的, 当程序对堆的操作比较频繁时, 这样做的结果是会严重影响程序的性能的。'比较好的做法就是程序向操作系统申请一块适当大小的堆空间, 然后由程序
自己管理这块空间, 而具体来讲, 管理着堆空间分配的往往是程序的运行库'。

运行库相当于是向操作系统"批发"了一块较大的堆空间, 然后"零售"给程序用。当全部"售完"或程序有大量的内存需求时, 再根据实际需求向操作系统"进货"。当然运行库在向程序零售堆空间
时, 必须管理它批发来的堆空间, 不能把同一块地址出售两次, 导致地址的冲突。

'于是运行库需要一个算法来管理堆空间, 这个算法就是堆的分配算法'。


// !! 10.3.2　Linux 进程堆管理

进程的地址空间中, 除了可执行文件、共享库和栈之外, 剩余的未分配的空间都可以被用来作为堆空间。

Linux 下的进程堆管理稍微有些复杂, 因为它提供了两种堆空间分配的方式, 即两个系统调用: 一个是 brk() 系统调用, 另外一个是 mmap()。

brk() 的 C 语言形式声明如下:

int brk(void* end_data_segment)

brk() 的作用实际上就是设置进程数据段的结束地址, 即它可以扩大或者缩小数据段 ( Linux 下数据段和 BSS 合并在一起统称数据段)。

'如果我们将数据段的结束地址向高地址移动, 那么扩大的那部分空间就可以被我们使用, 把这块空间拿来作为堆空间是最常见的做法之一'


mmap() 它的作用就是向操作系统申请一段虚拟地址空间, 当然这块虚拟地址空间可以映射到某个文件 (这也是这个系统调用的最初的作用), 当它不将地址空间映射到某个文件时, 我们又
称这块空间为匿名 (Anonymous) 空间, 匿名空间就可以拿来作为堆空间。

void *mmap(void* start, size_t length, int prot, int flags, int fd, off_t offset);

mmap 的前两个参数分别用于指定需要申请的空间的起始地址和长度, 如果起始地址设置为 0, 那么 Linux 系统会自动挑选合适的起始地址。prot/flags 这两个参数用于设置申请的空间的
权限 (可读、可写、可执行) 以及映射类型 (文件映射、匿名空间等), 最后两个参数是用于文件映射时指定文件描述符和文件偏移;


glibc 的 malloc 函数是这样处理用户的空间请求的:

1. 对于小于 128KB 的请求来说, 它会在现有的堆空间里面, 按照堆分配算法为它分配一块空间并返回

2. 对于大于 128KB 的请求来说, 它会使用 mmap() 函数为它分配一块匿名空间, 然后在这个匿名空间中为用户分配空间

当然我们直接使用 mmap 也可以轻而易举地实现 malloc 函数:

void *malloc(size_t nbytes) {
    void* ret = mmap(0, nbytes, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
    if(ret == MAP_FAILED){
        return 0;
    }
    return ret;
}

由于 mmap() 函数是系统虚拟空间申请函数, 它们申请的空间的起始地址和大小都必须是系统页的大小的整数倍, 对于字节数很小的请求如果也使用 mmap 的话, 无疑是会浪费大量的空间


// !! 10.3.4　堆分配算法


对于程序来说, 堆空间只是程序向操作系统申请划出来的一大块地址空间。而程序在通过 malloc 申请内存空间时的大小却是不一定的, 从数个字节到数个 GB 都是有可能的。
于是我们必须将堆空间管理起来, 将它分块地按照用户需求出售给最终的程序, 并且还可以按照一定的方式收回内存。其实这个问题可以归结为: '如何管理一大块连续的内存空间, 能够按照需
求分配、释放其中的空间, 这就是堆分配的算法'。

堆的分配算法有很多种, 有很简单的, 也有些很复杂、适用于某些高性能或者有其他特殊要求的场合。

// !! 1. 空闲链表

空闲链表 (Free List) 的方法实际上就是把堆中各个空闲的块按照链表的方式连接起来, 当用户请求一块空间时, 可以遍历整个列表, 直到找到合适大小的块并且将它拆分; 当用户释放空间
时将它合并到空闲链表中。

'我们首先需要一个数据结构来登记堆空间里所有的空闲空间, 这样才能知道程序请求空间的时候该分配给它哪一块内存'。这样的结构有很多种, 这里介绍最简单的一种——空闲链表。

空闲链表是这样一种结构, 在堆里的每一个空闲空间的开头 (或结尾) 有一个头 (header), 头结构里记录了 prev 和 next 空闲块的地址, 也就是说, 所有的空闲块形成了一个链表。


在这样的结构下如何分配空间呢?

1. 首先在空闲链表里查找足够容纳请求大小的一个空闲块, 然后将这个块分为两部分, 一部分为程序请求的空间, 另一部分为剩余下来的空闲空间

2. 下面将链表里对应原来空闲块的结构更新为新的剩下的空闲块, 如果剩下的空闲块大小为 0, 则直接将这个结构从链表里删除


图 10-16 演示了用户请求一块和空闲块 2 恰好相等的内存空间后堆的状态。


这样的空闲链表实现尽管简单, 但在释放空间的时候, 给定一个已分配块的指针, 堆无法确定这个块的大小。一个简单的解决方法是当用户请求 k 个字节空间的时候, 我们实际分配 k+4 个字
节, 这 4 个字节用于存储该分配的大小, 即 k+4。这样释放该内存的时候只要看看这 4 个字节的值, 就能知道该内存块的大小, 然后将其插入到空闲链表里就可以了。


// !! 2. 位图

针对空闲链表的弊端, 另一种分配方式显得更加稳健。这种方式称为位图 Bitmap, 其核心思想是将整个堆划分为大量的块 (block), 每个块的大小相同。当用户请求内存的时候, 总是分配
整数个块的空间给用户, 第一个块我们称为已分配区域的头 (Head), 其余的称为已分配区域的主体 (Body)。而我们可以使用一个整数数组来记录块的使用情况, 由于每个块只有头/主体/空
闲三种状态, 因此仅仅需要两位即可表示一个块, 因此称为位图。



// !! 3. 对象池

以上介绍的堆管理方法是最为基本的两种, '实际上在一些场合, 被分配对象的大小是较为固定的几个值', 这时候我们可以针对这样的特征设计一个更为高效的堆算法, 称为对象池。

对象池的思路很简单, 如果每一次分配的空间大小都一样, 那么就可以按照这个每次请求分配的大小作为一个单位, 把整个堆空间划分为大量的小块,每次请求的时候只需要找到一个小块就可以
了。

对象池的管理方法可以采用空闲链表, 也可以采用位图, 与它们的区别仅仅在于它假定了每次请求的都是一个固定的大小, 因此实现起来很容易。

实际上很多现实应用中, 堆的分配算法往往是采取多种算法复合而成的。比如对于 glibc 来说, 它对于小于64字节的空间申请是采用类似于对象池的方法; 而对于大于 512 字节的空间申请
采用的是最佳适配算法; 对于大于 64 字节而小于 512 字节的, 它会根据情况采取上述方法中的最佳折中策略; 对于大于 128KB 的申请, 它会使用 mmap 机制直接向操作系统申请空间。