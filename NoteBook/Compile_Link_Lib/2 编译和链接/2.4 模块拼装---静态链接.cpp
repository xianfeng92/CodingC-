// !! 2.4　模块拼装——静态链接

程序设计的模块化是人们一直在追求的目标, 因为当一个系统十分复杂的时候, 我们不得不将一个复杂的系统逐步分割成小的系统以达到各个突破的目的。

一个复杂的软件也如此, 人们把每个源代码模块独立地编译, 然后按照须要将它们组装起来, '这个组装模块的过程就是链接 (Linking)'。

'链接的主要内容就是把各个模块之间相互引用的部分都处理好, 使得各个模块之间能够正确地衔接'。

链接过程主要包括了地址和空间分配 (Address and Storage Allocation)、符号决议 (Symbol Resolution) 和重定位 (Relocation)等这些步骤。

最基本的静态链接过程如图 2-8 所示。每个模块的源代码文件 (如.c) 文件经过编译器编译成目标文件 (Object File, 一般扩展名为 .o), 目标文件和库 (Library) 一起链接形成最
终可执行文件。'最常见的库就是运行时库 (Runtime Library), 它是支持程序运行的基本函数的集合'。库其实是一组目标文件的包, 就是一些最常用的代码编译成目标文件后打包存放。


使用链接器, 你可以直接引用其他模块的函数和全局变量而无须知道它们的地址, 因为链接器在链接的时候, 会根据你所引用的符号 foo, 自动去相应的 func.c 模块查找 foo 的地址, 然后
将 main.c 模块中所有引用到 foo 的指令重新修正, 让它们的目标地址为真正的 foo 函数的地址。这就是静态链接的最基本的过程和作用。

让我们结合具体的 CPU 指令来了解这个过程。假设我们有个全局变量叫做 var, 它在目标文件 A 里面。我们在目标文件 B 里面要访问这个全局变量, 比如我们在目标文件 B 里面有这么一
条指令:

movl    $0x2a, var

这条指令就是给这个 var 变量赋值 0x2a, 相当于 C 语言里面的语句 var = 42。

由于在编译目标文件 B 的时候, 编译器并不知道变量 var 的目标地址, 所以编译器在没法确定地址的情况下, 将这条 mov 指令的目标地址置为 0, 等待链接器在将目标文件 A 和 B 链接
起来的时候再将其修正。

'这个地址修正的过程也被叫做重定位 (Relocation), 每个要被修正的地方叫一个重定位入口 (Relocation Entry)'。