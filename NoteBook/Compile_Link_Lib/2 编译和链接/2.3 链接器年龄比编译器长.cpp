// !! 2.3　链接器年龄比编译器长

原始的链接概念远在高级程序语言发明之前就已经存在了, 当程序修改的时候, 这些位置都要重新计算, 十分繁琐又耗时, 并且很容易出错。这种重新计算各个目标的地址过程被叫做
重定位(Relocation)。

汇编语言使用接近人类的各种符号和标记来帮助记忆, 比如指令采用两个或三个字母的缩写, 记住 jmp 比记住 0001XXXX 是跳转(jump) 指令容易得多了;'最重要的是, 这种符号的方法使
得人们从具体的指令地址中逐步解放出来'。

符号 (Symbol) 这个概念随着汇编语言的普及迅速被使用, 它用来表示一个地址, 这个地址可能是一段子程序(后来发展成函数)的起始地址,也可以是一个变量的起始地址。

有了汇编语言以后, 生产力大大提高了, 随之而来的是软件的规模也开始日渐庞大, 这时程序的代码量也已经开始快速地膨胀, 导致人们要开始考虑将不同功能的代码以一定的方式组织起来,
使得更加容易阅读和理解, 以便于日后修改和重复使用。

自然而然, 人们开始将代码按照功能或性质划分, 分别形成不同的功能模块, 不同的模块之间按照层次结构或其他结构来组织。这个在现代的软件源代码组织中很常见, 比如在 C 语言中, 
最小的单位是变量和函数, 若干个变量和函数组成一个模块, 存放在一个 .c 的源代码文件里, 然后这些源代码文件按照目录结构来组织。

在现代软件开发过程中, 软件的规模往往都很大, 动辄数百万行代码, 如果都放在一个模块肯定无法想象。所以现代的大型软件往往拥有成千上万个模块, 这些模块之间相互依赖又相对独立。
这种按照层次化及模块化存储和组织源代码有很多好处, 比如代码更容易阅读、理解、重用，每个模块可以单独开发、编译、测试, 改变部分代码不需要编译整个程序等。

'在一个程序被分割成多个模块以后, 这些模块之间最后如何组合形成一个单一的程序是须解决的问题'。

模块之间如何组合的问题可以归结为模块之间如何通信的问题, 最常见的属于静态语言的 C/C++ 模块之间通信有两种方式: 一种是模块间的函数调用, 另外一种是模块间的变量访问。

函数访问须知道目标函数的地址, 变量访问也须知道目标变量的地址, 所以这两种方式都可以归结为一种方式, 那就是'模块间符号的引用'。

'模块间依靠符号来通信类似于拼图版, 定义符号的模块多出一块区域, 引用该符号的模块刚好少了那一块区域, 两者一拼接刚好完美组合'

'这种基于符号的模块化的一个直接结果是链接过程在整个程序开发中变得十分重要和突出'。我们在后面将可以看到链接器如何将这些编译后的模块链接到一起, 最终产生一个可以执行的程序。

