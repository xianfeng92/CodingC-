// !! 2.2 编译器做了什么

从最直观的角度来讲, '编译器就是将高级语言翻译成机器语言的一个工具'。比如我们用 C/C++ 语言写的一个程序可以使用编译器将其翻译成机器可以执行的指令及数据。

人们期望能够采用类似于自然语言的语言来描述一个程序, 但是自然语言的形式不够精确, 所以类似于数学定义的编程语言很快就诞生了。

'高级语言使得程序员们能够更加关注程序逻辑的本身, 而尽量少考虑计算机本身的限制, 如字长、内存大小、通信方式、存储方式等'。高级编程语言的出现使得程序开发的效率大大提高,
高级语言的可移植性也使得它在多种计算机平台下能够游刃有余。据研究, 高级语言的开发效率是汇编语言和机器语言的 5 倍以上。

让我们继续回到编译器本身的职责上来, '编译过程一般可以分为 6 步:扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化'。

比如我们有一行C语言的源代码如下:

array[index] = (index + 4) * (2 + 6)

CompilerExpression.c


// !! 2.2.1　词法分析

首先源代码程序被输入到扫描器 (Scanner), 扫描器的任务很简单, 它只是简单地进行词法分析, 运用一种类似于有限状态机 (Finite State Machine) 的算法可以很轻松地'将源代码的
字符序列分割成一系列的记号 (Token)'。

比如上面的那行程序, 总共包含了 28 个非空字符, 经过扫描以后, 产生了 16 个 Token。

词法分析产生的记号一般可以分为如下几类: 关键字、标识符、字面量(包含数字、字符串等) 和特殊符号 (如加号、等号)。在识别记号的同时, 扫描器也完成了其他工作。比如将标识符存放
到符号表, 将数字、字符串常量存放到文字表等, 以备后面的步骤使用。

'有一个叫做 lex 的程序可以实现词法扫描, 它会按照用户之前描述好的词法规则将输入的字符串分割成一个个记号'。因为这样一个程序的存在, 编译器的开发者就无须为每个编译器开发一个
独立的词法扫描器, 而是根据需要改变词法规则就可以了。

另外对于一些有预处理的语言, 比如 C 语言, 它的宏替换和文件包含等工作一般不归入编译器的范围而交给一个独立的预处理器。


// !! 2.2.2　语法分析

接下来'语法分析器 (Grammar Parser) 将对由扫描器产生的 Token 进行语法分析, 从而产生语法树 (Syntax Tree)'。

简单地讲, 由 Grammar Parser 生成的 Syntax Tree 就是以表达式 (Expression) 为节点的树。

正如前面词法分析有 lex 一样, 语法分析也有一个现成的工具叫做 yacc (Yet Another Compiler Compiler)。它也像 lex 一样, 可以根据用户给定的语法规则对输入的 Token 序
列进行解析, 从而构建出一棵 Syntax Tree。


// !! 2.2.3　语义分析

接下来进行的是语义分析, 由语义分析器 (Semantic Analyzer) 来完成。'语法分析仅仅是完成了对表达式的语法层面的分析, 但是它并不了解这个语句是否真正有意义'。

比如 C 语言里面两个指针做乘法运算是没有意义的, 但是这个语句在语法上是合法的; 比如同样一个指针和一个浮点数做乘法运算是否合法等。

'编译器所能分析的语义是静态语义 (Static Semantic), 所谓静态语义是指在编译期可以确定的语义',与之对应的动态语义 (Dynamic Semantic) 就是只有在运行期才能确定的语义。

'静态语义通常包括声明和类型的匹配, 类型的转换'。比如当一个浮点型的表达式赋值给一个整型的表达式时, 其中隐含了一个浮点型到整型转换的过程, 语义分析过程中需要完成这个步骤。
比如将一个浮点型赋值给一个指针的时候, 语义分析程序会发现这个类型不匹配, 编译器将会报错。

'经过语义分析阶段以后, 整个语法树的表达式都被标识了类型; 如果有些类型需要做隐式转换, 语义分析程序会在语法树中插入相应的转换节点'。

语义分析器还对符号表里的符号类型也做了更新。


// !! 2.2.4　中间语言生成

现代的编译器有着很多层次的优化, 往往在源代码级别会有一个优化过程。我们这里所描述的源码级优化器 (Source Code Optimizer), 在不同编译器中可能会有不同的定义或有一些其他
的差异。源代码级优化器会在源代码级别进行优化, 在上例中, 细心的读者可能已经发现, (2 + 6) 这个表达式可以被优化掉, 因为它的值在编译期就可以被确定。

其实直接在语法树上作优化比较困难, 所以源代码优化器往往将整个语法树转换成中间代码 (Intermediate Code),它是语法树的顺序表示, 其实它已经非常接近目标代码了。

中间代码使得编译器可以被分为前端和后端。编译器前端负责产生机器无关的中间代码, 编译器后端将中间代码转换成目标机器代码。这样对于一些可以跨平台的编译器而言, 它们可以针对不同
的平台使用同一个前端和针对不同机器平台的数个后端。


// !! 2.2.5　目标代码生成与优化

源代码级优化器产生中间代码标志着下面的过程都属于编译器后端。编译器后端主要包括代码生成器 (Code Generator) 和目标代码优化器 (Target Code Optimizer)。

代码生成器将中间代码转换成目标机器代码, 这个过程十分依赖于目标机器, 因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等。

'现代的编译器有着异常复杂的结构, 这是因为现代高级编程语言本身非常地复杂'; 比如 C++ 语言的定义就极为复杂, 至今没有一个编译器能够完整支持 C++ 语言标准所规定的所有语言特性。
使得编译过程更为复杂的是有些编译器支持多种硬件平台, 即允许编译器编译出多种目标 CPU 的代码。比如著名的 GCC 编译器就几乎支持所有 CPU 平台, 这也导致了编译器的指令生成过程
更为复杂。

'经过这些扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化, 编译器忙活了这么多个步骤以后, 源代码终于被编译成了目标代码'。

如果我们要把目标代码使用汇编器(AS)编译成真正能够在机器上执行的指令, 那么 index 和 array 的地址应该从哪儿得到呢? 如果 index 和 array 定义在跟上面的源代码同一个编译
单元里面, 那么编译器可以为 index 和 array 分配空间, 确定它们的地址; 那如果是定义在其他的程序模块呢?

这个看似简单的问题引出了我们一个很大的话题: '目标代码中有变量定义在其他模块, 该怎么办?'

事实上, 定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。

'所以现代的编译器可以将一个源代码文件编译成一个未链接的目标文件, 然后由链接器最终将这些目标文件链接起来形成可执行文件'。