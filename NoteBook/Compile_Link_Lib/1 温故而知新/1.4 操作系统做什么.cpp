// !! 1.4　操作系统做什么

'操作系统的一个功能是提供抽象的接口, 另外一个主要功能是管理硬件资源'。

计算机硬件的能力是有限的, 比如一个 CPU 一秒钟能够执行的指令条数是 1 亿条或是 1GB 的内存能够最多同时存储 1GB 的数据。无论你是否使用它, 资源总是那么多。当然我们不希望
自己花钱买回来的硬件成为摆设, 充分挖掘硬件的能力, 使得计算机运行得更有效率, 在更短的时间内处理更多的任务, 才是我们的目标。这对于早期动辄数百万美元的古董计算机来说更是如
此, 人们挖空心思让计算机硬件发挥所有潜能。'一个计算机中的资源主要分 CPU、存储器(包括内存和磁盘) 和 I/O 设备', 我们分别从这三个方面来看看如何挖掘它们的潜力。

// !! 1.4.1　不要让 CPU 打盹

在计算机发展早期, CPU 资源十分昂贵, 如果一个 CPU 只能运行一个程序, 那么当程序读写磁盘时, CPU 就空闲下来了, 这在当时简直就是暴殄天物。

于是人们很快编写了一个监控程序, 当某个程序暂时无须使用 CPU 时, 监控程序就把另外的正在等待 CPU 资源的程序启动, 使得 CPU 能够充分地利用起来。

这种被称为多道程序(Multiprogramming) 的方法看似很原始, 但是它当时的确大大提高了 CPU 的利用率, 不过这种原始的多道程序技术存在最大的问题是程序之间的调度策略太粗糙。
对于多道程序来说, 程序之间不分轻重缓急, 如果有些程序急需使用 CPU 来完成一些任务(比如用户交互的任务), 那么很有可能很长时间后才有机会分配到 CPU。

经过稍微改进, '程序运行模式变成了一种协作的模式', 即每个程序运行一段时间以后都主动让出 CPU 给其他程序, 使得一段时间内每个程序都有机会运行一小段时间。

'这种程序协作模式叫做分时系统(Time-Sharing System)', 这时候的监控程序已经比多道程序要复杂多了, 完整的操作系统雏形已经逐渐形成了。

这种模式就是我们现在很熟悉的'多任务(Multi-tasking) 系统', 操作系统接管了所有的硬件资源, 并且本身运行在一个受硬件保护的级别。所有的应用程序都以进程(Process) 的方式运
行在比操作系统权限更低的级别, 每个进程都有自己独立的地址空间, 使得进程之间的地址空间相互隔离。

CPU 由操作系统统一进行分配, 每个进程根据进程优先级的高低都有机会得到 CPU, 但是, 如果运行时间超出了一定的时间, 操作系统会暂停该进程, 将 CPU 资源分配给其他等待运行的进程。
'这种 CPU 的分配方式即所谓的抢占式(Preemptive), 操作系统可以强制剥夺 CPU 资源并且分配给它认为目前最需要的进程'。

目前几乎所有现代的操作系统都是采用这种方式, 比如我们熟悉的 UNIX、Linux、Windows NT, 以及 Mac OS X 等流行的操作系统。


// !! 1.4.2　设备驱动

操作系统作为硬件层的上层, 它是对硬件的管理和抽象。

'对于操作系统上面的运行库和应用程序来说, 它们希望看到的是一个统一的硬件访问模式'。

当成熟的操作系统出现以后, 硬件逐渐被抽象成了一系列概念。在 UNIX 中, 硬件设备的访问形式跟访问普通的文件形式一样;

这些繁琐的硬件细节全都交给了操作系统, 具体地讲是操作系统中的硬件驱动 (Device Driver) 程序来完成。

提到文件的读取, 那么不得不提到文件系统这个操作系统中最为重要的组成部分之一。文件系统保存了这些文件的存储结构, 负责维护这些数据结构并且保证磁盘中的扇区能够有效地组织和利用。
那么当我们在 Linux 操作系统中, 要读取这个文件的前 4 096 个字节时, 我们会使用一个 read 的系统调用来实现。文件系统收到 read 请求之后, 判断出文件的前 4 096 个字节位于
磁盘的 1000 号逻辑扇区到 1007 号逻辑扇区。然后文件系统就向硬盘驱动发出一个读取逻辑扇区为 1000 号开始的 8 个扇区的请求, 磁盘驱动程序收到这个请求以后就向硬盘发出硬件命令。
向硬件发送 I/O 命令的方式有很多种, 其中最为常见的一种就是通过读写 I/O 端口寄存器来实现。