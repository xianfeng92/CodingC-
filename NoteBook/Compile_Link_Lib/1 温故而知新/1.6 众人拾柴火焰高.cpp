// !! 1.6　众人拾柴火焰高

// !! 线程的访问权限

线程的访问非常自由, 它可以访问进程内存里的所有数据, 但实际运用中线程也拥有自己的私有存储空间, 包括以下几方面:

> 栈 (尽管并非完全无法被其他线程访问, 但一般情况下仍然可以认为是私有的数据)

> 线程局部存储 (Thread Local Storage, TLS)。线程局部存储是某些操作系统为线程单独提供的私有空间, 但通常只具有很有限的容量

> 寄存器 (包括 PC 寄存器), 寄存器是执行流的基本数据, 因此为线程私有



// !! 线程调度与优先级

在单处理器对应多线程的情况下, 并发是一种模拟出来的状态。这样的一个不断在处理器上切换不同的线程的行为称之为线程调度(Thread Schedule)。在线程调度中, 线程通常拥有至少三种
状态, 分别是:

> 运行 (Running): 此时线程正在执行

> 就绪 (Ready): 此时线程可以立刻运行, 但 CPU 已经被占用

> 等待 (Waiting): 此时线程正在等待某一事件(通常是 I/O 或同步) 发生, 无法执行


处于运行中线程拥有一段可以执行的时间, 这段时间称为时间片 (Time Slice) , 当时间片用尽的时候, 该进程将进入就绪状态。如果在时间片用尽之前进程就开始等待某事件, 那么它将进入
等待状态。每当一个线程离开运行状态时, 调度系统就会选择一个其他的就绪线程继续执行。


在 Windows 和 Linux 中, 线程的优先级不仅可以由用户手动设置, '系统还会根据不同线程的表现自动调整优先级, 以使得调度更有效率'。

例如通常情况下, 频繁地进入等待状态(进入等待状态, 会放弃之后仍然可占用的时间份额)的线程(例如处理 I/O 的线程)比频繁进行大量计算、以至于每次都要把时间片全部用尽的线程要受欢
迎得多。

其实道理很简单, 频繁等待的线程通常只占用很少的时间, CPU 也喜欢先捏软柿子。我们一般把频繁等待的线程称之为 IO 密集型线程(IO Bound Thread), 而把很少等待的线程称为 CPU
密集型线程(CPU Bound Thread)。IO 密集型线程总是比 CPU 密集型线程容易得到优先级的提升。

在优先级调度下, 存在一种饿死的现象, 一个线程被饿死, 是说它的优先级较低, 在它执行之前, 总是有较高优先级的线程试图执行, 因此这个低优先级线程始终无法执行。当一个 CPU 密集
型的线程获得较高的优先级时, 许多低优先级的进程就很可能饿死。而一个高优先级的 IO 密集型线程由于大部分时间都处于等待状态, 因此相对不容易造成其他线程饿死。为了避免饿死现象,
调度系统常常会逐步提升那些等待了过长时间的得不到执行的线程的优先级。

在这样的手段下, 一个线程只要等待足够长的时间, 其优先级一定会提高到足够让它执行的程度。


让我们总结一下, 在优先级调度的环境下, 线程的优先级改变一般有三种方式:

•用户指定优先级

•根据进入等待状态的频繁程度提升或降低优先级

•长时间得不到执行而被提升优先级



// !! 可抢占线程和不可抢占线程

我们之前讨论的线程调度有一个特点, 那就是线程在用尽时间片之后会被强制剥夺继续执行的权利, 而进入就绪状态, 这个过程叫做抢占, 即之后执行的别的线程抢占了当前线程。

在不可抢占线程中, 线程主动放弃执行无非两种情况:

•当线程试图等待某事件时(I/O等)

•线程主动放弃时间片

因此, 在不可抢占线程执行的时候, 有一个显著的特点, 那就是线程调度的时机是确定的, 线程调度只会发生在线程主动放弃执行或线程等待某事件的时候。这样可以避免一些因为抢占式线程
里调度时机不确定而产生的问题。'但即使如此, 非抢占式线程在今日已经十分少见'。


// !! Linux 的多线程

Windows 对进程和线程的实现如同教科书一般标准, Windows 内核有明确的线程和进程的概念。在 Windows API 中, 可以使用明确的 API: CreateProcess 和 CreateThread 来创
建进程和线程, 并且有一系列的 API 来操纵它们。但'对于 Linux 来说, 线程并不是一个通用的概念'。

Linux 对多线程的支持颇为贫乏, '事实上, 在 Linux 内核中并不存在真正意义上的线程概念'。Linux 将所有的执行实体(无论是线程还是进程)都称为任务(Task), 每一个任务概念上都
类似于一个单线程的进程, 具有内存空间、执行实体、文件资源等。 不过, Linux 下不同的任务之间可以选择共享内存空间, 因而在实际意义上, 共享了同一个内存空间的多个任务构成了一个
进程, 这些任务也就成了这个进程里的线程。

fork 函数产生一个和当前进程完全一样的新进程, 并和当前进程一样从 fork 函数里返回。

pid_t pid;
if(pid = fork()) {
    ...
}

在 fork 函数调用之后, 新的任务将启动并和本任务一起从 fork 函数返回。但不同的是本任务的 fork 将返回新任务 pid, 而新任务的 fork 将返回0。

fork 产生新任务的速度非常快, 因为 fork 并不复制原任务的内存空间, 而是和原任务一起共享一个写时复制(Copy on Writel,COW)的内存空间。所谓写时复制, 指的是两个任务可以同
时自由地读取内存, 但任意一个任务试图对内存进行修改时, 内存就会复制一份提供给修改方单独使用, 以免影响到其他的任务使用。

'fork 只能够产生本任务的镜像, 因此须要使用 exec 配合才能够启动别的新任务'。exec 可以用新的可执行映像替换当前的可执行映像, 因此在 fork 产生了一个新任务之后, 新任务可
以调用 exec 来执行新的可执行文件。fork 和 exec 通常用于产生新任务, 而如果要产生新线程, 则可以使用 clone。



// !! 1.6.2　线程安全

'多线程程序处于一个多变的环境当中, 可访问的全局变量和堆数据随时都可能被其他的线程改变'。因此多线程程序在并发时数据的一致性变得非常重要。


// !! 竞争与原子操作

我们把单指令的操作称为原子的 Atomic, 因为无论如何, 单条指令的执行是不会被打断的。为了避免出错, 很多体系结构都提供了一些常用操作的原子指令


// !! 同步与锁

为了避免多个线程同时读写同一个数据而产生不可预料的后果, 我们需要将各个线程对同一个数据的访问同步 (Synchronization)。'所谓同步,既是指在一个线程访问数据未结束的时候,
其他线程不得对同一个数据进行访问'。如此, 对数据的访问被原子化了。

同步的最常见方法是使用锁 Lock。每一个线程在访问数据或资源之前首先试图获取 Acquire 锁, 并在访问结束之后释放 Release 锁。'在锁已经被占用的时候试图获取锁时, 线程会等待,
直到锁重新可用'。

'二元信号量 Binary Semaphore 是最简单的一种锁', 它只有两种状态: 占用与非占用。它适合只能被唯一一个线程独占访问的资源。当二元信号量处于非占用状态时, 第一个试图获取该二
元信号量的线程会获得该锁, 并将二元信号量置为占用状态, 此后其他的所有试图获取该二元信号量的线程将会等待, 直到该锁被释放。

对于允许多个线程并发访问的资源, 多元信号量简称信号量 (Semaphore), 它是一个很好的选择。

一个初始值为 N 的信号量允许 N 个线程并发访问。线程访问资源的时候首先获取信号量, 进行如下操作: 

•将信号量的值减 1
•如果信号量的值小于 0, 则进入等待状态, 否则继续执行

访问完资源之后, 线程释放信号量, 进行如下操作:

•将信号量的值加 1
•如果信号量的值小于 1, 唤醒一个等待中的线程

互斥量 (Mutex) 和二元信号量很类似, 资源仅同时允许一个线程访问, 但和信号量不同的是, 信号量在整个系统可以被任意线程获取并释放, 也就是说,'同一个信号量可以被系统中的一个
线程获取之后由另一个线程释放'。而'互斥量则要求哪个线程获取了互斥量, 哪个线程就要负责释放这个锁, 其他线程越俎代庖去释放互斥量是无效的'。


临界区 (Critical Section) 是比互斥量更加严格的同步手段。

读写锁 (Read-Write Lock) 致力于一种更加特定的场合的同步。对于一段数据, 多个线程同时读取总是没有问题的，但假设操作都不是原子型，只要有任何一个线程试图对这个数据进行修改
，就必须使用同步手段来避免出错。

条件变量 (Condition Variable) 作为一种同步手段, 作用类似于一个栅栏。对于条件变量, 线程可以有两种操作, 首先线程可以等待条件变量, 一个条件变量可以被多个线程等待。
其次, 线程可以唤醒条件变量, 此时某个或所有等待此条件变量的线程都会被唤醒并继续支持。'使用条件变量可以让许多线程一起等待某个事件的发生, 当事件发生时(条件变量被唤醒), 所
有的线程可以一起恢复执行'。


// !! 可重入(Reentrant)与线程安全

一个函数被重入, 表示这个函数没有执行完成, 由于外部因素或内部调用, 又一次进入该函数执行。一个函数被称为可重入的, 表明该函数被重入之后不会产生任何不良后果。
































