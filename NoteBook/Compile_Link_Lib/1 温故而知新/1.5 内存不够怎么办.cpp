// !! 1.5　内存不够怎么办

'进程的总体目标是希望每个进程从逻辑上来看都可以独占计算机的资源'。操作系统的多任务功能使得 CPU 能够在多个进程之间很好地共享, 从进程的角度看好像是它独占了 CPU 而不用考
虑与其他进程分享 CPU 的事情。操作系统的 I/O 抽象模型也很好地实现了 I/O 设备的共享和抽象, 那么唯一剩下的就是主存, 也就是内存的分配问题了。

为了更有效地利用硬件资源, 我们必须同时运行多个程序, 正如前面的多道程序、分时系统和多任务中一样, 当我们能够同时运行多个程序时, CPU 的利用率将会比较高。'那么很明显的一个问
题是, 如何将计算机上有限的物理内存分配给多个程序使用'。

假设我们的计算机有 128 MB内存, 程序 A 运行需要 10MB, 程序 B 需要 100 MB, 程序 C 需要 20 MB。如果我们需要同时运行程序 A 和 B, 那么比较直接的做法是将内存的前 10 MB
分配给程序 A, 10 MB~110 MB 分配给 B。这样就能够实现 A 和 B 两个程序同时运行, 但是这种简单的内存分配策略问题很多。


'地址空间不隔离'

所有程序都直接访问物理地址, 程序所使用的内存空间不是相互隔离的。恶意的程序可以很容易改写其他程序的内存数据, 以达到破坏的目的; 有些非恶意的、但是有臭虫的程序可能不小心修
改了其他程序的数据, 就会使其他程序也崩溃, 这对于需要安全稳定的计算环境的用户来说是不能容忍的。用户希望他在使用计算机的时候, 其中一个任务失败了, 至少不会影响其他任务。

'内存使用效率低'

由于没有有效的内存管理机制, 通常需要一个程序执行时, 监控程序就将整个程序装入内存中然后开始执行。如果我们忽然需要运行程序 C, 那么这时内存空间其实已经不够了, 这时候我们可
以用的一个办法是将其他程序的数据暂时写到磁盘里面, 等到需要用到的时候再读回来。由于程序所需要的空间是连续的, 那么这个例子里面, 如果我们将程序 A 换出到磁盘所释放的内存空
间是不够的, 所以只能将 B 换出到磁盘, 然后将 C 读入到内存开始运行。可以看到整个过程中有大量的数据在换入换出, 导致效率十分低下。


'程序运行的地址不确定'

因为程序每次需要装入运行时,我们都需要给它从内存中分配一块足够大的空闲区域, 这个空闲区域的位置是不确定的。这给程序的编写造成了一定的麻烦, 因为程序在编写时, 它访问数据和指
令跳转时的目标地址很多都是固定的, 这涉及程序的重定位问题。


解决这几个问题的思路就是使用我们前文提到过的法宝: '增加中间层, 即使用一种间接的地址访问方法'。整个想法是这样的, 我们把程序给出的地址看作是一种虚拟地址(Virtual Address),
然后通过某些映射的方法, 将这个虚拟地址转换成实际的物理地址。

这样, '只要我们能够妥善地控制这个虚拟地址到物理地址的映射过程, 就可以保证任意一个程序所能够访问的物理内存区域跟另外一个程序相互不重叠, 以达到地址空间隔离的效果'。


// !! 1.5.1　关于隔离

用户程序在运行时不希望介入到这些复杂的存储器管理过程中, 作为普通的程序, 它需要的是一个简单的执行环境, 有一个单一的地址空间、有自己的 CPU, 好像整个程序占有整个计算机而
不用关心其他的程序(当然程序间通信的部分除外, 因为这是程序主动要求跟其他程序通信和联系)。

'所谓的地址空间是个比较抽象的概念, 你可以把它想象成一个很大的数组, 每个数组的元素是一个字节', 而这个数组大小由地址空间的地址长度决定, 比如 32 位的地址空间的大小为 
2^32 = 4 294 967 296 字节, 即 4GB, 地址空间有效的地址是 0~4 294 967 295, 用十六进制表示就是 0x00000000~0xFFFFFFFF。

地址空间分两种: 虚拟地址空间 (Virtual Address Space) 和物理地址空间 (Physical Address Space)。物理地址空间是实实在在存在的, 存在于计算机中, 而且对于每一台计算机
来说只有唯一的一个, 你可以把物理空间想象成物理内存

虚拟地址空间是指虚拟的、人们想象出来的地址空间, 其实它并不存在, 每个进程都有自己独立的虚拟空间, 而且每个进程只能访问自己的地址空间, 这样就有效地做到了进程的隔离。


// !!1.5.2　分段 (Segmentation)

最开始人们使用的是一种叫做分段(Segmentation)的方法, 基本思路是把一段与程序所需要的内存空间大小的虚拟空间映射到某个地址空间。

分段的方法基本解决了上面提到的3个问题中的第一个和第三个。首先它做到了地址隔离, 因为程序 A 和程序 B 被映射到了两块不同的物理空间区域, 它们之间没有任何重叠, 如果程序 A 访问虚
拟空间的地址超出了 0x00A00000 这个范围, 那么硬件就会判断这是一个非法的访问,拒绝这个地址请求, 并将这个请求报告给操作系统或监控程序, 由它来决定如何处理。再者, 对于每个程
序来说, 无论它们被分配到物理地址的哪一个区域, 对于程序来说都是透明的, 它们不需要关心物理地址的变化, 它们只需要按照从地址 0x00000000 到 0x00A00000 来编写程序、放置变
量，所以程序不再需要重定位。

但是分段的这种方法还是没有解决我们的第二个问题, 即内存使用效率的问题。'分段对内存区域的映射还是按照程序为单位', 如果内存不足, 被换入换出到磁盘的都是整个程序, 这样势必会造
成大量的磁盘访问操作, 从而严重影响速度, 这种方法还是显得粗糙，粒度比较大。

事实上, '根据程序的局部性原理, 当一个程序在运行时, 在某个时间段内, 它只是频繁地用到了一小部分数据, 也就是说, 程序的很多数据其实在一个时间段内都是不会被用到的'。人们很自然
地想到了更小粒度的内存分割和映射的方法, 使得程序的局部性原理得到充分的利用, 大大提高了内存的使用率。这种方法就是分页(Paging)。


// !! 1.5.3　分页 (Paging)

'分页的基本方法是把地址空间人为地等分成固定大小的页', 每一页的大小由硬件决定, 或硬件支持多种大小的页, 由操作系统选择决定页的大小。比如 Intel Pentium 系列处理器支持
4KB 或 4MB 的页大小, 那么操作系统可以选择每页大小为 4KB, 也可以选择每页大小为 4MB, 但是在同一时刻只能选择一种大小, 所以对整个系统来说, 页就是固定大小的。'目前几乎所
有的 PC 上的操作系统都使用 4KB 大小的页'。我们使用的 PC 机是 32 位的虚拟地址空间, 也就是 4GB, 那么按 4KB 每页分的话. 总共有 1048 576 个页。物理空间也是同样的分法。

在这里, 我们把虚拟空间的页就叫虚拟页(VP, Virtual Page), 把物理内存中的页叫做物理页(PP, Physical Page), 把磁盘中的页叫做磁盘页(DP, Disk Page)。

我们可以看到虚拟空间的有些页被映射到同一个物理页, 这样就可以实现内存共享。

'保护也是页映射的目的之一, 简单地说就是每个页可以设置权限属性, 谁可以修改, 谁可以访问等', 而只有操作系统有权限修改这些属性, 那么操作系统就可以做到保护自己和保护进程。

虚拟存储的实现需要依靠硬件的支持, 对于不同的 CPU 来说是不同的。但是几乎所有的硬件都采用一个叫 MMU(Memory Management Unit) 的部件来进行页映射。一般 MMU 都集成在 
CPU 内部了, 不会以独立的部件存在。