// !! 4.3　COMMON块

正如前面提到过的, 由于弱符号机制允许同一个符号的定义存在于多个文件中, 所以可能会导致的一个问题是: 如果一个弱符号定义在多个目标文件中, 而它们的类型又不同, 怎么办? 目前的
链接器本身并不支持符号的类型, 即变量类型对于链接器来说是透明的, 它只知道一个符号的名字, 并不知道类型是否一致。那么当我们定义的多个符号定义类型不一致时, 链接器该如何处理
呢?

让我们来分析一下多个符号定义类型不一致的几种情况, 主要分三种情况:

• 两个或两个以上强符号类型不一致

• 有一个强符号, 其他都是弱符号, 出现类型不一致

• 两个或两个以上弱符号类型不一致

对于上述三种情况, 第一种情况是无须额外处理的, 因为多个强符号定义本身就是非法的, 链接器会报符号多重定义错误。

事实上, 现在的编译器和链接器都支持一种叫 COMMON 块 (Common Block) 的机制, 当不同的目标文件需要的 COMMON 块空间大小不一致时, 以最大的那块为准。

现代的链接机制在处理弱符号的时候, 采用的就是与 COMMON 块一样的机制。


当然 COMMON 类型的链接规则是针对符号都是弱符号的情况, 如果其中有一个符号为强符号, 那么最终输出结果中的符号所占空间与强符号相同。

现在我们再回头总结性地思考关于未初始化的全局变量的问题:

'在目标文件中, 编译器为什么不直接把未初始化的全局变量也当作未初始化的局部静态变量一样处理, 为它在 BSS 段分配空间, 而是将其标记为一个 COMMON 类型的变量'?

通过了解链接器处理多个弱符号的过程, 我们可以想到, '当编译器将一个编译单元编译成目标文件的时候, 如果该编译单元包含了弱符号(未初始化的全局变量就是典型的弱符号), 那么该弱符
号最终所占空间的大小在此时是未知的, 因为有可能其他编译单元中该符号所占的空间比本编译单元该符号所占的空间要大'。所以编译器此时无法为该弱符号在 BSS 段分配空间, 因为所须要
空间的大小未知。'但是链接器在链接过程中可以确定弱符号的大小, 因为当链接器读取所有输入目标文件以后, 任何一个弱符号的最终大小都可以确定了', 所以它可以在最终输出文件的 BSS 
段为其分配空间。所以总体来看,未初始化全局变量最终还是被放在 BSS 段的。

GCC 的 -fno-common 也允许我们把所有未初始化的全局变量不以 COMMON 块的形式处理, 或者使用 __attribute__ 扩展:

int global __attribute__((nocommon));

'一旦一个未初始化的全局变量不是以 COMMON 块的形式存在, 那么它就相当于一个强符号, 如果其他目标文件中还有同一个变量的强符号定义, 链接时就会发生符号重复定义错误'