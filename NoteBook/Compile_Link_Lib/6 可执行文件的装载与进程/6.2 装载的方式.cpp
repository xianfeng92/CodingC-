// !! 6.2　装载的方式

程序执行时所需要的指令和数据必须在内存中才能够正常运行, 最简单的办法就是将程序运行所需要的指令和数据全都装入内存中, 这样程序就可以顺利运行, 这就是最简单的静态装入的
办法。但是很多情况下程序所需要的内存数量大于物理内存的数量, 当内存的数量不够时, 根本的解决办法就是添加内存。相对于磁盘来说, 内存是昂贵且稀有的, 这种情况自计算机磁盘诞生
以来一直如此。

'所以人们想尽各种办法, 希望能够在不添加内存的情况下让更多的程序运行起来, 尽可能有效地利用内存'。后来研究发现, '程序运行时是有局部性原理的', 所以我们可以将程序最常用的
部分驻留在内存中, 而将一些不太常用的数据存放在磁盘里面, 这就是动态装入的基本原理。

'覆盖装入 (Overlay) 和页映射 (Paging) 是两种很典型的动态装载方法', 它们所采用的思想都差不多, 原则上都是利用了程序的局部性原理。

动态装入的思想是程序用到哪个模块, 就将哪个模块装入内存, 如果不用就暂时不装入, 存放在磁盘中。


// !! 6.2.1　覆盖装入

覆盖装入在没有发明虚拟存储之前使用比较广泛, 现在已经几乎被淘汰了。



// !! 6.2.2　页映射

页映射是虚拟存储机制的一部分, 它随着虚拟存储的发明而诞生。

页映射不是一下子就把程序的所有数据和指令都装入内存, 而是将内存和所有磁盘中的数据和指令按照页 (Page) 为单位划分成若干个页, 以后所有的装载和操作的单位就是页。以目前的情
况, 硬件规定的页的大小有 4 096 字节、8 192 字节、2 MB、4 MB 等, 最常见的 Intel IA32 处理器一般都使用 4 096 字节的页, 那么 512 MB 的物理内存就拥有 
512 * 1024 * 1024 / 4 096 = 131 072 个页。

为了演示页映射的基本机制, 假设我们的 32 位机器有 16 KB 的内存, 每个页大小为 4 096 字节, 则共有 4 个页, 如表 6-1 所示。

假设程序所有的指令和数据总和为 32 KB, 那么程序总共被分为 8 个页。我们将它们编号为 P0~P7。很明显, 16 KB 的内存无法同时将 32 KB 的程序装入, 那么我们将按照动态装入的
原理来进行整个装入过程。

如果程序刚开始执行时的入口地址在 P0, 这时装载管理器发现程序的 P0 不在内存中, 于是将内存 F0 分配给 P0, 并且将 P0 的内容装入 F0; 运行一段时间以后, 程序需要用到 P5, 于
是装载管理器将 P5 装入 F1; 就这样, 当程序用到 P3 和 P6 的时候, 它们分别被装入到了 F2 和 F3, 它们的映射关系如图 6-4 所示。

很明显, 如果这时候程序只需要 P0、P3、P5 和 P6 这 4 个页, 那么程序就能一直运行下去。但是问题很明显, 如果这时候程序需要访问 P4, 那么装载管理器必须做出抉择, 它必须放弃
目前正在使用的 4 个内存页中的其中一个来装载 P4。'至于选择哪个页, 我们有很多种算法可以选择', 比如可以选择 F0, 因为它是第一个被分配掉的内存页(这个算法我们可以称之为 
FIFO, 先进先出算法); 假设装载管理器发现 F2 很少被访问到, 那么我们可以选择 F2 (这种算法可以称之为 LUR, 最少使用算法)。

可能很多读者已经发现了, '这个所谓的装载管理器就是现代的操作系统, 更加准确地讲就是操作系统的存储管理器'。


