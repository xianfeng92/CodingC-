// !! 6.1　进程虚拟地址空间

// !! 程序和进程有什么区别

程序 (或者狭义上讲可执行文件) 是一个静态的概念, '它就是一些预先编译好的指令和数据集合的一个文件'; 进程则是一个动态的概念, 它是程序运行时的一个过程, 很多时候把动态库
叫做运行时 (Runtime) 也有一定的含义。

有人做过一个很有意思的比喻, 说把程序和进程的概念跟做菜相比较的话, 那么程序就是菜谱, 计算机的 CPU 就是人, 相关的厨具则是计算机的其他硬件, 整个炒菜的过程就是一个进程。

我们知道每个程序被运行起来以后, 它将拥有自己独立的虚拟地址空间 (Virtual Address Space), '这个虚拟地址空间的大小由计算机的硬件平台决定, 具体地说是由 CPU 的位数决
定的'。'硬件决定了地址空间的最大理论上限, 即硬件的寻址空间大小', 比如 32 位的硬件平台决定了虚拟地址空间的地址为 0 到 2^32 -1, 即 0x00000000 ~ 0xFFFFFFFF, 也就是
我们常说的 4 GB 虚拟空间大小; 而 64 位的硬件平台具有 64 位寻址能力, 它的虚拟地址空间达到了 264 字节, 即 0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF, 总共
17 179 869 184 GB, 这个寻址能力从现在来看, 几乎是无限的, 但是历史总是会嘲弄人, 或许有一天我们会觉得 64 位的地址空间很小, 就像我们现在觉得 32 位地址不够用一样。

'其实从程序的角度看, 我们可以通过判断 C 语言程序中的指针所占的空间来计算虚拟地址空间的大小'。一般来说, C 语言指针大小的位数与虚拟空间的位数相同, 如 32 位平台下的指针
为 32 位, 即 4 字节; 64 位平台下的指针为 64 位, 即 8 字节。

那么 32 位平台下的 4 GB 虚拟空间, 我们的程序是否可以任意使用呢? 很遗憾, 不行。因为程序在运行的时候处于操作系统的监管下, 操作系统为了达到监控程序运行等一系列目的,进程
的虚拟空间都在操作系统的掌握之中。进程只能使用那些操作系统分配给进程的地址, 如果访问未经允许的空间, 那么操作系统就会捕获到这些访问, 将进程的这种访问当作非法操作, 强制结
束进程。

Linux 下的 Segmentation fault 很多时候是因为进程访问了未经允许的地址。

那么到底这 4 GB 的进程虚拟地址空间是怎样的分配状态呢? 

首先以 Linux 操作系统作为例子, 默认情况下, Linux 操作系统将进程的虚拟地址空间做了如图 6-1 所示的分配。

整个 4 GB 被划分成两部分, 其中操作系统本身用去了一部分: 从地址 0xC00000000 到 0xFFFFFFFF, 共 1 GB。剩下的从 0x00000000 地址开始到 0xBFFFFFFF 共 3 GB 的空间
都是留给进程使用的。

那么从原则上讲, 我们的进程最多可以使用 3 GB 的虚拟空间, 也就是说整个进程在执行的时候, 所有的代码、数据包括通过 C 语言 malloc() 等方法申请的虚拟空间之和不可以超过 3GB。

在现代的程序中, 3 GB 的虚拟空间有时候是不够用的, 比如一些大型的数据库系统、数值计算、图形图像处理、虚拟现实、游戏等程序需要占用的内存空间较大, 这使得 32 位硬件平台的虚
拟地址空间显得捉襟见肘。

当然一本万利的方法就是使用 64 位处理器, 把虚拟地址空间扩展到 17 179 869 184 GB。当然不是人人都能顺利地更换 64 位处理器, 更何况有很多现有的程序只能运行在 32 位处理
器下。


// !! PAE

32 位的 CPU 下, 程序使用的空间能不能超过 4GB 呢? 这个问题其实应该从两个角度来看, 首先, 问题里面的空间如果是指虚拟地址空间, 那么答案是否。因为 32 位的 CPU 只能使
用 32 位的指针, 它最大的寻址范围是 0 到 4GB; 如果问题里面的空间指计算机的内存空间, 那么答案为是。

Intel 自从 1995 年的 Pentium Pro CPU 开始采用了 36 位的物理地址, 也就是可以访问高达 64 GB 的物理内存。

从硬件层面上来讲, 原先的 32 位地址线只能访问最多 4GB 的物理内存。'但是自从扩展至 36 位地址线之后, Intel 修改了页映射的方式, 使得新的映射方式可以访问到更多的物理内
存'。 Intel 把这个地址扩展方式叫做 PAE (Physical Address Extension)。

当然扩展的物理地址空间, 对于普通应用程序来说正常情况下感觉不到它的存在, 因为这主要是操作系统的事, 在应用程序里, 只有 32 位的虚拟地址空间。

那么应用程序该如何使用这些大于常规的内存空间呢? 一个很常见的方法就是操作系统提供一个窗口映射的方法, 把这些额外的内存映射到进程地址空间中来。

'当然这只是一种补救 32 位地址空间不够大时的非常规手段, 真正的解决方法还是应该使用 64 位的处理器和操作系统'。