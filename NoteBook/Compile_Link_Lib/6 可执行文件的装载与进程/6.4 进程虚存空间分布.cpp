// !! 6.4　进程虚存空间分布

// !! 6.4.1　ELF 文件链接视图和执行视图

在一个正常的进程中, 可执行文件中包含的往往不止代码段, 还有数据段、BSS 等, 所以映射到进程虚拟空间的往往不止一个段。

当段的数量增多时, 就会产生空间浪费的问题。因为我们知道, ELF 文件被映射时, 是以系统的页长度作为单位的, 那么每个段在映射时的长度应该都是系统页长度的整数倍; 如果不是, 那
么多余部分也将占用一个页。一个 ELF 文件中往往有十几个段, 那么内存空间的浪费是可想而知的。

有没有办法尽量减少这种内存浪费呢？

'当我们站在操作系统装载可执行文件的角度看问题时, 可以发现它实际上并不关心可执行文件各个段所包含的实际内容, 操作系统只关心一些跟装载相关的问题, 最主要的是段的权限'
(可读、可写、可执行)。

ELF 文件中, 段的权限往往只有为数不多的几种组合, 基本上是三种:

• 以代码段为代表的权限为可读可执行的段

• 以数据段和 BSS 段为代表的权限为可读可写的段

• 以只读数据段为代表的权限为只读的段

那么我们可以找到一个很简单的方案就是: '对于相同权限的段, 把它们合并到一起当作一个段进行映射'。


比如有两个段分别叫 .text 和 .init, 它们包含的分别是程序的可执行代码和初始化代码, 并且它们的权限相同, 都是可读并且可执行的。假设 .text 为 4 097 字节, .init 为 512 
字节, 这两个段分别映射的话就要占用三个页面, 但是, 如果将它们合并成一起映射的话只须占用两个页面, 如图 6-7 所示。

ELF 可执行文件引入了一个概念叫做 Segment, 一个 Segment 包含一个或多个属性类似的 Section。正如我们上面的例子中看到的, 如果将 .text 段和 .init 段合并在一起看作是一
个 Segment, 那么装载的时候就可以将它们看作一个整体一起映射, 也就是说映射以后在进程虚存空间中只有一个相对应的 VMA, 而不是两个, '这样做的好处是可以很明显地减少页面内部
碎片, 从而节省了内存空间'。

'Segment 的概念实际上是从装载的角度重新划分了 ELF 的各个段'。

在将目标文件链接成可执行文件的时候,链接器会尽量把相同权限属性的段分配在同一空间。'比如可读可执行的段都放在一起, 这种段的典型是代码段'; 可读可写的段都放在一起, 这种段的典型
是数据段。'在 ELF 中把这些属性相似的、又连在一起的段叫做一个 Segment', 而系统正是按照 Segment 而不是 Section 来映射可执行文件的。


下面的例子是一个很小的程序, 程序本身是不停地循环执行 sleep 操作, 除非用户发信号给它, 否则就一直运行。它的源代码如下:

#include <stdio.h>

int main() {
    while(1) {
        sleep(1000);
    }
    return 0;
}

我们使用静态连接的方式将其编译连接成可执行文件, 然后得到的可执行文件 SectionMapping.elf 是一个 Linux 下很典型的可执行文件:

> gcc -static SectionMapping.c -o SectionMapping.elf

使用 readelf 可以看到, 这个可执行文件中总共有 32 个段 (Section):

readelf -S SectionMapping.elf
There are 32 section headers, starting at offset 0xd4618:

节头：
  [号] 名称              类型             地址              偏移量
       大小              全体大小          旗标   链接   信息   对齐
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .note.gnu.propert NOTE             0000000000400270  00000270
       0000000000000020  0000000000000000   A       0     0     8
  [ 2] .note.gnu.build-i NOTE             0000000000400290  00000290
       0000000000000024  0000000000000000   A       0     0     4
  [ 3] .note.ABI-tag     NOTE             00000000004002b4  000002b4
       0000000000000020  0000000000000000   A       0     0     4
  [ 4] .rela.plt         RELA             00000000004002d8  000002d8
       0000000000000240  0000000000000018  AI       0    20     8
  [ 5] .init             PROGBITS         0000000000401000  00001000
       000000000000001b  0000000000000000  AX       0     0     4
  [ 6] .plt              PROGBITS         0000000000401020  00001020
       0000000000000180  0000000000000000  AX       0     0     16
  [ 7] .text             PROGBITS         00000000004011a0  000011a0
       0000000000091b40  0000000000000000  AX       0     0     16
  [ 8] __libc_freeres_fn PROGBITS         0000000000492ce0  00092ce0
       0000000000001ca0  0000000000000000  AX       0     0     16
  [ 9] .fini             PROGBITS         0000000000494980  00094980
       000000000000000d  0000000000000000  AX       0     0     4
  [10] .rodata           PROGBITS         0000000000495000  00095000
       000000000001bfec  0000000000000000   A       0     0     32
  [11] .stapsdt.base     PROGBITS         00000000004b0fec  000b0fec
       0000000000000001  0000000000000000   A       0     0     1
  [12] .eh_frame         PROGBITS         00000000004b0ff0  000b0ff0
       000000000000a63c  0000000000000000   A       0     0     8
  [13] .gcc_except_table PROGBITS         00000000004bb62c  000bb62c
       00000000000000b1  0000000000000000   A       0     0     1
  [14] .tdata            PROGBITS         00000000004bd0c0  000bc0c0
       0000000000000020  0000000000000000 WAT       0     0     8
  [15] .tbss             NOBITS           00000000004bd0e0  000bc0e0
       0000000000000040  0000000000000000 WAT       0     0     8
  [16] .init_array       INIT_ARRAY       00000000004bd0e0  000bc0e0
       0000000000000010  0000000000000008  WA       0     0     8
  [17] .fini_array       FINI_ARRAY       00000000004bd0f0  000bc0f0
       0000000000000010  0000000000000008  WA       0     0     8
  [18] .data.rel.ro      PROGBITS         00000000004bd100  000bc100
       0000000000002df4  0000000000000000  WA       0     0     32
  [19] .got              PROGBITS         00000000004bfef8  000beef8
       00000000000000f0  0000000000000000  WA       0     0     8
  [20] .got.plt          PROGBITS         00000000004c0000  000bf000
       00000000000000d8  0000000000000008  WA       0     0     8
  [21] .data             PROGBITS         00000000004c00e0  000bf0e0
       0000000000001a50  0000000000000000  WA       0     0     32
  [22] __libc_subfreeres PROGBITS         00000000004c1b30  000c0b30
       0000000000000048  0000000000000000  WA       0     0     8
  [23] __libc_IO_vtables PROGBITS         00000000004c1b80  000c0b80
       00000000000006a8  0000000000000000  WA       0     0     32
  [24] __libc_atexit     PROGBITS         00000000004c2228  000c1228
       0000000000000008  0000000000000000  WA       0     0     8
  [25] .bss              NOBITS           00000000004c2240  000c1230
       0000000000001718  0000000000000000  WA       0     0     32
  [26] __libc_freeres_pt NOBITS           00000000004c3958  000c1230
       0000000000000028  0000000000000000  WA       0     0     8
  [27] .comment          PROGBITS         0000000000000000  000c1230
       000000000000002b  0000000000000001  MS       0     0     1
  [28] .note.stapsdt     NOTE             0000000000000000  000c125c
       00000000000013e8  0000000000000000           0     0     4
  [29] .symtab           SYMTAB           0000000000000000  000c2648
       000000000000afb0  0000000000000018          30   735     8
  [30] .strtab           STRTAB           0000000000000000  000cd5f8
       0000000000006ec5  0000000000000000           0     0     1
  [31] .shstrtab         STRTAB           0000000000000000  000d44bd
       0000000000000157  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)


我们可以使用 readelf 命令来查看 ELF 的 Segment。正如描述 Section 属性的结构叫做段表, 描述 Segment 的结构叫程序头 (Program Header), 它描述了 ELF 文件该如何被
操作系统映射到进程的虚拟空间:

readelf -l SectionMapping.elf

Elf 文件类型为 EXEC (可执行文件)
Entry point 0x401b90
There are 10 program headers, starting at offset 64

程序头：
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x0000000000000518 0x0000000000000518  R      0x1000
  LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000
                 0x000000000009398d 0x000000000009398d  R E    0x1000
  LOAD           0x0000000000095000 0x0000000000495000 0x0000000000495000
                 0x00000000000266dd 0x00000000000266dd  R      0x1000
  LOAD           0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0
                 0x0000000000005170 0x00000000000068c0  RW     0x1000
  NOTE           0x0000000000000270 0x0000000000400270 0x0000000000400270
                 0x0000000000000020 0x0000000000000020  R      0x8
  NOTE           0x0000000000000290 0x0000000000400290 0x0000000000400290
                 0x0000000000000044 0x0000000000000044  R      0x4
  TLS            0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0
                 0x0000000000000020 0x0000000000000060  R      0x8
  GNU_PROPERTY   0x0000000000000270 0x0000000000400270 0x0000000000400270
                 0x0000000000000020 0x0000000000000020  R      0x8
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0
                 0x0000000000002f40 0x0000000000002f40  R      0x1

 Section to Segment mapping:
  段节...
   00     .note.gnu.property .note.gnu.build-id .note.ABI-tag .rela.plt 
   01     .init .plt .text __libc_freeres_fn .fini 
   02     .rodata .stapsdt.base .eh_frame .gcc_except_table 
   03     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data __libc_subfreeres __libc_IO_vtables __libc_atexit .bss __libc_freeres_ptrs 
   04     .note.gnu.property 
   05     .note.gnu.build-id .note.ABI-tag 
   06     .tdata .tbss 
   07     .note.gnu.property 
   08     
   09     .tdata .init_array .fini_array .data.rel.ro .got 

我们可以看到, 这个可执行文件中共有 10 个Segment。从装载的角度看, 我们目前只关心 4 个 LOAD 类型的 Segment, 因为只有它是需要被映射的, 其他的诸如 NOTE、TLS、
GNU_STACK 都是在装载时起辅助作用的。

很明显, 所有相同属性的 Section 被归类到一个 Segment, 并且映射到同一个 VMA。

所以总的来说, Segment 和 Section 是从不同的角度来划分同一个 ELF 文件。这个在 ELF 中被称为不同的视图(View), 从 Section 的角度来看 ELF 文件就是链接视图
(Linking View), 从 Segment 的角度来看就是执行视图 (Execution View)。

ELF 可执行文件中有一个专门的数据结构叫做程序头表 (Program Header Table) 用来保存 Segment 的信息。

因为 ELF 目标文件不需要被装载, 所以它没有程序头表, 而 ELF 的可执行文件和共享库文件都有。

跟段表结构一样,程序头表也是一个结构体数组, 它的结构体如下:

typedef struct {
    lf32_Word p_type;
    Elf32_Off p_offset;
    Elf32_Addr p_vaddr;
    Elf32_Addr p_paddr;
    Elf32_Word p_filesz;
    Elf32_Word p_memsz;
    Elf32_Word p_flags;
    Elf32_Word p_align;
} Elf32_Phdr;


我们来看 Elf32_Phdr 结构的各个成员的基本含义, 如表 6-2 所示。

对于 LOAD 类型的 Segment 来说, p_memsz 的值不可以小于 p_filesz, 否则就是不符合常理的。但是, 如果 p_memsz 的值大于 p_filesz 又是什么意思呢? 如果 p_memsz 大于
p_filesz, 就表示该 Segment 在内存中所分配的空间大小超过文件中实际的大小, 这部分多余的部分则全部填充为 0。这样做的好处是, 我们在构造 ELF 可执行文件时不需要再额外设立
BSS 的 Segment了, 可以把数据 Segment 的 p_memsz 扩大, 那些额外的部分就是 BSS。因为数据段和 BSS 的唯一区别就是: 数据段从文件中初始化内容, 而 BSS 段的内容全都初始
化为 0。这也就是我们在前面的例子中只看到了两个 LOAD 类型的段, 而不是三个, BSS 已经被合并到了数据类型的段里面。


// !! 6.4.2　堆和栈


很多情况下, 一个进程中的栈和堆分别都有一个对应的 VMA。


在 Linux 下, 我们可以通过查看 /proc 来查看进程的虚拟空间分布:

> ./SectionMapping.elf&
[1] 121695
> cat /proc/121695/maps
00400000-00401000 r--p 00000000 08:05 2505887                           SectionMapping.elf
00401000-00495000 r-xp 00001000 08:05 2505887                           SectionMapping.elf
00495000-004bc000 r--p 00095000 08:05 2505887                           SectionMapping.elf
004bd000-004c0000 r--p 000bc000 08:05 2505887                           SectionMapping.elf
004c0000-004c3000 rw-p 000bf000 08:05 2505887                           SectionMapping.elf
004c3000-004c4000 rw-p 00000000 00:00 0 
01961000-01984000 rw-p 00000000 00:00 0                                  [heap]
7ffd1ca8f000-7ffd1cab0000 rw-p 00000000 00:00 0                          [stack]
7ffd1cba6000-7ffd1cbaa000 r--p 00000000 00:00 0                          [vvar]
7ffd1cbaa000-7ffd1cbac000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]

上面的输出结果中: 第一列是 VMA 的地址范围; 第二列是 VMA 的权限, r 表示可读, w 表示可写, x 表示可执行, p 表示私有(COW, Copy on Write), s 表示共享。第三列是偏
移, 表示 VMA 对应的 Segment 在映像文件中的偏移; 第四列表示映像文件所在设备的主设备号和次设备号; 第五列表示映像文件的节点号。最后一列是映像文件的路径。

我们可以看到进程中有 10 个 VMA, 只有前 5 个是映射到可执行文件中的 Segment。另外 5 个段的文件所在设备主设备号和次设备号及文件节点号都是 0, 则表示它们没有映射到文件中,
这种 VMA 叫做匿名虚拟内存区域 (Anonymous Virtual Memory Area)。

另外有一个很特殊的 VMA 叫做 vdso, 它的地址已经位于内核空间了 (即大于 0xC0000000 的地址), 事实上它是一个内核的模块, 进程可以通过访问这个 VMA 来跟内核进行一些通信

通过上面的例子, 让我们小结关于进程虚拟地址空间的概念:

1. 操作系统通过给进程空间划分出一个个 VMA 来管理进程的虚拟空间

2. 基本原则是将相同权限属性的、有相同映像文件的映射成一个 VMA

3. 一个进程基本上可以分为如下几种 VMA 区域:

     • 代码 VMA, 权限只读、可执行; 有映像文件

     • 数据 VMA, 权限可读写、可执行; 有映像文件

     • 堆 VMA, 权限可读写、可执行; 无映像文件, 匿名, 可向上扩展

     • 栈 VMA, 权限可读写、不可执行; 无映像文件, 匿名, 可向下扩展




// !! 6.4.3　堆的最大申请数量

Linux 下虚拟地址空间分给进程本身的是 3GB (Windows 默认是 2GB), 那么程序真正可以用到的有多少呢? 我们知道, 一般程序中使用 malloc() 函数进行地址空间的申请, 那么 
malloc() 到底最大可以申请多少内存呢? 用下面这个小程序可以测试 malloc 最大内存申请数量:

#include <stdio.h>
#include <stdlib.h>

unsigned maximum = 0;

int main(int argc, char **argv){
     unsigned blocksize[] = { 1024 * 1024, 1024, 1 };
     int i, count = 0;
     for(int i = 0; i < 3 ; i++) {
        for(count = 1;; count++) {
            void *block = malloc( maximum + blocksize[i] * count);
            if(block){
                maximum = maximum + blocksize[i] * count;
                free( block );
            }else {
                break;
            }
        }
     }
     printf("maximum malloc size = %u bytes\n", maximum);
     return 0;
}

那么 malloc 的最大申请数量会受到哪些因素的影响呢? 实际上, 具体的数值会受到操作系统版本、程序本身大小、用到的动态/共享库数量、大小、程序栈数量、大小等, 甚至有可能每次运
行的结果都会不同, 因为有些操作系统使用了一种叫做随机地址空间分布的技术(主要是出于安全考虑，防止程序受恶意攻击), 使得进程的堆空间变小。



// !! 6.4.4　段地址对齐

可执行文件最终是要被操作系统装载运行的, 这个装载的过程一般是通过虚拟内存的页映射机制完成的。

在映射过程中, 页是映射的最小单位。对于 Intel 80x86 系列处理器来说, 默认的页大小为 4 096 字节, 也就是说, 我们要映射将一段物理内存和进程虚拟地址空间之间建立映射关系,
这段内存空间的长度必须是 4 096 的整数倍, 并且这段空间在物理内存和进程虚拟地址空间中的起始地址必须是 4 096 的整数倍。

由于有着长度和起始地址的限制, 对于可执行文件来说, 它应该尽量地优化自己的空间和地址的安排, 以节省空间。


// !! 6.4.5　进程栈初始化

我们知道进程刚开始启动的时候, 须知道一些进程运行的环境, 最基本的就是系统环境变量和进程的运行参数。

很常见的一种做法是操作系统在进程启动前将这些信息提前保存到进程的虚拟空间的栈中, 让我们来看看 Linux 的进程初始化后栈的结构, 我们假设系统中有两个环境变量:

HOME=/home/user
PATH=/usr/bin

比如我们运行该程序的命令行是:

> prog 123

并且我们假设堆栈段底部地址为 0xBF802000, 那么进程初始化后的堆栈就如图 6-12 所示。

栈顶寄存器 esp 指向的位置是初始化以后堆栈的顶部, 最前面的 4 个字节表示命令行参数的数量, 我们的例子里面是两个, 即 prog 和 123, 紧接的就是分布指向这两个参数字符串的指
针; 后面跟了一个 0; 接着是两个指向环境变量字符串的指针, 它们分别指向字符串 HOME=/home/user 和 PATH=/usr/bin; 后面紧跟一个 0 表示结束。

进程在启动以后, 程序的库部分会把堆栈里的初始化信息中的参数信息传递给 main() 函数, 也就是我们熟知的 main() 函数的两个 argc 和 argv 两个参数, 这两个参数分别对应这里
的命令行参数数量和命令行参数字符串指针数组。

