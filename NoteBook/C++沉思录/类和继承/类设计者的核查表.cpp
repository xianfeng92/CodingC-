// !! 类设计者的核查表

核查表并不是任务清单。它的用途是帮助你回忆起可能会忘掉的事情，而不是来约束你。

知道这一点之后，请看下面关于定义类时要弄清楚的一些问题。这些问题都没有确切的答案，关键是要提醒你思考它们，并确认你所作的
事情是出于有意识的决定，而不是偶然事件。

1. 你的类需要一个构造函数吗？

   我们现在主要关心的是那些足够复杂的类，它们需要构造函数来隐藏它们的内部工作方式

2. 你的数据成员是私有的吗？

   通常使用公有的数据成员不是什么好事，因为类设计者无法控制何时访问这些成员.另外，使用函数而不是变量，在还允许读取访问的时
   候能够很容易地阻止写入访问。没有所谓“最好的”风格来编写访问或者改变类部件的函数，请选择一种规范，一致地使用，并用文档清楚
   地保存。
   
3. 你的类需要一个无参的构造函数吗？

   如果一个类已经有了构造函数，而你想声明该类的对象可以不必显式地初始化它们，则必须显式地写一个无参的构造函数。此外请牢记，如果一
   个类需要一个显式构造函数，则试图生成该类对象的数组是非法的

4. 是不是每个构造函数初始化所有的数据成员？

   '构造函数的用途就是用一种明确定义的状态来设置对象'。对象的状态由对象的数据成员进行反映。因此，每个构造函数都要负责为所有的数据成员
   设置经过明确定义的值。如果构造函数没有做到这一点，就很可能导致错误。

5. 类需要析构函数吗？

   不是所有有构造函数的类都需要析构函数。例如，表示复数的类即使有构造函数也可能不需要析构函数。'如果深入考虑一个类要做些什么，那么该类是
   否需要析构函数的问题就十分明显了'。应该问一问该类是否分配了资源，而这些资源又不会由成员函数自动释放，这就足够了。特别是那些构造函数里
   包含了 new 表达式的类，通常要在析构函数中加上相应的 delete 表达式，所以会需要一个析构函数

6. 类需要一个虚析构函数吗？

  '有些类需要虚析构函数只是为了声明它们的析构函数是虚的。当然，决不会用作基类的类是不需要虚析构函数的:任何虚函数只在继承的情况下才有用'。
   但是，请设想一下，你写了一个叫 B 的类，而别人从它派生了一个类 D，那么 B 何时需要一个虚析构函数？只要有人可能会对实际指向 D 类型对象
   的 B* 指针执行 delete 表达式，你就需要给 B 加上一个虚析构函数

   struct B 
   {
       string s;
   };

   struct D : B
   {
       string t;
   };

   int main()
   {
       B *bp = new D；
       delete bp;
   }

   这里，即使 B 没有虚成员函数，甚至根本没有任何成员函数，也必须有一个虚析构函数，否则 delete 会出错：

    struct B 
   {
       string s;
       virtual ~B() {}
   };

   虚析构函数通常是空的。


7. 你的类需要复制构造函数吗？

很多时候答案都是“不”，但有时候答案是“是”。'关键在于复制该类的对象是否就相当于复制其数据成员和基类对象'。如果并不相当，就需
要复制构造函数。

如果你的类在构造函数内分配资源，则可能需要一个显式的复制构造函数来管理资源。有析构函数（除了空的虚析构函数外）的类通常是用析构
函数来释放构造函数分配的资源，这通常也说明需要一个复制构造函数。一个典型的例子就是类 String：

class String
{
   public:
   String();
   String(const char* s);
   // 其他成员函数
   private:
   char* data;
}

即使不考虑类接下来的定义，我们也能猜到它需要一个析构函数，因为它的数据成员指向了必须由对应的对象释放的被动态分配的内存。

出于同样的原因，它还需要一个显式的复制构造函数：没有的话，复制 String 对象就会以复制它的 data 成员的形式隐式地定义。
复制完后，两个对象的 data 成员将指向同样的内存；当这两个对象被销毁时，这个内存会被释放两次。

如果不想用户能够复制类的对象，就声明复制构造函数（可能还有赋值操作符）为私有的：

class Thing
{
   public:
   //...
   private:
   Thing(const Thing & thing);
   Thing & operator=(const Thing & thing);
}

如果其他的成员不会使用这些成员函数，如上声明就足够了。'没有必要定义它们，因为没人会调用它们：你不能，用户也不能'。


8. 你的类需要一个赋值操作符吗？

如果需要复制构造函数，同理多半也会需要一个赋值操作符。如果不想用户能够设置类中的对象，就将赋值操作符私有化。
类X的赋值由 X：operator= 来定义。通常，operator= 应该返回一个 X&，并且 return *this; 结束以保证与内建的复制操作符一致。


9. 你的赋值操作符能正确地将对象赋给对象本身吗？

自我赋值常常被错误地应用，以至于不止一本 C++ 书把它弄错了。'赋值总是用新值取代目标对象的旧值'。如果原对象和目标对象是同一个，而我们又
奉行“先释放旧值，再复制”的行事规程，那么就可能在还没有实施复制之前就把原对象销毁了。例如，思考类 String：

class String
{
   public:
   String& operator=(const String& s);

   private:
   char * data;
};

我们很容易就用下面的方法来实现赋值:


String& String::operator=(const String& s)
{
   delete [] data;
   data = new char[strlen(s.data) + 1];// length of data plus '\0'
   strcpy(data, s.data);
   return *this;
}

一旦我们把一个 String 对象赋给它本身，这个方法就会彻底失败，因为 s 和 *this 都指向同样的对象。避免这个问题的最简单的方法就是显式
地加以预防：

String& String::operator=(const String& s)
{
   if(s != *this)
   {
      delete[] data;
      data = new char[strlen(s.data) + 1];
      strcpy(data,s.data);
   }
   return *this;
}


10. 你的类需要定义关系操作符吗？

'由于 C++ 支持模板，所以通用库也逐渐开始包含容器类了'。这些类提供了关于诸如列表、集合和图等数据结构的泛型定义。这些容器依赖于它们所包含的元素
类型的操作。通常要求容器能够判断两个值是否相等。还常常需要容器具有判断一个值是否大于或者小于另一个值的能力。'因此，如果你的类逻辑上支持相等操作
，那么提供 operator== 和 operator= 就可能会很有好处'。类似地，如果你的类的值有某种排序关系，那就可能会想提供余下的关系操作符。即使不希望用
户直接使用关系操作符，也可能需要这些关系操作符。'只要它们想创建你的类型的有序集合，你就必须提供关系操作符'。


11. 删除数组时你记住了用 delete[] 吗？

[] 这个奇怪的语法之所以存在，是因为 C++ 希望在保持与 C 兼容性的同时关注效率。C 程序员们希望在他们写函数时使用 malloc 分配内存，然后返回给 C++ 
函数。之后，他们希望 C++ 函数能够使用 delete 来释放那些内存。C++ 系统不想占用现有 C 系统的 malloc 函数，因此必须利用原来的这个 malloc 直
接实现 new，而不能另起炉灶。因此，C++ 库在释放数组时不一定要清楚数组的大小。即使 malloc 把长度值存储到某个位置上，C++ 库也没法在保证可移植性的前
提下找到这个值。因此，作为一种折中方案，C++ 要求用户告知要被删除的是不是数组。如果是，该实现就可能会提供另一个地方来存储长度，因为与数组所需的内存量
相比，这个常数的开销会小很多。尽管有些 C++ 实现只在数组中的对象有特殊的析构函数时才要求这样做，在删除任何类型的数组时使用 [] 格式仍然是一种很好的习惯。



12. 记得在复制构造函数和赋值操作符的参数类型中加上 const 了吗？

复制构造函数应该是像 X：X(const X&) 这样。毕竟复制对象不会改变原对象！同样的道理也适用于赋值: 使用 X：operator=(const X&)


如果函数有引用参数，它们应该是 const 引用吗？ 只有当函数想改变参数时，它才应该有不用 const 声明的引用参数。所以，例如，不应该用

Complex operator+(Complex &x, Complex &y);

而应该总用:

Complex operator+(const Complex &x, const Complex &y);


13. 记得适当地声明成员函数为 const 的了吗？

'如果确信一个成员函数不用修改它的对象，就可以声明它为 const，这样就把它用于 const 对象了'。所以，如果我们像前面的例子中那样使用存取函数：

template<typename T> class Vector
{
   public:
   int length();
   int length(int);
   private:
   // ...
}

取回长度值而不改变该值的函数应该被声明为 const：


template<typename T> class Vector
{
   public:
   int length() const;
   int length(int);
   private:
   // ...
}

否则，我们会遇到类似下面的问题：

// 返回 n 和 v 长度较大的一个
template<class T> int paddedLength(const Vector<T>& v, int n)
{
   int k = v.length();// opps!
   return k > n ? k : n;
}

除非对 length 的声明中出现了前面所说的const，否则标注了 oops！的行将不会编译，因为 v 是 const 引用。