
// !! UNIX、Linux 和 GNU 简介

'Linux 的成功要归功于在它之前诞生的系统和应用程序 —— UNIX 和 GNU 软件'。

1. 什么是 UNIX

    1. UNIX 简史

    UNIX 操作系统最初是由贝尔实验室开发的, 当时的贝尔实验室是电信业巨头 AT&T (美国电报电话公司) 旗下的一员。UNIX 操作系统可以运行在大量不同种类的硬件平台上,
    其适用范围从 PC 工作站一直到多处理器服务器和超级计算机。

    严格来说, UNIX 是由 Open Group (开放组织) 管理的一个商标, 它指的是一种遵循特定规范的计算机操作系统。'这个规范也称为单一 UNIX 规范 (The Single UNIX 
    Specification), 它定义了所有必需的 UNIX 操作系统函数的名称、接口和行为'。

    如今只有少数系统完全遵守开放组织(Open Group)的规范, 从而允许它们挂上 UNIX 的商标。

    2. UNIX 哲学

    UNIX 操作系统(包括Linux)鼓励一种特定的编程风格。下面列出了一些典型的 UNIX 程序和系统所具有的特点:

    1. 简单性: 许多很有用的 UNIX 工具是非常简单的，因此也是很小并易于理解的。“小而简单”(KISS: Keep It Small and Simple)是一种值得学习的技术。越大、越复杂
       的系统注定包含越大、越复杂的错误, 而调试是我们所有人都想避免的苦差事

    2. 集中性: 通常'让一个程序很好地执行一项任务要好过把所有功能都乱七八糟地堆在一起'。功能臃肿的程序难于使用和维护, '只有单一目标的程序更容易随着更好的算法或
       界面被开发出来而得到改进'。在 UNIX 中, 当用户出现新的需求时, 我们通常是把小工具组合起来以完成更复杂的任务, 而不是试图将一个用户期望的所有功能放在一个大
       程序里

    3. 可重用组件: '将应用程序的核心实现为库', 具有简单而灵活的编程接口、文档齐备的库可以帮助其他人开发出同类程序, 或者把这些技术应用到新的应用领域
      
    4. 过滤器: 许多 UNIX 应用程序可用作过滤器, 也就是说它们对输入进行转换并产生输出。正如你将在后面看到的, UNIX 提供了一些机制, 让我们可以把一些 UNIX 程序
       通过一种新颖的方式组合起来, 以开发出相当复杂的应用程序。当然, 这种类型的重用是靠我们前面提到的开发方法支撑的。
      
    5. 开放的文件格式: '比较成功并流行的 UNIX 程序都使用纯 ASCII 码的文本文件或 XML 文件作为配置文件和数据文件'。如果你在开发程序时采用了任一种做法,那你做
       对了！ 它使用户可以用标准工具来修改和搜索配置项, 并且可以开发出新工具在数据文件上执行新的功能。
      
    6. 灵活性: '你不能期待用户都能非常正确地使用你的程序'。所以, 你在编程时应尽量考虑到灵活性, 尽量避免随意限制字段长度或记录数目。如果你能做到的话, 则你编写的
       网络程序既能在单机上运行, 也能跨网络运行。永远不要认为你知道用户想做的一切事



'KISS: Keep It Small and Simple、只有单一目标的程序、可重用组件'


2.什么是 Linux

可能你已经知道, Linux 是一个可以自由发布的类 UNIX 内核实现, 它是一个操作系统的底层核心。


3.GNU 项目和自由软件基金会

Linux 能够存在并发展到今天是无数人共同努力的结果。'操作系统内核本身仅仅是可用开发系统的一小部分'。Linux社区 (以及其他的软件开发组织) 支持自由软件的概念, 即
软件本身不应受限，它们应遵守 GNU (GNU 是 GNU's Not UNIX'的递归缩写)通用公共许可证(GPL)。虽然获得软件可能要支付一定的费用, 但此后就可以随意使用它们,并且
它们通常是以源代码的形式发布。

'GNU 项目已为软件社区提供了许多 UNIX 系统上应用程序的仿制品'。所有这些程序, 即 GNU 软件, 都是在 GNU '通用公共许可证'(GPL) 的条款下发布的。

自由软件基金会 (Free Software Foundation) 由Richard Stallman 创立, 他是 UNIX 及其他系统上最著名的文本编辑软件之一 GNU Emacs 的开发者。Stallman 是
自由软件这一概念的倡导者, 并发起了 GNU 项目, 这个项目的宗旨是: 试图创建一个与 UNIX 系统兼容, 但并不受 UNIX 名字和源代码私有权限制的操作系统和开发环境。

GNU 项目已为软件社区提供了许多 UNIX 系统上应用程序的仿制品。所有这些程序即 GNU 软件, 都是在 GNU 通用公共许可证 (GPL) 的条款下发布的。

下面是在 GPL 条款下发布的一些主要的 GNU 项目软件:

1. GCC: GNU 编译器集, 它包括 GNU C 编译器

2. G++: C++ 编译器, 是 GCC 的一部分

3. GDB: 源代码级的调试器 

4. GNU make: UNIX make 命令的免费版本 

5. Bison: 与 UNIX yacc 兼容的语法分析程序生成器 

6. bash: 命令解释器 (shell)

7. GNU Emacs: 文本编辑器及环境

现在有这么多可用的自由软件, 再加上 Linux 内核, 我们可以说：创建一个 GNU 的、自由的类 UNIX 系统的目标已经通过 Linux 系统实现了。由于认识到 GNU 软件所
做出的贡献,现在许多人通常都把 Linux 系统称为 GNU/Linux。

4. Linux 发行版

Linux 实际上只是一个内核。你可以获得内核源代码, 编译并安装它, 然后获得并安装许多其他自由发布的软件, 从而完成一个完整 Linux 系统的安装。我们通常将这样安
装所得的系统称为Linux**系统**, 这是因为它包含的远不止一个 Linux 内核。'系统中大多数的工具都来自于自由软件基金会的 GNU 项目'。


// !! Linux 程序设计

许多人认为 Linux 程序设计就是用 C 语言编程。的确, UNIX 最初是用 C 语言编写的, 并且 UNIX 的大多数应用程序也是用 C 语言编写的, 但 C 语言并不是 Linux 程序
员或 UNIX 程序员的唯一选择。

'我们将集中精力从 C 语言程序员的视角探究 Linux 编程接口'。

1. Linux 程序

  'Linux 应用程序表现为两种特殊类型的文件': 可执行文件和脚本文件。可执行文件是计算机可以直接运行的程序。'脚本文件是一组指令的集合, 这些指令将由另一个程序（
  即解释器）来执行'

  Linux 并不要求可执行文件或脚本文件具有特殊的文件名或扩展名。

  在 Linux 中, 你可以用编译过的程序代替脚本(反之亦然)而不会影响其他程序或调用者。事实上, 在用户级别, 这两者本质上没有任何不同。

  当登录进 Linux 系统时, 你与一个 shell 程序 (通常是 bash) 进行交互。'它在一组指定的目录路径下按照你给出的程序名搜索与之同名的文件'。搜索的目录路径存
  储在 shell 变量 PATH 里。搜索路径（你也可以添加这个路径）由系统管理员配置, 它通常包含如下一些存储系统程序的标准路径:

    1. /bin: 二进制文件目录, 用于存放启动系统时用到的程序

    2. /usr/bin: 用户二进制文件目录, 用于存放用户使用的标准程序
    
    3. /usr/local/bin: 本地二进制文件目录, 用于存放软件安装的程序

    系统管理员（例如 root 用户）登录后使用的 PATH 变量可能还包含存放系统管理程序的目录, 如 /sbin 和 /usr/sbin。

2. 文本编辑器

编写和输入本书中的代码需要使用一个编辑器。在典型的 Linux 系统上有许多编辑器可用，较流行的编辑器是 vi

3. C 语言编译器

在 POSIX 兼容的系统中, C 语言编译器被称为 c89。历史上, C 语言编译器被简称为 cc。许多年来, 不同厂商销售的类 UNIX 系统中所带的 C 语言编译器均包含不同的功
能和选项，但它们一般都称为 cc

'在 Linux 系统中，你会发现 c89、cc 和 gcc 这些命令全部或部分地指向系统的 C 语言编译器, 通常是 GNU C 编译器或 gcc'。在 UNIX 系统中, C 语言编译器几乎总
被称为 cc。


// !! 开发系统导引

'对 Linux 开发人员来说, 了解软件工具和开发资源在系统中存放的位置是很重要的'

1. 应用程序

应用程序通常存放在系统为之保留的特定目录中。'系统为正常使用提供的程序, 包括用于程序开发的工具，都可在目录 /usr/bin 中找到'；系统管理员为某个特定的主机
或本地网络添加的程序通常可在目录 /usr/local/bin 或 /opt 中找到。

系统管理员一般喜欢使用 /opt 和 /usr/local 目录, 因为它们分离了厂商提供及后续添加的文件与系统本身提供的应用程序。一直保持以这种方式组织文件的好处在你需要
升级操作系统时就可以看出来了, 因为只有目录 /opt 和 /usr/local 里的内容需要保留。'我们建议对于系统级的应用程序,你可以将它放在 /usr/local 目录中来运行
和访问所需的文件。对于开发用和个人的应用程序, 最好在你的家(/home)目录中使用一个文件夹来存放它'。

GNU 编译系统的驱动程序 gcc 一般位于 /usr/bin 或 /usr/local/bin 目录中, 但它会从其他位置运行各种编译器支持的应用程序。这个位置是在编译编译器本身时指
定的, 并且它随主机类型的不同而不同。'对 Linux 系统来说,这个位置可能是 /usr/lib/gcc/ 目录下的一个版本特定的子目录'。

2.头文件

用 C 语言及其他语言进行程序设计时, 你'需要用头文件来提供对常量的定义和对系统函数及库函数调用的声明'。对 C 语言来说, 这些头文件几乎总是位于 /usr/include 
目录及其子目录中。那些依赖于特定 Linux 版本的头文件通常可在目录 /usr/include/sys 和 /usr/include/linux 中找到。

3.库文件

'库是一组预先编译好的函数的集合，这些函数都是按照可重用的原则编写的'。它们通常由一组相互关联的函数组成以执行某项常见的任务。

'标准系统库文件一般存储在 /lib 和 /usr/lib 目录中'。'C 语言编译器 (或更确切地说是链接程序) 需要知道要搜索哪些库文件, 因为在默认情况下, 它只搜索标准 C 语言
库'。这是从那个计算机速度还很慢而且 CPU 运行周期还很昂贵的时代遗留下来的问题。仅把库文件放在标准目录中, 就希望编译器能够找到它是不够的, 库文件必须遵循特定的命
名规范并且需要在命令行中明确指定。

库文件的名字总是以 lib 开头, 随后的部分指明这是什么库。文件名的最后部分以.开始, 然后给出库文件的类型:

1. .a代表传统的静态函数库

2. .so代表共享函数库

'函数库通常同时以静态库和共享库两种格式存在, 你可用 ls /usr/lib 命令查看'。

'你可以通过给出完整的库文件路径名或用 -l 标志来告诉编译器要搜索的库文件'。例如:

gcc -o fred fred.c /usr/lib/libm.a

这条命令要求编译器编译文件 fred.c, 将编译产生的程序文件命名为 fred, 并且除了搜索标准的 C 语言函数库外, 还搜索数学库以解决函数引用问题。下面的命令也能产生
类似的结果:

gcc -o fred fred.c -lm

-lm (在字母l和m之间没有空格)是简写方式(简写在 UNIX 环境里很有用), 它代表的是标准库目录(本例中是 /usr/lib)中名为 libm.a 的函数库。-lm 标志的另一个好
处是如果有共享库, 编译器会自动选择共享库。

虽然库文件和头文件一样, 通常都保存在标准位置, 但你也可以通过使用 -L （大写字母）标志为编译器增加库的搜索路径。


4.静态库

函数库最简单的形式是一组处于准备好使用状态的目标文件。'当程序需要使用函数库中的某个函数时, 它包含一个声明该函数的头文件。编译器和链接器负责将程序代码和函数
库结合在一起以组成一个单独的可执行文件'。你必须使用 -l 选项指明除标准 C 语言运行库外还需使用的库。

'静态库，也称作归档文件(archive), 按惯例它们的文件名都以 .a 结尾'。比如, 标准 C 语言函数库 /usr/lib/libc.a 和 X11 函数库 /usr/lib/libX11.a

你可以很容易地创建和维护自己的静态库, 只要使用 ar(代表archive, 即建立归档文件)程序和使用 gcc -c 命令对函数分别进行编译。你应该尽可能把函数分别保存到不同的
源文件中。如果函数需要访问公共数据, 你可以把它们放在同一个源文件中, 并使用在该文件中声明的静态变量。

// !! 实验　静态库

在本例中,你将创建一个小型函数库, 它包含两个函数, 然后你将在一个示例程序中调用其中一个函数。这两个函数分别是 fred 和 bill 它们只打印欢迎信息。

1. 首先, 为两个函数分别创建各自的源文件（将它们分别命名为 fred.c 和 bill.c)

2. 你可以分别编译这些函数以产生要包含在库文件中的目标文件。这可以通过调用带有 -c 选项的 C 语言编译器来完成, -c 选项的作用是阻止编译器创建一个完整的程序

» gcc -c fred.c bill.c
 » ls *.o
bill.o  fred.o

3. 现在编写一个调用 bill 函数的程序。'首先, 为你的库文件创建一个头文件'。这个头文件将声明你的库文件中的函数, 它应该被所有希望使用你的库文件的应用程序所包
   含。'把这个头文件包含在源文件 fred.c 和 bill.c 中是一个好主意, 它将帮助编译器发现所有错误'。

4. 调用程序(program.c)非常简单, 它包含库的头文件并且调用库中的一个函数

  #include <stdio.h>
  #include "lib.h"

  int main()
  {
      bill("hello world");
      return 0;
  }

5. 现在，你可以编译并测试这个程序了。你暂时为编译器显式指定目标文件, 然后要求编译器编译你的文件并将其与先前编译好的目标模块 bill.o 链接

 » gcc -c program.c
 » gcc -o program program.o bill.o                                                                   
 » ./program                                                                                         
bill:we passed hello world

6. 现在，你将创建并使用一个库文件。你使用 ar 程序创建一个归档文件并将你的目标文件添加进去。'这个程序之所以称为 ar, 是因为它将若干单独的文件归并到
   一个大的文件中以创建归档文件或集合'。注意, 你也可以用 ar 程序来创建任何类型文件的归档文件（与许多 UNIX 工具一样, ar 是一个通用工具）

 » ar crv libfoo.a fred.o bill.o                                                                     
a - fred.o
a - bill.o

» ls *.a                                                                                            
libfoo.a


7. 库文件创建好了, 两个目标文件也已添加进去。在某些系统, 尤其是从 Berkeley UNIX 衍生的系统中，要想成功地使用函数库, 你还需要为函数库生成一个内容表。
   通过 ranlib 命令来完成这一工作。在 Linux 中, 当你使用的是 GNU 的软件开发工具时，这一步骤并不是必需的

>> ranlib libfoo.a


你的函数库现在可以使用了。你可以在编译器使用的文件列表中添加该库文件以创建你的程序，如下所示：

 » gcc -o program program.o libfoo.a                                                                 
 » ./program                                                                                         
bill:we passed hello world

你也可以使用 -l 选项来访问函数库，但因其未保存在标准位置, 所以你必须使用 -L 选项来告诉编译器在何处可以找到它，如下所示:

 » gcc -o program program.o -L. -lfoo                                                                
 » ./program                                                                                         
bill:we passed hello world

-L. 选项告诉编译器在当前目录(.)中查找函数库。-lfoo 选项告诉编译器使用名为 libfoo.a 的函数库(或者名为 libfoo.so 的共享库，如果它存在的话)

// !! 共享库

'静态库的一个缺点是, 当你同时运行许多应用程序并且它们都使用来自同一个函数库的函数时, 内存中就会有同一函数的多份副本, 而且在程序文件自身中也有多份同
样的副本'。这将消耗大量宝贵的内存和磁盘空间。

共享库的保存位置与静态库是一样的, 但共享库有不同的文件名后缀。在一个典型的 Linux 系统中, 标准数学库的共享版本是 /usr/lib/libm.so

当一个程序使用共享库时, 它的链接方式是这样的: '程序本身不再包含函数代码, 而是引用运行时可访问的共享代码'。'当编译好的程序被装载到内存中执行时, 函数
引用被解析并产生对共享库的调用, 如果有必要, 共享库才被加载到内存中'。

通过这种方法, 系统可以只保留共享库的一份副本供许多应用程序同时使用, 并且在磁盘上也仅保存一份。另一个好处是共享库的更新可以独立于依赖它的应用程序。例如, 文件
/lib/libm.so 就是对实际库文件修订版本（/lib/libm.so.N, 其中 N 代表主版本号）的符号链接。当 Linux 启动应用程序时, 它会考虑应用程序需要的函数库版本, 以防止
函数库的新版本致使旧的应用程序不能使用。

'对 Linux 系统来说, 负责装载共享库并解析客户程序函数引用的程序(动态装载器)是 ld.so', 也可能是 ld-linux.so.2、ld-lsb.so.2 或 ld-lsb.so.3。

'你可以通过运行工具 ldd 来查看一个程序需要的共享库'。例如,  如果你在自己的示例程序上运行 ldd, 你将看到如下所示的输出结果:

 » ldd ./program                                                                                     
	linux-vdso.so.1 (0x00007ffcf35db000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fcf68ca4000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fcf68ebb000)

在本例中，你看到标准 C 语言函数库(libc)是共享的，程序需要的主版本号是 6。


// !! 获得帮助

绝大多数 Linux 系统都为系统编程接口和标准工具提供了很好的文档。这是因为，从早期的 UNIX 系统开始，程序员就被鼓励为他们的应用程序提供手册页。这些手册页都
可以通过电子形式获得，有时也会以印刷品的形式提供。

man 命令可用来访问在线手册页。

GNU 软件和其他一些自由软件还使用名为 info 的在线文档系统。


// !!实验　手册页和info

让我们来看看 GNU C 语言编译器 (gcc) 的文档。

1. 首先查看手册页

GCC(1)                                                                               GNU                                                                              GCC(1)

NAME
       gcc - GNU project C and C++ compiler

SYNOPSIS
       gcc [-c|-S|-E] [-std=standard]
           [-g] [-pg] [-Olevel]
           [-Wwarn...] [-Wpedantic]
           [-Idir...] [-Ldir...]
           [-Dmacro[=defn]...] [-Umacro]
           [-foption...] [-mmachine-option...]
           [-o outfile] [@file] infile...

       Only the most useful options are listed here; see below for the remainder.  g++ accepts mostly the same options as gcc.

DESCRIPTION

2.  为了获得更多关于 GNU C 的信息，你可以使用 info 命令