
// !! 内联技巧

有许多"技巧"可以使内联变得更为高效。如今，已经有越来越多的编译器将此类技巧作为可选项及可用优化技术提供给编程者。

在为实践这些技巧而辛苦付出之前，让我们先来了解一下编译器能做些什么。

// !! 条件内联

编译、调试和配置等过程与内联是有一些冲突的，做这些工作时，都希望将内联决策推迟到开发周期的后期，在大部分调试工作完成之后进行。
理想情况下，内联决策是基于配置结果做出的。'大部分编译器可以使用编译行开关来阻止内联'，但如果您的编译器不支持这种功能，那么还有一个简单的方法，即构建自定义编
译行开关。

遗憾的是, 配置需要程序员付出相当的努力。'为了性能而内联或为了进行正常测试而外联，在这两者之间反复修改方法是难以接受的'。幸运的是，预处理器可以协助我们实现在内联
与外联之间的轻松转移。'这项技术的基本思路是利用编译行参数向编译器传递一个宏定义'。输入参数用来定义名为 INLINE 的宏，也可以忽略这个参数而不定义 INLINE。这种技
术基于对两种定义的划分，即需要内联的方法及需要外联的方法。外联方法包含于标准的 .c 文件中，需要内联的方法放置在 .inl 文件中。如果对 .inl 文件中的方法内联，可以
在编译命令中使用 -D 选项来定义 INLINE 宏。

下例向我们展示了如何使用编译时内联开关:

文件 x.h:

#if !defined(_X_H_)
#define _X_H_
class X
{
    ...
    int y(int a);
    ...
};

#if defined(INLINE)
#include x.inl
#endif
#endif // _X_H_

文件 x.inl:// 需要内联的方法放置在 .inl 文件中

#if !define(INLINE)
#define INLINE
#endif

inline 
int X::y(int a)
{
    ...
}

文件 x.c:// 外联方法包含于标准的 .c 文件中

#if !defined(INLINE)
#include x.inl
#endif

.h 文件的使用遵循其惯用方式。如果 INLINE 被定义，则 .h 文件将包含 .inl 文件, 且各方法之前的 inline 指示符将不受影响。相反，如果未定义 INLINE，.h 文件将
不会包含内联方法， 这些方法会包含在 .c 文件中，同时每个方法前面的 inline 指示符也会被清除。这种机制提供了一种简单的机动性，以便内联方法由内联状态转为外联状态。
但是，这项技术要么全部内联要么全不内联，没有一种折中的选择。所以，对于建立内联/外联子部分的情况，仍需给予足够重视。


// !! 选择性内联

内联机制的语法和机动性是 C++ 最严重的缺陷之一。尽管通常情况下它很有用，但却存在一个令人头疼的缺陷，即它没有针对选择性内联的机制；'所谓选择性内联，是指在某些场合下
对方法进行内联而在另外一些场合则不然'。这种缺陷使得内联决策成为非全则无的选择，从而忽略了快速路径优化的真实情况。

例如，假设某程序的快速路径(典型的执行序列)包含针对某方法的两次静态调用，而在该快速路径之外还有对该方法的另外 20 次静态调用。C++ 内联机制不存在简单的方法以实现：
在两个重要调用位置上内联该方法，而在其他位置使用正常的调用机制。

我们将会展示如何实现这种功能--它相当简单并且非常有效。遗憾的是，这种机制对程序员的要求较高，因而推广这种机制的使用有些困难。

假设我们想对以下方法进行选择性内联:

int x::y(int a)
{
    ...
}

该方法位于 x.c 文件中。

为了选择性地内联该方法，我们可以向指定的文件中添加以下代码。

文件 x.h：

class x
{
public:
    ...
    int inline_y(int a);
    int y(int a);
};

#include "x.inl"

文件 x.inl：

inline
int x::inline_y(int a)
{
    ...// y的原始实现
}

文件 x.c：

int x::y(int a)
{
    return inline_y(a);
}

通过以上代码，我们获得了两种版本的 y；其一是内联版本，名称为 inline_y，另一种是外联版本，名称为 y。此外我们还为 x::y 代码体定义了一种单个共享版本，即
inline_y 定义中那个版本。这样做会有一些额外的好处，对于方法内的任何静态变量，单个方法体可以为其产生唯一实例。


// !! 递归内联


// !! 对静态局部变量进行内联

// !! 要点

● 内联可以改善性能。'目标是找到程序的快速路径，然后内联它，尽管内联这个路径可能要费点工夫'

● 条件内联可以阻止内联的发生。这样就减少了编译时间，同时也简化了开发前期的调试工作

● 选择性内联是一种只在某些地方内联方法的技术。在对方法进行内联时，为了抵消可能的代码尺寸膨胀的影响，选择性内联只在对性能有重大影响的路径上对方法调用进行内联

● 递归内联是一种让人感觉别扭，但对于改善递归方法性能却很有效的技术

● 需要关注局部静态变量

● 内联的目标是消除调用开销。在使用内联之前请弄清您系统中真正的调用代价






