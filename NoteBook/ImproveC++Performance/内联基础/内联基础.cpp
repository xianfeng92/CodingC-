// !! 内联基础

// !! 什么是内联？

'内联类似于宏，在调用方法内部展开被调用方法, 以此来代替方法的调用'。

一般来说表达内联意图的方式有两种。一种是在定义方法时添加内联保留字的前缀，另一种是在类的头部声明中定义方法。

下面的示例代码清晰地展现了这两种方式:

class GatedInt
{
private:
    int x;
public:
    int get() { return x; }
    void set(int value) { x = value; }
};

GatedInt::get 和 GatedInt::set 都属于内联方法，因为它们都定义在类声明中。

此外，待内联方法的定义也可以放置在类声明之外，但是必须出现在头文件或者被头文件包含的文件中。

class GatedInt
{
private:
    int x;
public:
    int get();
    void set(int value);
};


inline int GatedInt::get() const
{
    return x;
}

inline void GatedInt::set(int value)
{
    x = value;
}


虽然内联方法的调用方式和普通方法相同，但其编译过程却相差甚远。'由于内联方法的代码必须内联展开，这就要求调用内联方法的代码段必须有权访问该内联方法的定义'。
而内联方法的定义需要整合到其调用方法之中，这就使得任何针对内联方法的更改，都将引起所有调用该方法模块的重新编译。所以，'内联在显著提升性能的同时，也增加了编译时间'。
编译时间的增加有时是适度的，但有时却极大，并且在大多数极端情况下，对内联方法的一处修改可能会要求整体程序重新进行编译。'因此，将内联过程搁置到代码开发阶段后期是明
智的做法'。

程序可能以如下方式对方法进行调用：

int main()
{
    GatedInt gi;
    gi.set(12);
    cout << gi.get() << endl;
}

方法在程序中以连续代码块的形式出现, 其中包含了方法所能执行的操作。以示例程序为例，get、set 和 main 可以分别表示为独立代码块，这些代码块包含了由编译器选择的机
器语言指令, 以使其执行各自操作。

在示例程序中，main 方法实例化一个 GateInt 对象，将直接量 12 压栈并调用 GateInt::set 方法。然后调用 GateInt::get 方法并将其返回值压栈，以便让 iostream
::operator<< 输出该返回值。GateInt::get 方法返回私有成员变量 GateInt::x 的值，GateInt::set 方法将输入参数 value 赋值给 GetInt::x。如果忽略操作系统
为程序载入和运行所做的工作，该程序的外联(非内联)版本执行了三次调用, '前两次调用中，用于执行调用和返回操作的开销可能要比实际执行被调用方法的代码的开销高出一个数量
级'。 


反之，内联的 get 和 set 可以使 main 程序只包含一个对 iostream::operator<< 的调用，'在 get 和 set 内联之后、main 方法被编译之前'，逻辑上主程序的结构应
如下所示:

int main()
{
    GatedInt gi;
    {
        gi::x =  12;
    }
    int temp = gi::x;
    cout << temp << "\n";
}

请注意我们只是从逻辑上来分析; 实际上编译器所做的应该远比这个要好。经过优化后，main 方法可以简化为如下形式:

int main() 
{
    cout << 12 << '\n';
}


从逻辑上来说，编译器将方法内联化的步骤如下:

1. 首先将待内联方法的连续代码块复制到调用方法中的调用点处。然后在块中为所有内联方法的局部变量分配内存。

2. 之后将内联方法的输入参数和返回值映射到调用方法的局部变量空间内。

3. 最后，如果内联方法有多个返回点，将其转变为内联代码块末尾的分支(可怕的 GOTO 语句)。经过这样的处理即可消除所有与调用(可能除去与创建新块相关的 SP 修改)
   相关的痕迹以及性能损失。
   
然而，'避免方法调用仅仅是内联可提升的性能空间的一半'。假设有两个方法 y 和 build_mask:

int x::y(int a)
{
    ...
    int b = 6;
    ...// 该区域未对 b 进行修改
    int m = build_mask(b);
    ...// 该区域未对 m 进行修改
    int n = m + 1;
    ...
}

inline int build_mask(int q)
{
    if(q > WORD_SIZE) return -1;
    else if (q > 0) return (1 >> q) - 1;
    else return 0;
}


将 build_mask 内联到 y 中而未经优化，则结果如下所示:

int x::y(int a)
{
    ...
    int b = 6;
    ...// 该区域未对 b 进行修改
    int m;
    {
        int _temp_q = 6;
        int _temp;
        if(_temp_q > WORD_SIZE) _temp = -1;
        else if(_temp_q > 0) _temp=  (1 >> _temp_q) - 1;
        else _temp = 0;
        m = _temp;
    }
    ...// 该区域未对 m 进行修改
    int n = m + 1;
    ...
}


如果经过优化，则结果变为：

int x::y(int a)
{
    ...
    int b = 6;
    ...// 该区域未对 b 进行修改
    int m = 0x3F;
    ...// 该区域未对 m 进行修改
    int n = 0x40;
    ...
}

'调用间(cross-call)优化是内联可提升的性能空间的另外一半'。

'优秀的、经过优化的编译器可以使内联方法块的边界痕迹难以区分'。方法中大量的甚至是所有的代码经过优化后都将不复存在，因为编译器可能会对方法中大部分代码进行重新排列。
因此，尽管在逻辑上可以将方法内联化看做是对一定内聚度的维持，不过编译器并未强制执行这种优化措施，这也是内联的优点之一。



// !! 方法调用的代价

为了完全理解内联性能收益的相关内容，我们必须先弄懂方法调用(过程调用)以及返回过程的相关细节。

大部分系统都有 3 或 4 个"内务处理"寄存器:指令指针(Instruction Pointer，常被称为程序计数器——Program Counter，但其功能并非对程序进行计数)，链接寄存器(Link Register)，栈指针(Stack Pointer)，帧指针(Frame Pointer)以及自变量指针(Argument Pointer)，分别可以记作 IP、LR、SP、FP 以及 AP。

读者可能注意到这里列出了 5 个寄存器，前面却说一个系统只有 3 或 4 个内务处理寄存器。这是因为系统通常会混合使用这些寄存器。我们从未听说有系统使用的寄存器会少于其
中 3 种，也同样不曾了解有哪些系统会用到全部 5 种寄存器。


对每种维护寄存器的功能作简要说明如下:

1. '指令指针(IP)存放下一条将要执行的指令地址'。调用方法时，程序要跳转到被调用方法的指令并修改 IP。但不能只是简单地重写 IP。重写前必须先保存其旧值，否则无法返回 至原调用方法

2. '链接寄存器(LR)存储某一方法的 IP 的地址，该方法对当前方法进行了调用'。这个地址就是方法执行完毕后返回的地方。LR 通常和体系结构调用指令的操作绑定在一起，执行调用操作时其值会被自动设定。LR 是单个寄存器而非多寄存器集合。因此，如果某方法调用了其他方法，则必须保存 LR 的值以防止其被重写，因为调用者标识消失后，就很难有效地从调用中返回。在某些体系结构中，LR 的功能是通过自动或显式地将调用方法 IP 压入程序进程堆栈来实现的，因此这些体系结构不存在明确的 LR。

3. '方法的局部(自)变量是在进程堆栈上分配的'。而'栈指针(SP)的功能就是跟踪记录堆栈的使用情况'。调用操作会消耗堆栈空间，返回操作则会释放之前分配的堆栈空间。类似于调用者的 IP 和 LR，调用返回之后，必须根据传递到堆栈的参数来进行可能的调整以恢复堆栈。这就意味着 SP 也必须被保存为方法调用序列的一部分。


4. 自变量指针(AP)和帧指针(FP)的存在随系统而异。某些体系结构不包含这两个寄存器，某些仅包含一个，而另外一些则二者兼备。'FP 的作用是标识堆栈中两个区域的边界'：第一个区域供调用方法用来保存需要记录状态的寄存器，第二个区域为被调用方法的自变量分配内存。在方法执行期间 SP 一般会频繁地变化。FP通常被当成方法中局部变量的固定引用指针。


'良好的调用性能要求系统只保存方法用到的寄存器'。每次调用都保存全部寄存器是无谓的浪费，但是只保存部分寄存器会导致在传给方法的参数和分配给方法自变量之间产生潜在的内存分配。如果数量可变的寄存器存储和某个给定的方法调用相关联（也即寄存器值存储的数量依赖于调用方法的状态），就需要用 AP 指出传给方法的参数在堆栈中的位置。


使用寄存器的典型调用顺序如下：

1. 调用方法整理需要传给被调用方法的参数。此步骤通常意味着要将参数压栈，压栈时一般采用倒序。所有参数入栈后，SP 将指向第一个参数

2. 把将要返回的指令地址压栈，然后调用指令跳转到被调用方法的第一条指令处

3. 由被调用方法在堆栈中保存调用方法的 SP、AP 以及 FP，并调整每个"管家"寄存器以反映被调用方法的上下文环境

4. 同时，被调用方法保存(压入堆栈)其将会用到的所有其他寄存器（此步骤是必要的，以便被调用方法返回后不会中断调用方法的上下文环境，通常要保存另外的 3 或 4 个寄存器。）

清除调用的典型返回序列如下:

1. 如果方法有返回值，则通常将该返回值存储到寄存器0（有时是寄存器1）中。这就意味着寄存器 0 和寄存器 1 必须是暂时性寄存器(此类寄存器的存储和恢复不是方法调用和返回的一部分)。通过寄存器使得返回操作的堆栈清理工作更加容易

2. 将由于方法调用而保存的寄存器从堆栈中恢复至其初始位置

3. 将保存的调用者的 FP 和 AP 寄存器值从堆栈中恢复到其相应的位置

4. 修改 SP 使其指向将方法第一个参数压栈前的位置

5. 从堆栈中找到返回地址并将其存入 IP，强制返回至调用者中紧接调用点的位置


简单算一算单次方法调用过程中的数据移动次数可以看出，6～8 个寄存器(4 个寄存器用于维护现场，2～4 个供方法使用)被保存过，其中 4 个稍后被修改过。通常情况下这些操作至少需要 12 个时钟周期(实际中数据移入/移出内存很少只花费单个时钟周期)，有时甚至会消耗多达 40 个时钟周期。'因此，就机器时钟周期方面的花费而言，与方法调用相关的操作的代价非常昂贵'。不幸的是，以上所述只是所有开销的一半。'方法返回时,为调用过程所做的工作必须全部撤销'。之前保存的值必须从堆栈中恢复，机器状态也必须恢复到和调用前类似。这就意味着单次方法调用通常需要消耗 25～100 个时钟周期，有时这甚至仅是保守估计。

'之所以说是保守估计，部分原因与参数的准备及获取有关'。被压栈的参数作为调用开始阶段的一部分，通常直接映射到被调用方法的内存映像中。对于引用来说始终如此，而对于指针和对象则是有时如此。因而会产生额外的调用开销，这种开销与调用前参数的压栈以及被调用方法将其从堆栈中读回的操作相关。某些情况下可以通过寄存器进行参数传递，虽然这种机制可以提供很好的性能特性(尽管不无代价)，但是公认的机制还是使用内存来传递参数。

'如果方法有返回值，特别当其返回值是一个对象时,被调用方法将对象复制到调用方法为返回值预留的存储空间中也是一笔开销'。对于较大的对象而言，这笔额外开销将更加可观，尤其是使用复杂的拷贝构造函数执行该任务时(这种情况会产生两份调用/返回开销：一份开销是因为对方法的显式调用，另一份则是拷贝构造函数返回一个对象时产生的开销)。'如果将所有调用者/被调用者的通信因素和系统维护因素也考虑在内，方法调用的代价大约为 25～250 个时钟周期'。通常被调用方法越大，所产生的开销也越大，取决于保存恢复所有寄存器、传递大量参数、调用自定义方法以构造返回值等操作的最大开销。

'使用异常处理可以显著降低内联返回值优化的性能'。从逻辑上来说，返回值的复制工作是作为被调用方法返回过程一部分的、由拷贝构造函数执行的原子操作。这就意味着如果返回前有异常被抛出，则返回值将不会返回，而且存放方法返回值的变量也不会改变，从而导致异常发生时，必须为返回值使用复制语义。'这在某些情况下也成为避免使用异常处理的正当理由'。理想情况下，为达到优化目的，如果存在一些语法标记以允许异常发生时对返回值进行优化，将会带来极大便利。某些针对异常发生时的返回值优化已经可以实现。例如，如果返回值变量的作用域和内联方法处在同一 try 代码块内，则返回值可被优化。不幸的是，尽管这种情形在大多数情况下可以轻易确定，但其要求的调用间优化往往代价高昂且实现起来十分复杂。


'内联的另一个好处是无须跳转执行被调用方法'。跳转，即便是无条件跳转，都会对现代处理器的性能产生负面影响。频繁跳转会造成执行流水线迟滞，这是因为预取缓存中没有需要执行的指令。跳转还需要运算单元为其确定跳转目标地址，使指令直到跳转地址可知才可执行。'流水线的延迟意味着处理器将会因为大量时间被用于重定向指令流而处于闲置状态'。每次方法调用时这种情况都会发生两次——方法被调用阶段和返回阶段。

另外还存在一些与调用性能相冲突的因素。'编译器只擅长处理小型代码窗口，因此对于单个方法而言，编译器可以很好地对其进行优化，而对于跨越方法调用边界的优化则不然'。这就意味着一些简单的优化操作，比如消除写在同一区域的两个内存序列中的第一个内存的操作，在发生插入调用时这种优化将不能执行。

例如：

int x = 10;
x = 20;

作为单一代码段来看，这段代码非常简单。显然，第一个赋值语句: x = 10 是可以忽略的。任何合格的编译器都会将第一句和第二句组合成为一句简单的: int x = 20。
'不幸的是，如果在连续赋值语句中加入一条返回指令，这种常见的代码形态会被编译器无视，且不加优化地执行下去'。例如:

int a::b(int& i)
{
    i = 10;
    ...
}


int a::c()
{
    ...
    int k = 0;
    ret = this->b(k);
    ...
}

在语句方面，可以将一对一调用的两个方法转化为同时包含两种方法功能的一个方法，'尽管这种改变从逻辑上来说对最终执行结果并无影响，但是对提升编译器优化低效代码的能力
来说，这种改变却至关重要'。

'因此，在某些情况下，方法调用最大的代价就是无法对跨越方法边界的代码进行优化'。


// !! 因何内联？

'内联可能是 C++ 中可用的最有效的性能提升机制'。

通过内联的方式，无须进行任何重写即可使大型的系统迅速提升性能。笔者在为某网络架构工作时，曾使用过 10，000 行代码的子系统，并将其性能提升了不止一个数量级。'系统改进的最后一步就涉及将系统内联化'。这些工作仅仅花费了两天时间，却使系统性能提升了 40%。之所以耗费两天时间去做内联是因为该工作系统的代码在开始设计时并未引入内联。如果系统开发期间采用了笔者当前掌握的内联相关技术，就可以通过修改 makefile 和重新编译来快速完成同样的内联工作。

这 40% 的性能提升并非对系统进行仔细配置以及对"快速路径"分析的结果，而仅仅源自粗略检查方法集合并将其中比较明显的方法进行内联重新编译。如果对性能有更多需求，可以在建立"直线快速路径"方面更加细致一些， 这也正是自动提升性能技术的真正目标。

"程序的快速路径是程序的一部分,支持程序正常、无差错地运行，满足常用场景"。这条快速路径通常只包含 10% 的代码量。甚至只占全部程序代码的 1% 也并不罕见。

'快速路径的典型示例就是沿直线执行包含最少分支数量(条件执行、循环和调用)的代码'。

这种特性对于实现高度优化的性能是很关键的。'内联可以消除快速路径上的调用'。而在大多数系统中，调用是代价最高的唯一结构实体。总的来说，如果程序主要由众多小型方法构成, 那么该程序是很难实现合理性能的, 除非这些方法的真子集被标识且已内联。


// !! 内联详述

表面上看来内联的概念相当简单，但其也有复杂的一面。'尽管理解和正确使用内联很重要，但是内联终究还是一种由编译器/配置器/优化器执行的、基于编译和配置的优化操作'。
'笔者认为自动化的工具终将比人完成更多精细的内联工作'。但遗憾的是，当前的商用编译器还不够完善，甚至连内联自动优化都无法做到。因此，人们不得不学习所有和内联相关的细节，并通过麻烦的句法机制以实现内联。'如果顺利的话，将来我们可以忽略所有内联细节而实现内联'，除非当你向后来人提起这个话题：“我记得曾经有段时间我们不得不人工进行编码路径优化。孩子，那真是段美好的过去。”但更有可能的是，当你这样说的时候会想起与内联相关的回忆：“孩子，那真是段糟糕的过去。” C++ 集成开发环境对文档语义的不当维护使编译器完善性难以达到期望水平。

'保留字 "inline" 仅表示对编译器的一种建议，它告诉编译器, 将方法代码内联展开而不是调用可以获得更佳性能'。但是编译器没有义务答应内联请求。因此编译器可以根据自己的意愿或者能力来选择是否进行内联。这就意味着即使没有被明确告知需要内联 (对低价值方法编译器会自动内联，这常常是优化的副作用) 编译器也会这样去做，或者即便被明确告知需要内联却不进行内联。

'通常情况下，编译器对典型方法的内联依然不够完善'。

例如，有些编译器会拒绝内联包含循环的方法，有些则不能处理内联方法或虚方法中的静态变量。在某些场合下编译器可能会无法解析被调用方法的变量空间映射。事实上，有些编译器除了将间接调用、存取器方法（除设置或返回某一属性值外基本不再涉及其他操作的方法）或只包含简单赋值及相关计算语句的方法进行内联外，不会再内联其他方法。因此，主动内联的程序最后可能会被编译器轻易阻止，而这样的编译器是无法满足程序员全部甚至只是大部分的内联需求的。


// !! 虚方法的内联

本书在之前提到过有些编译器会拒绝内联虚方法。这看起来可能理所当然。毕竟虚方法只有在运行时才会进行联编。'虚方法通常被认为总是间接通过函数指针表来进行调用。尽管关于虚方法的这种观点一般来说都是正确的，但其并非完全正确'。比如下面的代码段:

inline virtual int x::y(char* a)
{
    ...
}


void z(char* b)
{
    x_base* x_pointer = new x(some_argument_maybe);
    x x_instance(maybe_some_more_argument);
    x_pointer->y(b);
    x_instance.y(b);
}

y() 是虚方法，但其联编过程并非总要等到运行阶段才能进行。

示例中，y() 被 x_pointer 和 x_instance 调用。'延时虚方法的联编以对象指针的使用为基础'。'对象实例对虚方法的任何调用都将产生对虚方法实例的直接调用，并且该虚方法实例和对象的类型相关'。在调用联编时却不存在任何延时。因为这种延时会适得其反: 对象类型在编译阶段是已知的,不必也不可能使用多态。

'编译器在任何时候都要避免虚方法在运行阶段产生的额外调用开销，并且由于对象实例不具备多态性，因此编译器总要通过对象实例产生对虚方法的直接调用'。

在某些实例中，如上例，编译阶段已经知道其类型可能为多态指针，这种情况下，对虚方法进行直接调用是可行的。对象指针可以是多态的，但如果与对象指针关联的对象是可见的，并且其间没有用实际类型未知的对象给对象指针赋值，'那么编译器在编译时可以确定方法的哪个虚拟实例应被调用，且产生直接调用而非虚调用'。

在 x_pointer 的实例中，编译器不辞劳苦地确定了(动态对象实例的结构是可见的，同时未对 x_pointer 赋值，这种赋值可能改变此基类指针引用的对象类型) 关于 y() 的哪些虚方法需要被调用的多态解决方案。'真实环境下，在编译阶段会有许多虚方法调用被解析'。例如，所有在虚方法内由 this 指针引发的对虚方法的调用都存在至少一种可能的编译器解决方案。

'这就意味着如果编译器足够完善, 许多对虚方法的调用是可以内联化的'。因此，如果配置文件指出某些虚方法需要占用程序过多的运行时间，则可通过将部分方法调用内联化来挽回一些开销。这也说明如果编译器有能力并且选择了将虚方法内联化，那么几乎可以保证一定会有一些针对同一方法的内联调用实例以及虚方法调用实例



// !! 通过内联提升性能

考虑将一个简单的存取方法(可以访问对象属性的方法)内联化所产生的影响:

int x::get_y()
{
    return y;
}

方法本身可能仅需 3 或 4 个时钟周期即可执行完毕。但是如果被调用，即便是这种简单的方法也要产生多达 20 个时钟周期的开销。而如果将其内联，则只需耗费 1 或 2 个时钟周期(之所以比原来的少两个指令，是因为省略了调用和返回指令)。因此，内联可以提供多达 10 倍的速度提升。

同时应该记住，20 个时钟周期中节省出的大部分开销都是与调用相关的指令。这就意味着除了节约这 20 个时钟周期的开销外，每个静态内联方法的调用(程序中调用内联方法的位置数量)还减少了 12 条指令，从而亦减少了代码量。

#include<iostream.h>

// inline
int calc(int a, int b)
{
    return a + b;
}

int main()
{
    int x[1000];
    int y[1000];
    int z[1000];

    for(int i=0; i<1000; i++)
    {
        for(int j=0; j<1000; j++)
        {
            for(int k=0; k<1000; k++)
            {
                z[i] = calc(x[j], y[k]);
            }
        }
    }
}

为测试内联对执行速度的影响，该程序运行了两次。第一次运行时，其中的 calc 是内联的，耗时 8s。第二次运行时，calc 是外联(非内联)的，耗时 62s。因此，通过消除
调用开销，本程序轻松获取了 8 倍的性能提升。内联版本的程序代码量也减少了 30 字节，在这个示例中代码至少减少了 10%。将此方法内联化的结果是使程序变得更快而且更小。


// !! 要点

● 内联就是用方法的代码来替换对方法的调用

● 内联通过消除调用开销来提升性能，并且允许进行调用间优化

● 内联的主要作用是对运行时间进行优化，当然它也可以使可执行映像变得更小