#include<iostream>
#include<string>

using namespace std;

// !! 类中内联

// 头文件中声明方法

class A
{
public:

    void f1(int x); 

    /**
     * @brief 类中定义了的函数是隐式内联函数,声明要想成为内联函数，必须在实现处(定义处)加 inline 关键字。
     *
     * @param x
     * @param y
     */
    void Foo(int x,int y) /// 定义即隐式内联函数！
    {

    };

    void f1(int x); /// 声明后，要想成为内联函数，必须在定义处加 inline 关键字。  
};

/**
 * @brief inline 要起作用, inline 要与函数定义放在一起, inline 是一种“用于实现的关键字,而不是用于声明的关键字”
 *
 * @param x
 * @param y
 *
 * @return 
 */
int Foo(int x,int y);  // 函数声明
inline int Foo(int x,int y) // 函数定义
{
    return x+y;
}


// 定义处加 inline 关键字，推荐这种写法！!!
/**
 * 编译器对 inline 函数的处理步骤
 * 将 inline 函数体复制到 inline 函数调用点处；
 * 为所用 inline 函数中的局部变量分配内存空间；
 * 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
 * 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）
 */
inline void A::f1(int x)
{

}

// !! 内联能提高函数效率，但并不是所有的函数都定义成内联函数！内联是以代码膨胀(复制)为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率
// !! 以下情况不宜用内联：
// 1. 如果函数体内的代码比较长，使得内联将导致内存消耗代价比较高
// 2. 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大


// !! 虚函数（virtual）可以是内联函数（inline）吗？
// 1. 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联
// 2. 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联


int main(int argc, char **argv)
{
    // !! Why inline ?---在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数
    // 栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间
    // 在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如:函数的死循环递归调用的最终结果就是导致栈内存空间枯竭

    // !! inline 仅是一个对编译器的建议
    // inline 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，
    // 就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。

    // !! 建议：inline 函数的定义放在头文件中


    // !! 类中的成员函数与 inline
    // 定义在类中的成员函数缺省都是内联的，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，
    // 而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的。
}