// !! 循环和关系表达式

// !! for 循环

'很多情况下都需要程序执行重复的任务'，如将数组中的元素累加起来或将歌颂生产的赞歌打印 20 份，C++ 中的 for 循环可以轻松地完成
这种任务。我们来看看程序 forloop.cpp，以了解 for 循环所做的工作，然后讨论它是如何工作的。

// forloop.cpp
#include <iostream>

int main()
{
    using namespace std;
    int i;
    for(i = 0; i < 5; i++)
    {
        cout << "C++ knows loop\n";
    }
    cout << "C++ knows when to stop loop\n";
}

 » g++ --std=c++11 forloop.cpp 
--------------------------------------------------------------------------------
 » ./a.out
C++ knows loop
C++ knows loop
C++ knows loop
C++ knows loop
C++ knows loop
C++ knows when to stop loop


1. 该循环首先将整数变量 i 设置为 0, 这是循环的初始化（loop initialization）部分

2. 然后，循环测试（loop test）部分检查 i 是否小于 5

3. 如果确实小于 5，则程序将执行接下来的语句—循环体（loop body）

4. 然后，程序使用循环更新（loop update）部分将 i 加 1

for 循环为执行重复的操作提供了循序渐进的步骤。我们来具体看一看它是如何工作的。for 循环的组成部分完成下面这些步骤。

1．设置初始值。
2．执行测试，看看循环是否应当继续进行
3．执行循环操作
4．更新用于测试的值

C++ 循环设计中包括了这些要素，很容易识别。'初始化、测试和更新操作构成了控制部分，这些操作由括号括起'。其中每部分都是一个表达
式，彼此由分号隔开。'控制部分后面的语句叫作循环体'，只要测试表达式为 true，它便被执行

实际上，C++ 并没有将 test-expression 的值限制为只能为真或假。可以使用任意表达式，C++ 将把结果强制转换为 bool 类型。因此，
值为 0 的表达式将被转换为 bool 值 false，导致循环结束。如果表达式的值为非零，则被强制转换为 bool 值 true，循环将继续进行。


// !! 递增运算符（++）和递减运算符（−−）

递增运算符（++）（名称 C++ 由此得到）和递减运算符（−−）。这两个运算符执行两种极其常见的循环操作: 将循环计数加 1 或减 1。然而，
它们还有很多特点不为读者所知。这两个运算符都有两种变体。'前缀（prefix）版本位于操作数前面，如 ++x；后缀（postfix）版本位于操
作数后面，如x++'。 '两个版本对操作数的影响是一样的，但是影响的时间不同'

程序 plus_one.cpp 演示递增运算符的这种差别。

// plus_one.cpp
#include<iostream>

int main()
{
    using std::cout;
    int a = 20;
    int b = 20;
    cout << "a = " << a << " b = " << b << "\n";
    cout << "a++ = " << a++ << " ++b = " << ++b << "\n";
    cout << "a = " << a << " b = " << b << "\n";
    return 0;
}

 » g++ --std=c++11 plus_one.cpp                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 » ./a.out                                                                                      
a = 20 b = 20
a++ = 20 ++b = 21
a = 21 b = 21

'粗略地讲，a++ 意味着使用 a 的当前值计算表达式，然后将 a 的值加 1；而 ++b 的意思是先将 b 的值加 1，然后使用新的值来计算表达式'。
例如，我们有下面这样的关系:

int x = 5;
int y = ++x;// change x, then assign to y. y is 6

int z = 5;
int y = z++;// assign to y. then change z,y is 5

递增和递减运算符是处理将值加减 1 这种常见任务的一种简约、方便的方法

'递增运算符和递减运算符都是漂亮的小型运算符，不过千万不要失去控制，在同一条语句对同一个值递增或递减多次'。问题在于，规则“使用后
修改”和“修改后使用”可能会变得模糊不清。


// !! 副作用和顺序点

下面更详细地介绍 C++ 就递增运算符何时生效的哪些方面做了规定，哪些方面没有规定。

'副作用（side effect）指的是在计算表达式时对某些东西（如存储在变量中的值）进行了修改'

'顺序点（sequence point）是程序执行过程中的一个点，在这里，进入下一步之前将确保对所有的副作用都进行了评估'

在 C++ 中，语句中的分号就是一个顺序点，这意味着程序处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行的所有修改都必
须完成。另外，任何完整的表达式末尾都是一个顺序点。

'何为完整表达式呢'？

它是这样一个表达式：不是另一个更大表达式的子表达式。完整表达式的例子有: 表达式语句中的表达式部分以及用作 while 循环中检测条件
的表达式

'顺序点有助于阐明后缀递增何时进行'。例如请看下面的代码:

while (guess++ < 10)
{
    cout << guess << "\n";
}

while 循环它类似于只有测试表达式的 for 循环。在这里，C++ 新手可能认为“使用值，然后递增”意味着先在 cout 语句中使用 guess 的值，
再将其值加 1。然而，'表达式 guess++ < 10 是一个完整表达式，因为它是一个 while 循环的测试条件，因此该表达式的末尾是一个顺序点'。
所以，C++ 确保副作用（将 guess 加 1）在程序进入 cout 之前完成。然而，通过使用后缀格式，可确保将 guess 同 10 进行比较后再将其
值加 1


现在来看下面的语句:

y = (4 + x++) + (6 + x++);

表达式 4 + x++ 不是一个完整表达式，因此，C++ 不保证 x 的值在计算子表达式 4 + x++ 后立刻增加1。在这个例子中，'整条赋值语句是一个
完整表达式，而分号标示了顺序点'，因此 C++ 只保证程序执行到下一条语句之前，x 的值将被递增两次。C++ 没有规定是在计算每个子表达式之后
将 x 的值递增，还是在整个表达式计算完毕后才将 x 的值递增，有鉴于此，您应避免使用这样的表达式

在 C++11 文档中，不再使用术语“顺序点”了，因为这个概念难以用于讨论多线程执行。相反，使用了术语“顺序”，它表示有些事件在其他事件前发生。
这种描述方法并非要改变规则，而旨在更清晰地描述多线程编程


// !!前缀格式和后缀格式

显然，如果变量被用于某些目的（如用作函数参数或给变量赋值），使用前缀格式和后缀格式的结果将不同。然而，如果递增表达式的值没有被使用，
情况又如何呢？例如，下面两条语句的作用是否不同？

x++;
++x;

下面两条语句的作用是否不同？

for(n = lim; n > 0; n--) 
{

}

for(n = lim; n > 0; --n) 
{

}

从逻辑上说，在上述两种情形下，使用前缀格式和后缀格式没有任何区别。'表达式的值未被使用，因此只存在副作用'。在上面的例子中，使用这
些运算符的表达式为完整表达式，因此将 x 加 1 和 n 减 1 的副作用将在程序进入下一步之前完成，前缀格式和后缀格式的最终效果相同


然而，虽然选择使用前缀格式还是后缀格式对程序的行为没有影响，但执行速度可能有细微的差别。对于内置类型和当代的编译器而言，这看似不是
什么问题。然而，C++ 允许您针对类定义这些运算符，在这种情况下，用户这样定义前缀函数： 将值加 1，然后返回结果

但后缀版本首先复制一个副本，将其加 1，然后将复制的副本返回。'因此，对于类而言，前缀版本的效率比后缀版本高'


// !! 递增、递减运算符和指针

可以将递增运算符用于指针和基本变量。将递增运算符用于指针时，将把指针的值增加其指向的数据类型占用的字节数，这种规则适用于对指针
递增和递减：

double arr[4] = {0.0, 1.0, 2.0, 3.0};
double *ptr = arr;
++ptr;


// !! 关系表达式

'计算机不只是机械的数字计数器。它能够对值进行比较，这种能力是计算机决策的基础'。在 C++ 中，关系运算符是这种能力的体现。C++ 提供了 6 种
关系运算符来对数字进行比较。由于字符用其 ASCII 码表示，因此也可以将这些运算符用于字符。不能将它们用于 C-Style string，但可用于 string 
类对象。对于所有的关系表达式，如果比较结果为真，则其值将为 true，否则为 false，因此可将其用作循环测试表达式。

// !! C-Style string 的比较

假设要知道字符数组中的字符串是不是 mate, 如果 word 是数组名，下面的测试可能并不能像我们预想的那样工作:

word = "mate";

请记住，数组名是数组的地址。同样，用引号括起的字符串常量也是其地址。因此，上面的关系表达式不是判断两个字符串是否相同，而是查看它们是否存储
在相同的地址上。两个字符串的地址是否相同呢？答案是否定的，虽然它们包含相同的字符。

由于 C++ 将 C-Style string 视为地址，因此如果使用关系运算符来比较它们，将无法得到满意的结果。应使用 C-Style string 库(cstring)
中的 strcmp() 函数来比较。

该函数接受两个字符串地址作为参数。这意味着参数可以是指针、字符串常量或字符数组名。如果两个字符串相同，该函数将返回零；如果第一个字符串
按字母顺序排在第二个字符串之前，则 strcmp() 将返回一个负数值；如果第一个字符串按字母顺序排在第二个字符串之后，则 strcmp() 将返回一
个正数值。

在有些语言（如 BASIC 和标准 Pascal）中，存储在不同长度的数组中的字符串彼此不相等。但是 C-Style string 是通过结尾的空值字符定义的
，而不是由其所在数组的长度定义的。'这意味着两个字符串即使被存储在长度不同的数组中，也可能是相同的':

char big[100] = "hello";// 5 letters plus \0
char ttt[6] = "hello";// 5 letters plus \0

'虽然不能用关系运算符来比较字符串，但却可以用它们来比较字符'，因为字符实际上是整型。因此下面的代码可以用来显示字母表中的字符
，至少对于 ASCII 字符集和 Unicode 字符集来说是有效的:


for(char c = 'a',c <= 'z',c++)
{
    cout << c << "\0";
}


程序 compstr1.cpp 在 for 循环的测试条件中使用了 strcmp()。该程序显示一个单词，修改其首字母，然后再次显示这个单词，这样循环往复，直
到 strcmp() 确定该单词与字符串 “mate” 相同为止。注意，该程序清单包含了文件 cstring，因为它提供了 strcmp() 的函数原型。

// compstr1.cpp
#include <iostream>
#include <cstring>

int main()
{
    using namespace std;
    char word[5] = "?ate";
    for(char ch = 'a'; strcmp(word, "mate"); ch++)
    {
        cout << word << "\n";
        word[0] = ch;
    }
    cout << "After loop ends, word is " << word << "\n";
    return 0;
}


 » g++ --std=c++11 compstr1.cpp 
-------------------------------------------------------------------------------
 » ./a.out

?ate
aate
bate
cate
date
eate
fate
gate
hate
iate
jate
kate
late

After loop ends, word is mate

// !! 比较 string 类字符串

如果使用 string 类字符串而不是 C-Style string，比较起来将简单些，因为类设计让您能够使用关系运算符进行比较。这之所以可行，
是因为类函数重载（重新定义）了这些运算符。程序 compstr2.cpp 它使用的是 string 对象而不是 char 数组。

// compstr2.cpp

#include <iostream>
#include<string>

int main()
{
    using namespace std;
    string word = "?ate";
    for(char ch = 'a'; word != "mate"; ch++)
    {
        cout << word << endl;
        word[0] = ch;
    }
    cout << "After loop ends, word is " << word << "\n";
    return 0;
}


下面的测试条件使用了一个关系运算符，该运算符的左边是一个 string 对象，右边是一个 C-Style string：

word != "mate"

string 类重载运算符 != 的方式让您能够在下述条件下使用它: 至少有一个操作数为 string 对象，另一个操作数可以是 string 对象，
也可以是 C-Style string。string 类的设计让您能够将 string 对象作为一个实体（在关系型测试表达式中），也可以将其作为一个聚合对象，从而
使用数组表示法来提取其中的字符。正如您看到的，使用 C-Style string 和 string 对象可获得相同的结果，但'使用 string 对象更简单、更直观'。


// !! 基于范围的 for 循环（C++11）

C++11 新增了一种循环：基于范围（range-based）的 for 循环。这简化了一种常见的循环任务:对数组（或容器类，如 vector 和 array）的每个元素
执行相同的操作，如下例所示：

double prices[5] = {1.10,2.20,3.0,4.2,1.10};

for(double x:prices)
{
    cout << x << endl;
}

其中，x 最初表示数组 prices 的第一个元素。显示第一个元素后，不断执行循环，而 x 依次表示数组的其他元素。因此，上述代码显示全部 5 个元素，每
个元素占据一行。总之，该循环显示数组中的每个值。

'要修改数组的元素，需要使用不同的循环变量语法': 

for(double &x : prices)
{
    x = x * 0.80;
}

符号 & 表明 x 是一个引用变量。就这里而言，这种声明让接下来的代码能够修改数组的内容，而第一种语法不能


还可结合使用基于范围的 for 循环和初始化列表：

for(int x:{1,2,3,4,5,6,7,8})
{
    cout << x << endl;
}

// !! 循环和文本输入

知道循环的工作原理后，来看一看循环完成的一项最常见、最重要的任务: 逐字符地读取来自文件或键盘的文本。

1.  使用原始的 cin 进行输入

如果程序要使用循环来读取来自键盘的文本输入， 则必须有办法知道何时停止读取。如何知道这一点呢？一种方法是选择某个特殊字符—有时被称为'哨兵字符
（sentinel character），将其作为停止标记'

例如, 程序 textin1.cpp 在遇到 # 字符时停止读取输入。该程序计算读取的字符数，并回显这些字符，即在屏幕上显示读取的字符。

// textin1.cpp
#include <iostream>

int main()
{
    using namespace std;
    char ch;
    int count = 0;
    cout << "Enter a character; enter # to quit:\n";
    cin >> ch;
    while (ch != '#')
    {
        cout << ch;
        ++count;
        cin >> ch;
    }
    cout << endl << count << " characters entered\n";
    return 0;
}

 » g++ --std=c++11 textin1.cpp 
-------------------------------------------------------------------------------
 » ./a.out
Enter a character; enter # to quit:
ssh key run#hello world
sshkeyrun
9 characters entered


1. 请注意该程序的结构。该程序在循环之前读取第一个输入字符，'这样循环可以测试第一个字符'。这很重要，因为第一个字符可能是 #。由于 
textin1.cpp 使用的是'入口条件循环'，因此在这种情况下，能够正确地跳过整个循环。由于前面已经将变量 count 设置为 0，因此 count 
的值也是正确的

2. 如果读取的第一个字符不是 #，则程序进入该循环，显示字符，增加计数，然后读取下一个字符。最后一步是极为重要的，没有这一步，循环将反复处
理第一个输入字符，一直进行下去。有了这一步后，程序就可以处理到下一个字符

3. 上面的做法合情合理。但为什么程序在输出时省略了空格呢？原因在 cin, '读取 char 值时，与读取其他基本类型一样，cin 将忽略空格和换行符'。
因此输入中的空格没有被回显，也没有被包括在计数内

4. 更为复杂的是，'发送给 cin 的输入被缓冲'。这意味着只有在用户按下回车键后，他输入的内容才会被发送给程序。这就是在运行该程序时，可以在 # 
后面输入字符的原因。按下回车键后，整个字符序列将被发送给程序，但程序在遇到 # 字符后将结束对输入的处理


// !! 使用 cin.get(char) 进行补救

'通常，逐个字符读取输入的程序需要检查每个字符，包括空格、制表符和换行符'。cin 所属的 istream 类（在 iostream 中定义）中包含一个能够
满足这种要求的成员函数

具体地说，'成员函数 cin.get(ch) 读取输入中的下一个字符（即使它是空格），并将其赋给变量 ch'。

使用这个函数调用替换 cin>>ch，可以修补程序 textin1.cpp 的问题。程序 textin2.cpp 列出了修改后的代码。

// textin2.cpp
#include <iostream>

int main()
{
    using namespace std;
    char ch;
    int count = 0;

    cout << "Enter character; enter # to quit:\n";
    cin.get(ch);
    while (ch != '#')
    {
        cout << ch;
        ++ count;
        cin.get(ch);
    }
    cout << endl << count << " characters entered\n";
    return 0;
}

 » g++ --std=c++11 textin2.cpp 
-------------------------------------------------------------------------------
 » ./a.out

Enter character; enter # to quit:
ssh key run#hello world
ssh key run
11 characters entered

现在，该程序回显了每个字符，并将全部字符计算在内，其中包括空格。'输入仍被缓冲'，因此输入的字符个数仍可能比最终到达程序的要多。

// !! 使用哪一个 cin.get()

char name[ArSize];
...
cout << "Enter your name:\n";
cin.get(name,ArSize).get();

最后一行相当于两个连续的函数调用：

cin.get(name,ArSize);
cin.get();

cin.get() 的一个版本接受两个参数：数组名（字符串（char*类型）的地址）和 ArSize（int类型的整数）。（记住，数组名是其第一个元素的地址，
因此字符数组名的类型为 char*）接下来，程序使用了不接受任何参数的cin.get()。而最近，我们这样使用过 cin.get()：

char ch;
cin.get(ch);

这里 cin.get 接受一个 char 参数。

看到这里，熟悉 C 语言的读者将再次感到兴奋或困惑。在 C 语言中，如果函数接受 char 指针和 int 参数，则使用该函数时，不能只传递一个参数（
类型不同）。但在 C++ 中，可以这样做，因为该语言支持被称为函数重载的 OOP 特性。函数重载允许创建多个同名函数，条件是它们的参数列表不同。

'函数重载允许对多个相关的函数使用相同的名称，这些函数以不同方式或针对不同类型执行相同的基本任务'。

// !! 文件尾条件

使用诸如 # 等符号来表示输入结束很难令人满意，因为这样的符号可能就是合法输入的组成部分，其他符号（如@和%）也如此。

'如果输入来自于文件，则可以使用一种功能更强大的技术—检测文件尾（EOF）'。C++ 输入工具和操作系统协同工作，来检测文件尾并将这种信息告知
程序。


'很多操作系统都允许通过键盘来模拟文件尾条件'。在 Unix 中，可以在行首按下 Ctrl+D 来实现；在 Windows 命令提示符模式下，可以在任意位置按 
Ctrl+Z 和 Enter。

如果编程环境能够检测 EOF，可以在类似于程序 textin2.cpp 的程序中使用重定向的文件，也可以使用键盘输入，并在键盘输入中模拟 EOF。这一点似乎很有用，
因此我们来看看究竟如何做。

检测到 EOF 后，cin 将两位（eofbit 和 failbit）都设置为 1。可以通过成员函数 eof() 来查看 eofbit 是否被设置；如果检测到 EOF，则 cin.eof() 
将返回 bool 值 true，否则返回 false。同样，如果 eofbit或failbit 被设置为1，则 fail() 成员函数返回 true，否则返回false。注意，eof() 和 
fail() 方法报告最近读取的结果；也就是说，它们在事后报告，而不是预先报告。

因此应将 cin.eof() 或 cin.fail() 测试放在读取后，程序 textin3.cpp 中的设计体现了这一点。它使用的是 fail()，而不是 eof()，因为前者可用于
更多的实现中。

// textin3.cpp
#include<iostream>

int main()
{
    using namespace std;
    char ch;
    int count = 0;

    cout << "Enter character; enter # to quit:\n";
    cin.get(ch);
    while (cin.fail() == false)
    {
        cout << ch;
        ++ count;
        cin.get(ch);
    }
    cout << endl << count << " characters entered\n";
    return 0;
}

// !! 常见的字符输入做法

每次读取一个字符，直到遇到 EOF 的输入循环的基本设计如下：

char ch;
cin.get(ch);
int count = 0;
while (cin.fail() == false) 
{
    cout << ch;
    ++count;
    cin.get(ch);
}

可以在上述代码中使用一些简捷方式。

while(!cin.fail())

方法 cin.get(char) 的返回值是一个 cin 对象。然而，'istream 类提供了一个可以将 istream 对象（如 cin）转换为 bool 值的函数'；当 cin 出现
在需要 bool 值的地方（如在 while 循环的测试条件中）时，该转换函数将被调用。另外，如果最后一次读取成功了，则转换得到的 bool 值为 true；否则
为 false。这意味着可以将上述 while 测试改写为这样:

while(cin)// while input is successfully
{

}

这比 !cin.fail() 或 !cin.eof() 更通用，因为它可以检测到其他失败原因，如磁盘故障。


最后，由于 cin.get(ch) 的返回值为 cin，因此可以将循环精简成这种格式：

char ch;
while(cin.get(ch))// while input is successfully
{
    // dostuff
}

这样，cin.get(char) 只被调用一次，而不是两次: 循环前一次、循环结束后一次。为判断循环测试条件，程序必须首先调用 cin.get(ch)。如果成功，则将值
放入 ch 中。然后，程序获得函数调用的返回值，即 cin 。接下来，程序对 cin 进行 bool 转换，如果输入成功，则结果为 true，否则为 false。

'三条指导原则（确定结束条件、对条件进行初始化以及更新条件）全部被放在循环测试条件中'。


// !! 另一个 cin.get() 版本

“怀旧”的 C 语言用户可能喜欢 C 语言中的字符 I/O 函数— getchar() 和 putchar()，它们仍然适用，只要像在 C 语言中那样包含头文件 stdio.h（或新的
cstdio）即可。也可以使用 istream 和 ostream 类中类似功能的成员函数，来看看这种方式。

1. 不接受任何参数的 cin.get() 成员函数返回输入中的下一个字符。也就是说，可以这样使用它：

ch = cin.get();

该函数的工作方式与 C 语言中的 getchar() 相似，将字符编码作为 int 值返回；而 cin.get(ch) 返回一个对象，而不是读取的字符。

同样，可以使用 cout.put() 函数来显示字符：

char ch;
cout.put(ch);

该函数的工作方式类似C语言中的 putchar()，只不过其参数类型为 char，而不是 int。

为成功地使用 cin.get()，需要知道其如何处理 EOF 条件。当该函数到达 EOF 时，将没有可返回的字符。相反，cin.get() 将返回一个用符号常量 EOF 表示
的特殊值。该常量是在头文件 iostream 中定义的。EOF 值必须不同于任何有效的字符值，以便程序不会将 EOF 与常规字符混淆。通常，EOF 被定义为值 −1，因
为没有 ASCII 码为 −1 的字符，但并不需要知道实际的值，而只需在程序中使用 EOF 即可。例如，以下程序：


char ch;
cin.get(ch);
while (cin.fail() == false)
{
    cout << ch;
    ++count;
    cin.get(ch);
}

可以使用 int ch，并用 cin.get() 代替 cin.get(char)，用 cout.put() 代替 cout，用 EOF 测试代替 cin.fail()测试：

int ch；
ch = cin.get();
while (ch != EOF)
{
    cout.put(ch);
    ++count;
    ch = cin.get();
}

如果 ch 是一个字符，则循环将显示它。如果 ch 为 EOF，则循环将结束。


除了当前所做的修改外，关于使用 cin.get() 还有一个微妙而重要的问题。由于 EOF 表示的不是有效字符编码，因此可能不与 char 类型兼容。例如，
在有些系统中，char 类型是没有符号的，因此 char 变量不可能为 EOF 值（−1）。由于这种原因，如果使用 cin.get()（没有参数）并测试 EOF，则必须将返回
值赋给 int 变量，而不是 char 变量。另外，如果将 ch 的类型声明为 int，而不是 char，则必须在显示 ch 时将其强制转换为 char 类型。

// textin4.cpp
#include<iostream>

int main()
{
    using namespace std;
    int ch;
    int count = 0;

    cout << "Enter character; enter # to quit:\n";
    while (ch = cin.get()) != EOF;)
    {
        cout.put(char(ch));
        ++ count;
        ch = cin.get();
    }
    cout << endl << count << " characters entered\n";
    return 0;
}


// !! 嵌套循环和二维数组

首先，介绍一下什么是二维数组。到目前为止，使用的数组都是一维数组，'因为每个数组都可以看作是一行数据'。'二维数组更像是一个表格—既有数据行又有数据列'。
例如，可以用二维数组来表示 6 个不同地区每季度的销售额，每一个地区占一行数据。

'C++ 没有提供二维数组类型，但用户可以创建每个元素本身都是数组的数组'。


例如，假设要存储 5 个城市在 4 年间的最高温度。在这种情况下，可以这样声明数组：

int maxtemp[4][5];

该声明意味着 maxtemps 是一个包含 4 个元素的数组，其中每个元素都是一个由 5 个整数组成的数组。可以将 maxtemps 数组看作由 4 行组成，其中每一行有 5
个温度值。

表达式 maxtemps[0] 是 maxtemps 数组的第一个元素，因此 maxtemps[0] 本身就是一个由 5 个 int 组成的数组。maxtemps[0] 数组的第一个元素是 
maxtemps [0][0]，该元素是一个 int。因此，需要使用两个下标来访问 int 元素。可以认为第一个下标表示行，第二个下标表示列


假设要打印数组所有的内容，可以用一个 for 循环来改变行，用另一个被嵌套的 for 循环来改变列：

for(int row = 0; row < 4; row++)
{
    for(int col = 0; col < 5; col++)
    {
        cout << maxtemps[row][col] << "\t";
    }
    cout << "\n";
}

对于每个 row 值，内部的 for 循环将遍历所有的 col 值。这个示例在每个值之后打印一个制表符（使用 C++ 转义字符表示时为\t），打印完每行后，打印一个
换行符。


// !! 初始化二维数组

'创建二维数组时，可以初始化其所有元素'。这项技术建立在一维数组初始化技术的基础之上: 提供由逗号分隔的用花括号括起的值列表：


int btbus[4] = {1,2,32,4};

对于二维数组来说，由于每个元素本身就是一个数组，因此可以使用与上述代码类似的格式来初始化每一个元素。因此，初始化由一系列逗号分隔的一维数组初始化
（用花括号括起）组成：

int maxtemps[4][5] = 
{
    {1,1,1,1,2},
    {2,2,2,2,1},
    {3,3,3,3,1},
    {4,4,4,4,1}
};

可将数组 maxtemps 包含 4 行，每行包含 5 个数字。{1,1,1,1,2} 初始化第一行，即 maxtemps [0]。'作为一种风格，如果可能的话，每行数据应各占一行，
这样阅读起来将更容易'。


// !! 总结

C++ 提供了 3 种循环：for 循环、while 循环和 do while 循环。'如果循环测试条件为 true 或非零，则循环将重复执行一组指令'；如果测试条件为 false 
或0，则结束循环。'for 循环和 while 循环都是入口条件循环，这意味着程序将在执行循环体中的语句之前检查测试条件'。do while 循环是出口条件循环，这意味
着其将在执行循环体中的语句之后检查条件。

每种循环的句法都要求循环体由一条语句组成。然而，这条语句可以是复合语句，也可以是语句块（由花括号括起的多条语句）。

'关系表达式对两个值进行比较，常被用作循环测试条件'。关系表达式是通过使用 6 种关系运算符之一构成的：<、<=、= =、>=、>或! =。关系表达式的结果为 bool 
类型，值为 true 或 false。

'许多程序都逐字节地读取文本输入或文本文件'，istream 类提供了多种可完成这种工作的方法。如果 ch 是一个 char 变量，则下面的语句将输入中的下一个字符读入
到 ch 中：

cin >> ch;

然而，它将忽略空格、换行符和制表符。下面的成员函数调用读取输入中的下一个字符（而不管该字符是什么）并将其存储到 ch 中：

cin.get(ch);

成员函数调用 cin.get() 返回下一个输入字符—包括空格、换行符和制表符，因此，可以这样使用它：

ch = cin.get();


































