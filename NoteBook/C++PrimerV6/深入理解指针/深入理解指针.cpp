// !! 深入理解指针

'指针强大的功能源于它们能追踪动态分配的内存'。通过指针来管理这部分内存是很多操作的基础, 包括一些用来处理复杂数据结构的操作。'要完全利用这些
能力, 需要理解 C 的动态内存管理是怎么回事'。

C 程序在运行时环境中执行, 这通常是由操作系统提供的环境, 支持栈和堆以及其他的程序行为。

'内存管理对所有程序来说都很重要'。有时候内存由运行时系统隐式地管理, 比如为自动变量分配内存。在这种情况下, 变量分配在它所处的函数的栈帧上。'如果是
静态或全局变量,内存处于程序的数据段,会被自动清零'。数据段是一个区别于可执行代码和运行时系统管理的其他数据的内存区域。

由于可以先分配内存然后释放, 因而应用程序可以更灵活高效地管理内存,'无需为适应数据结构可能的最大长度分配内存, 只要分配实际需要的内存即可'。

比如, 在 C99 以前数组是固定长度的。如果我们要持有可变数量的元素, 比如员工记录, 可能就必须声明一个足够大的数组来装下可能的最大员工数。'如果我们低
估了这个值, 那就只能重新编译应用程序或是采用别的办法'。'如果高估了, 那就会浪费空间'。动态分配内存的能力也对使用链表或队列等可变数量元素的数据结构有
帮助。

注意 C99 引入了变长数组(VLA)。数组长度在运行时而不是编译时确定。不过, 数组一旦创建出来就不能再改变长度了。

像 C 这类语言也支持动态内存管理, '对象就是从堆上分配出来的内存。这是用分配(malloc)和释放(free)函数手动实现的, 这个过程被称为动态内存管理'。

'接下来我们首先概述如何分配和释放内存'。然后讲解基本的分配函数, 如 malloc 和 realloc, 还有 free 函数, 包括 NULL 的使用和重复释放这类问题。

迷途指针是个常见问题。我们会通过示例说明什么情况下出现迷途指针以及处理这种问题的技术。最后讲解内存管理的其他技术。指针使用不当会造成不可预期的行为,
这么说的意思是程序可能产生无效结果, 损坏数据或者终止程序。


// !! 动态内存分配

在 C 中动态分配内存的基本步骤有:

1. 用 malloc 类的函数分配内存

2. 用这些内存支持应用程序

3. 用 free 函数释放内存


这个方法在具体操作上可能存在一些小变化, 不过这里列出的是最常见的。在下例中, 我们用 malloc 函数为整数分配内存。指针将分配的内存赋值为 5, 然后内存
被 free 函数释放。

#include <iostream>
#include <malloc.h>

using namespace std;

int main()
{
    int *pi = (int *)malloc(sizeof(int));
    *pi = 5;
    cout << "sizeof int is " << sizeof(int) << endl;
    free(pi);
    return 0;
}

 » g++ --std=c++11 DemoDynamicMemory.cpp 
--------------------------------------------------------------------------------
 » ./a.out        
sizeof int is 4
--------------------------------------------------------------------------------
 » 

malloc 函数的参数指定要分配的字节数。'如果成功, 它会返回从堆上分配的内存的指针。如果失败则会返回空指针'。后面再讨论测试所分配内存的指针是否有效。
'sizeof 操作符使应用程序更容易移植, 还能确定在宿主系统中应该分配的正确的字节数'。


在本例中, 我们试图为整数分配足够多的内存。假定长度是 4, 我们可以这么写:

int *pi = (int*) malloc(4));

'然而, 依赖于系统所用的内存模型, 整数的长度可能会发生变化'。可移植的方法是使用 sizeof 操作符, 这样不管程序在哪里运行都会返回正确的长度。

注意, 涉及解引操作的常见错误见下面的代码:

    int *pi;
    *pi = (int*) malloc(sizeof(int));

问题出在赋值符号的左边。我们在解引指针, 这样会把 malloc 函数返回的地址赋给 pi 中存放的地址所在的内存单元。如果这是第一次对指针进行赋值操作, 那指针
所包含的地址可能无效。正确的方法如下所示:

    int *pi;
    pi = (int*) malloc(sizeof(int));

注意, 每次调用 malloc (或类似函数), 程序结束时必须有对应的 free 函数调用, 以防止内存泄漏。一旦内存被释放, 就不应该再访问它了。通常我们不会在释
放内存后有意去访问, 不过也存在意外访问的情况。这时系统的行为将依赖于实现。'通常的做法总是把被释放的指针赋值为 NULL'。

'分配内存时, 堆管理器维护的数据结构中会保存额外的信息。这些信息包括块大小和其他一些东西',通常放在紧挨着分配块的位置。如果应用程序的写入操作超出了这
块内存, 数据结构可能会被破坏。这可能会造成程序奇怪的行为或者堆损坏。

考虑如下代码段, 我们为字符串分配内存, 让它可以存放最多 5 个字符外加结尾的 NULL 字符。for 循环在每个位置写入 0, 但是没有在写入 6 字节后停止。
for 语句的结束条件是写入 8 字节。写入的 0 是二进制 0 而不是 ASCII 字符 0 的值。


char *pc = (char *)malloc(6);
for(int i = 0; i < 8 ; i++)
{
    *pc[i] = 0;
}

6 字节的字符串后面还分配了额外的内存, 这是堆管理器用来记录内存分配的。'如果我们越过字符串的结尾边界写入, 额外的内存中的数据会损坏'。在本例中, 额外
的内存跟在字符串后面。不过, 实际的位置和原始信息取决于编译器。



// !! 内存泄漏

如果不再使用已分配的内存却没有将其释放就会发生内存泄漏, 导致内存泄漏的情况可能如下:

丢失内存地址

应该调用 free 函数却没有调用(有时候也称为隐式泄漏)

'内存泄漏的一个问题是无法回收内存并重复利用, 堆管理器可用的内存将变少'。如果内存不断地被分配并丢失, 那么当需要更多内存而 malloc 又不能分配时程序可
能会终止, 因为它用光了内存。在极端情况下, 操作系统可能崩溃。

下面这个简单的例子可以说明这个问题:

char * chunk;
while (1)
{
    chunk = (char *)malloc(1024*1024);
    printf("Allocating\n");
}

chunk 变量指向堆上的内存。然而, 在它指向另一块内存之前没有释放当前所指向的这块内存。最终, 程序会用光内存然后非正常终止, 即使没有终止, 至少内存的利
用效率也不高。


1. 丢失地址

下面的代码段说明了当 pi 被赋值为一个新地址时丢失内存地址的例子。当 pi 又指向第二次分配的内存时,第一次分配的内存地址就会丢失。

int *pi = (int *)malloc(sizeof(int));
*pi = 5;

...

pi = (int *)malloc(sizeof(int));

下面这个例子是为字符串分配内存, 将其初始化, 并逐个打印字符串:

char *name = (char *)malloc(strlen("Susan") + 1);
strcpy(name,"Susan");
while(*name != 0)
{
    printf("%c", name);
    name++;
}

然而每次迭代 name 都会增加 1, 最后 name 会指向字符串结尾的 NULL 字符,分配内存的起始地址丢失了。

2. 隐式内存泄漏

如果程序应该释放内存而实际却没有释放, 也会发生内存泄漏。如果我们不再需要某个对象但它仍然保存在堆上, 就会发生隐式内存泄漏, 一般这是程序员忽视所致。
这类泄漏的主要问题是对象在使用的内存其实已经不需要了, 应该归还给堆。最差的情况是, 堆管理器可能无法按需分配内存, 导致程序不得不终止。最好的情况是我
们持有了不必要的内存。'在释放用 struct 关键字创建的结构体时也可能发生内存泄漏。如果结构体包含指向动态分配的内存的指针, 那么可能需要在释放结构体之
前先释放这些指针'。


// !! 动态内存分配函数

'有几个内存分配函数可以用来管理动态内存',虽然具体可用的函数取决于系统, 但大部分系统的 stdlib.h 头文件中都有如下函数:

1. malloc --- 从堆上分配内存
2. realloc --- 在之前分配内存的基础上, 将内存重新分配为更大或更小
3. calloc ---从堆上分配内存并清零
4. free --- 将内存块返回给堆

动态内存从堆上分配, 至于一连串内存分配调用, 系统不保证内存的顺序和所分配内存的连续性。'不过, 分配的内存会根据指针的数据类型对齐, 比如说, 4 字节的
整数会分配在能被 4 整除的地址边界上。堆管理器返回的地址是最低字节的地址'。

如 malloc 函数在地址 500 处分配了 4 字节空间, 第二次使用该函数在地址 600 处分配了内存。它们都处于 4 字节地址边界上, 而且不是从相邻的内存位置上
分配的。


// !! 使用 malloc 函数

malloc 函数从堆上分配一块内存, 所分配的字节数由该函数唯一的参数指定, 返回值是 void 指针, 如果内存不足, 就会返回 NULL。'此函数不会清空或者修改内
存, 所以我们认为新分配的内存包含垃圾数据'。

函数的原型如下:

void * malloc(size_t);

这个函数只有一个参数, 类型是 size_t。传递参数给这个函数时要小心, 因为如果参数是负数就会引发问题。在有些系统中, 参数是负数会返回 NULL。

如果 malloc 的参数是0, 其行为是实现相关的: 可能返回 NULL 指针, 也可能返回一个指向分配了 0 字节区域的指针。如果 malloc 函数的参数是 NULL, 那么
一般会生成一个警告然后返回 0 字节。

以下是 malloc 函数的典型用法:

int *pi = (int *)malloc(sizeof(int));

执行malloc函数时会进行以下操作:

(1) 从堆上分配内存

(2) 内存中之前所存储的内容不会被修改或是清空

(3) 返回首字节的地址

注意, 当 malloc 无法分配内存时会返回 NULL, 所以, 在使用它返回的指针之前先检查 NULL 是不错的做法, 如下所示:

int *pi = (int *)malloc(sizeof(int));
if(pi != NULL)
{
// 指针没有问题
}
else
{
// 无效的指针
}

// !! 1. 要不要强制类型转换

'C 引入 void 指针之前, 在两种互不兼容的指针类型之间赋值需要对 malloc 使用显式转换类型以避免产生警告'。因为可以将 void 指针赋值给其他任何指针类
型, 所以就不再需要显式类型转换了。有些开发者认为显式类型转换是不错的做法, 因为:

1. 这样可以说明 malloc 函数的用意
2. 代码可以和 C++(或早期的C编译器)兼容, 后两者需要显式的类型转换

如果没有引用 malloc 的头文件, 类型转换可能会有问题, 编译器可能会产生警告。C 默认函数返回整数, 如果没有引用 malloc 的原型, 编译器会抱怨你试图把
int 赋值给指针。


// !! 2. 分配内存失败

'如果声明了一个指针, 但没有在使用之前为它指向的地址分配内存', 那么内存通常会包含垃圾, 这往往会导致一个无效内存引用的错误。考虑如下代码片段:

int *pi;
...
printf("%d",*pi);

执行这段代码可能会导致一个运行时异常。字符串中这类问题比较常见, 如下所示:

char *name;
print("Enter a name\n");
scanf("%s",&name);

这里使用的是 name 所引用的内存, 看起来似乎可以正确执行, 实际上这块内存还没有分配。


// !! 3. 没有给 malloc 传递正确的参数

malloc 函数分配的字节数是由它的参数指定的, 在用这个函数分配正确的字节数时要小心。比如说要为 10 个双精度浮点数分配空间, 那就需要 80 字节, 
通过下面的代码可以做到:

double *pd = (double *)malloc(sizeof(double) * 10);

'注意, 为数据类型分配指定字节数时尽量用 sizeof 操作符'。

下例尝试为 10 个双精度浮点数分配内存:

double *pd = (double *)malloc(10);

这段代码实际只分配了 10 字节。

// !! 4. 确认所分配的内存数

如果我们为一个字符串分配 64 字节, 堆管理器会分配额外的内存来管理这个块。'malloc 可分配的最大内存是跟系统相关的, 看起来这个大小由 size_t 限制。
不过这个限制可能受可用的物理内存和操作系统的其他限制所影响'。

'执行 malloc 时应该分配所请求数量的内存然后返回内存地址'。如果操作系统采用“惰性初始化”策略直到访问内存才真正分配的话会怎样 ? 这时候万一没有足够
的内存用来分配就会有问题, 答案取决于运行时和操作系统。开发者一般不需要处理这个问题, 因为这种初始化策略非常罕见。


// !! 5. 静态、全局指针和 malloc

'初始化静态或全局变量时不能调用函数'。下面的代码声明一个静态变量, 并试图用 malloc 来初始化:

static int *pi  = malloc(sizeof(int));

这样会产生一个编译时错误消息, 全局变量也一样。'对于静态变量,可以通过在后面用一个单独的语句给变量分配内存来避免这个问题'。但是全局变量不能用单独的赋
值语句, 因为全局变量是在函数和可执行代码外部声明的, 赋值语句这类代码必须出现在函数中:

static int *pi;
pi = (int *)malloc(sizeof(int));

注意, 在编译器看来, 作为初始化操作符的 = 和作为赋值操作符的 = 不一样。


// !! 使用 calloc 函数

'calloc 会在分配的同时清空内存'。该函数的原型如下:

void * calloc(size_t numElements, size_t elementSize);

注意清空内存的意思是将其内容置为二进制 0。

calloc 函数会根据 numElements 和 elementSize 两个参数的乘积来分配内存, 并返回一个指向内存的第一个字节的指针。如果不能分配内存, 则会返回 NULL。
此函数最初用来辅助分配数组内存。

如果 numElements 或 elementSize 为0, calloc 可能返回空指针。如果 calloc 无法分配内存就会返回空指针, 而且全局变量 errno 会设置为
ENOMEM(内存不足), 这是 POSIX 错误码, 有的系统上可能没有。


下例为 pi 分配了 20 字节, 全部包含 0:

int *pi = calloc(5, sizeof(int));

不用 calloc 的话, 用 malloc 函数和 memset 函数可以得到同样的结果, 如下所示:

int *pi = (int *)malloc(sizeof(int)*5);
memset(pi, 0, sizeof(int)*5);

注意, memset 函数会用某个值填充内存块。第一个参数是指向要填充的缓冲区的指针, 第二个参数是填充缓冲区的值, 最后一个参数是要填充的字节数。

如果内存需要清零可以使用 calloc, 不过执行 calloc 可能比执行 malloc 慢。

注意, cfree 函数已经没用了。早期的 C 用 cfree 来释放 calloc 分配的内存。

// !! 使用 realloc 函数

我们可能需要时不时地增加或减少为指针分配的内存, 如果需要一个变长数组这种做法尤其有用。realloc 函数会重新分配内存, 下面是它的原型:

void *realloc(void *ptr, size_t size);

realloc 函数返回指向内存块的指针。该函数接受两个参数: 第一个参数是指向原内存块的指针, 第二个是请求的大小。重新分配的块大小和第一个参数引用的块大
小不同。'返回值是指向重新分配的内存的指针'。

请求的大小可以比当前分配的字节数小或者大。'如果比当前分配的小, 那么多余的内存会还给堆, 不能保证多余的内存会被清空'。如果比当前分配的大,那么可能的话,
就在紧挨着当前分配内存的区域分配新的内存, 否则就会在堆的其他区域分配并把旧的内存复制到新区域。

如果大小是 0 而指针非空, 那么就释放内存。如果无法分配空间, 那么原来的内存块就保持不变, 不过返回的指针是空指针, 且 errno 会设置为 ENOMEM。

堆管理器可以重用原始的内存块, 且不会修改其内容。不过程序继续使用的内存超过了所请求的 8 字节。也就是说, 我们没有修改字符串以便它能装进 8 字节的内存
块中。在本例中, 我们本应该调整字符串的长度以使它能装进重新分配的 8 字节。实现这一点最简单的办法是将 NUL 赋给地址 507。实际使用的内存超出分配的内存
不是个好做法, 应该避免。


// !! 用 free 函数释放内存

有了动态内存分配, 程序员可以将不再使用的内存返还给系统, 这样可以释放内存留作他用。通常用 free 函数实现这一点, 该函数的原型如下:

void free(void *ptr);

'指针参数应该指向由 malloc 类函数分配的内存的地址, 这块内存会被返还给堆'。尽管指针仍然指向这块区域, 但是我们应该将它看成指向垃圾数据。稍后可能重新
分配这块区域, 并将其装进不同的数据。


'调用 free(p) 之后, 只是将 p 所指向的之前申请的内存区域标志为已回收, 可以由 malloc 函数再次申请, 但是 p 值和 p 指向的内存内容并不会自动清空'。


// !! 将已释放的指针赋值为 NULL

已释放的指针仍然可能造成问题。如果我们试图解引一个已释放的指针, 其行为将是未定义的。所以有些程序员会显式地给指针赋 NULL 来表示该指针无效, 后续再使
用这种指针会造成运行时异常。

下面是该方法的示例:

int *pi = (int *)malloc(sizeof(int) * 100);
...
free(pi);
pi = nullptr;

'这种技术的目的是解决迷途指针类问题'。不过, 花时间处理造成这类问题的条件要比粗暴地用空指针一刀切好, 更何况除了初始化的情况, 都不能将 NULL 赋给指针。


// !! 重复释放

'重复释放是指两次释放同一块内存'。下面是一个简单的例子:

#include <iostream>
#include <string.h>

using namespace std;

int main()
{
    char *str = (char*)malloc(sizeof(char) * 13);
    strcpy(str, "0123456789AB");
    cout << "str is " << str << endl;

    free(str);
    free(str);
}

 » g++ --std=c++11 DemoFree.cpp              
--------------------------------------------------------------------------------------------------------------------------
 » ./a.out                                   
str is 0123456789AB
free(): double free detected in tcache 2
[1]    526588 abort (core dumped)  ./a.out

调用第二个 free 函数会导致运行时异常。


另一个例子不那么明显, 涉及指向同一块内存的两个指针。如下所示, 如果我们试图第二次释放同一块内存会发生同样的运行时异常。

#include <iostream>
#include <string.h>

using namespace std;

int main()
{
    char *str = (char*)malloc(sizeof(char) * 13);
    strcpy(str, "0123456789AB");
    cout << "str is " << str << endl;
    char *str2 = str;
    free(str);
    free(str2);
}


 » g++ --std=c++11 DemoFree.cpp      
 » ./a.out                                   
str is 0123456789AB
free(): double free detected in tcache 2
[1]    527545 abort (core dumped)  ./a.out

'注意两个指针引用同一个地址称为别名'。


不幸的是, '堆管理器很难判断一个块是否已经被释放, 因此它们不会试图去检测是否两次释放了同一块内存'。这通常会导致堆损坏和程序终止, 即使程序没有终止, 
它意味着程序逻辑可能存在问题, 同一块内存没有理由释放两次。

// !! 堆和系统内存

'堆一般利用操作系统的功能来管理内存'。堆的大小可能在程序创建后就固定不变了, 也可能可以增长。'不过堆管理器不一定会在调用 free 函数时将内存返还给操作
系统'。释放的内存只是可供应用程序后续使用。所以, 如果程序先分配内存然后释放, '从操作系统的角度看, 释放的内存通常不会反映在应用程序的内存使用上'。


// !! 程序结束前释放内存

'操作系统负责维护应用程序的资源, 包括内存。当应用程序终止时, 操作系统要负责重新分配这块内存以便别的应用程序使用'。已终止的应用程序的内存状态不管是
否损坏都无关紧要, 事实上, 内存损坏可能正是应用程序终止的原因。'异常终止的程序可能无法做清理工作, 因此没有理由在程序终止之前释放分配的内存'。

'话虽如此, 可能又有一些原因要求我们在程序终止前释放内存'。尽责的程序员可能会把释放内存当成质量指标。即使应用程序正在终止, 不再使用内存后将其释放总归
是好习惯。如果用工具来检测内存泄漏或是类似问题, 那么释放内存会让这类工具的输出是干净的。

因此, 确保程序终止前释放所有内存:

可能得不偿失

可能很耗时, 释放复杂结构也比较麻烦

可能增加应用程序大小

导致更长的运行时间

增加引入更多编程错误的概率

是否要在程序终止前释放内存取决于具体的应用程序。


// !! 迷途指针

'如果内存已经释放, 而指针还在引用原始内存, 这样的指针就称为迷途指针'。'迷途指针没有指向有效对象', 有时候也称为过早释放。

使用迷途指针会造成一系列问题, 包括:

1. 如果访问内存, 则行为不可预期

2. 如果内存不可访问, 则是段错误

在下面这个简单的例子中,我们用 malloc 函数为一个整数分配内存, 接下来, 用 free 函数释放内存:

int *pi = (int *)malloc(sizeof(int));
*pi = 5;
printf("pi is %d\n", *pi);
free(pi);

pi 变量持有整数的地址, 但堆管理器可以重复利用这块内存, 且其中存放的可能是非整数数据。

'free pi 后, 大部分运行时系统不会阻止后续的访问或修改'。我们还是可以向这个位置写入数据, 如下所示。这么做的结果是不可预期的。

free(pi);
*pi = 100;

还有一种迷途指针的情况更难觉察: '一个以上的指针引用同一内存区域而其中一个指针被释放'。如下所示, p1 和 p2 都引用同一块内存区域(称为指针别名),
不过 p1 被释放了:

int *pi = (int *)malloc(sizeof(int));
*pi = 1;

...
int *pi2;
pi2 = pi;

free(pi);

....
*pi2 = 10010;// 迷途指针


使用块语句时也可能出现一些小问题, 如下所示。这里 pi 被赋值为 tmp 的地址, 变量 pi 可能是全局变量, 也可能是局部变量。不过当包含 tmp 的块出栈之后,
地址就不再有效:

int *pi;
{
    int temp = 100;
    pi = &temp;
}
// 这里pi变成了迷途指针

...

foo();


'大部分编译器都把块语句当做一个栈帧'。tmp 变量分配在栈帧上, 之后在块语句退出时会出栈。pi 指针现在指向一块最终可能被其他活跃记录(比如foo函数)覆盖
的内存区域。


// !! 处理迷途指针

有时候调试指针诱发的问题会很难解决, 以下方法可用来对付迷途指针。

1. 释放指针后置为 NULL, 后续使用这个指针会终止应用程序。不过, 如果存在多个指针的话还是会有问题。因为赋值只会影响一个指针。

2. 写一个特殊的函数代替 free 函数

3. 有些系统(运行时或调试系统)会在释放后覆写数据(比如 0xDEADBEEF, 取决于被释放的对象, Visual Studio 会用0xCC、0xCD或者0xDD)。在不抛出异常的
   情况下, 如果程序员在预期之外的地方看到这些值, 可以认为程序可能在访问已释放的内存。


// !! 动态内存分配技术

目前为止, 我们已经讨论了如何使用堆管理器分配和释放内存。不过, 不同的编译器在技术实现上有所不同。'大部分堆管理器把堆或数据段作为内存资源'。这种方法
的缺点是会造成碎片, 而且可能和程序栈碰撞。尽管如此, 它还是实现堆最常用的方法。


堆管理器需要处理很多问题, 比如堆是否基于进程和(或)线程分配, 如何保护堆不受安全攻击。

堆管理器有不少, 包括 OpenBSD 的 malloc、Hoard 的 malloc 和 Google 开发的 TCMalloc。GNU C 库的分配器基于通用分配器 
dlmalloc'(http://dmalloc.com), 它提供调试机制，能追踪内存泄漏。dlmalloc 的日志特性可以追踪内存的使用和内存事务，还有一些其他功能。


// !! C 的垃圾回收

'malloc 和 free 函数提供了手动分配和释放内存的方法'。不过对于很多问题, 需要考虑使用 C 的手动内存管理, 比如性能、达到好的引用局部性、线程问题, 
以及优雅地清理内存。

有些非标准的技术可以用来解决部分问题, 这里将探讨其中一部分技术。这些技术的关键特性在于自动释放内存。'内存不再使用之后会被收集起来以备后续使用, 
释放的内存称为垃圾, 因此, 垃圾回收就是指这个过程'。

鉴于以下原因, 垃圾回收是有价值的:

1. 不需要程序员费尽心思决定何时释放内存

2. 让程序员专注应用程序本身的问题


// !! 资源获取即初始化

资源获取即初始化 (Resource Acquisition Is Initialization, RAII)是 Bjarne Stroustrup 发明的技术, 可以用来解决 C++ 中资源的分配和释放。
即使有异常发生, 这种技术也能保证资源的初始化和后续的释放。分配的资源最终总是会得到释放。


// !! 小结

动态内存分配是 C 语言的重要特性。这里主要关注用 malloc 和 free 函数实现手动分配内存。我们解决了涉及这两个函数的一系列常见问题, 包括内存分配失败
和迷途指针。此外, 还有一些非标准技术可用来实现 C 的动态内存管理。我们也接触了几种垃圾回收技术: 包括 RAII 和异常处理。












