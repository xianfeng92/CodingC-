## 编译工具链

软件的编译过程由一系列的步骤完成, 每一个步骤都有一个对应的工具。这些工具紧密地工作在一起, 前一个工具的输出是后一个工具的输入, 像一根链条一样, 我们称这些工
具为工具链。

Linux系统上, 通常只需要使用 gcc 就可以完成整个编译过程。但不要被 gcc 的名字误导, 事实上, gcc 并不是一个编译器, 而是一个驱动程序。在整个的编译过程中, gcc
就像一个包工头一样, 编译过程中的每一个环节由具体的工具负责。比如编译过程由 cc1 负责, 汇编过程由 as 负责, 链接过程由 ld 负责。


对于一个 C 程序来说, 从源码构建出可执行程序经过了三个阶段:

1. 编译: gcc 调用 cc1 进行预编译和编译, 产生的汇编代码保存在/tmp下的文件 ccYBInzt.s (随机)

2. 汇编: gcc 调用 as(assembly) 进行汇编, 汇编过程产生的目标文件保存在 /tmp/ccj54pkM.o

3. 链接: gcc 调用 collect2 安排好静对象, 然后 collect2 调用 ld 链接 ccj54pkM.o 以及启动文件(crt1.0,crti.0,crtbegin.o,crtend.o,crtn.o)和 libc、
   libgcc 等库生成最终的可执行文件。


编译程序会对源文件进行以预处理然后进行词法分析、语法分析、语义分析后生成中间代码并对中间代码进行优化, 最终生成相应的汇编代码。

汇编程序将汇编代码翻译成机器指令, 生成 ELF 格式的目标文件, 还要在目标文件中创建辅助链接时需要的信息, 包括符号表、重定位表等。

链接程序将一个或多个的目标文件和库 (动态和静态库) 链接为一个单独的文件(可执行文件或者动态库或者静态库), 并为生成的文件处理好符号重定位。

链接静态库时有一点要注意, '链接时并不是将整个静态库中的所有的文件都合并到目标文件中, 而是仅链接库中使用的目标文件'。当然, 这个库中的目标文件中可能有个别的函
数用不到。'静态链接在文件生成的最后会处理好符号的重定位问题'。而动态链接无法在文件生成时重定位符号, 只能是生成一份重定位表, 帮助加载器在文件加载运行时重定位
符号。


## 构建工具链

现实中我们自己手工构建工具链的机会并不多, 很多时候我们是使用系统中别人已经构建好的。但是, '工具链中包含的组件可以说是除了操作系统内核以外的最底层的系统软件了'。
无论是对理解操作系统, 还是对开发程序来说, 都有着重要的意义。即使永远不需要自己手工构建工具链, 但是了解工具链的构建过程, 也可以帮助我们更高效灵活地运用已有的工
具链。

工具链的组成:

GUN 将构建软件过程中的工具分别包含在 3 个软件包中: Binutils、GCC、Glibc。

Binutils: 包括二进文件相关的工具, 比如生成目标文件的汇编器 as, 链接器 ld 以及若干处理二进制文件的工具(像 objdump、strip等)。也不是所有工具都是处理二进制
的, 像处理文本的预编译程序 cpp 也在这个包里。

GCC: 包括各种编译器程序, 像 C 编译器、C++ 编译器、Fortran 编译器、Ada 编译器等。这里面还包括了 C++ 的启动文件。

Glibc : 包括 C 库。还包括动态链接器和 C 的启动文件等。事实上, C 库有很多的实现, 比如适用于 Linux 桌面系统的 Glibc、EGlibc 等


除了上面三个软件包以外, 工具链中还需要包括内核头文件。'软件一般很少去直接调用 Linux 的内核接口, 一般都是使用更易用的 C 库'。C 库中很大一部分函数就是对内核服
务的封装。我们可以把内核头文件看作是内核与 C 库之间的协议。


## 构建工具链的过程


我们使用构建交叉编译工具链的方式展示一下这个过程。

GUN 将编译器和 C 库分开放在两个软件包里, 好处是比较灵活, 方便在工具链中可以选择不同的 C 库, 比如 Glibc、uClibc 等。但是, 也带来了编译器和 C 库的循环依赖
问题: 编译 C 库需要 C 编译器, 但是 C 编译器又依赖 C 库。理论上编译器是不应该依赖 C 库的, 它应该只负责将源代码翻译为汇编代码即可,但实际上并非如此, 原因如下:

C 编译器需要根据 C 库的某此特性来决定自己支持哪些特性, 因此 C 编译器要依赖 C 库的头文件。
C++ 的库和编译器需要 C 库支持, 比如异常处理和栈回溯部分。
GCC 不仅包含编译器, 还包含一些库, 这些库通常依赖 C 库
C 编译器本身也会使用  C 库的一些函数。
Glibc 基本是自包含的, 可能有小部分地方使用了 GCC 的代码。


我们可以这样编译一个交叉编译工具链:

1、使用宿主系统中的编译工具链构建一个交叉 Binutils, 包括汇编器 as、链接器 ld等

2、使用宿主系统中的编译工具链构建一个临时的交叉编译器(仅支持 freestanding)

3、安装目标系统的内核头文件

4、使用临时的交叉编译器构建目标系统的 C 库

5、使用临时的交叉编译器构建完整的交叉编译器(支持hosted和freestanding)

正常的我们现在机器上的 GCC 可以在我们机器上运行, 编译生成我们自己机器上运行的程序(也就是输入和输出是同一个体系)。但不能编译生成其它 cpu 或者系统上运行的程序。

我们需要一种 GCC, 这种 GCC 可以在我们机器上运行, 编译生成一种不能在我们机器上运行, 但是可以在其它机器系统上运行的程序(输入和输出不是同一个体系)。对于我们机
器上现在的 GCC 来说, 这种新的 GCC 也是一种程序。

现在我们要先用我们机器上的 GCC 来编译 GCC 源码生成一个新的 GCC 程序, 这个新的 GCC 就是我们需要的。用它能编译生成其它机器上运行的程序(一对一,只能在本机运行,
用于编译生成特定目标系统运行的程序)。'这种新生成的 GCC 程序我们就叫它交叉编译工具'。



