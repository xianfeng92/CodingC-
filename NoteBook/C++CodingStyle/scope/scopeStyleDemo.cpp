#include <iostream>

using namespace std;

// !! 2. 作用域
// 鼓励在 .cpp 文件内使用匿名命名空间或 static 声明, 使用具名的命名空间时, 其名称可基于项目名或相对路径


// !! 2.1. 命名空间
// 命名空间定义：命名空间将全局作用域细分为独立的、具名的作用域, 可有效防止全局作用域的命名冲突
// 虽然类已经提供了（可嵌套的）命名轴线(将命名分割在不同类的作用域内),命名空间在这基础上又封装了一层

// !! 命名空间缺点:
// 1. 命名空间具有迷惑性, 因为它们使得区分两个相同命名所指代的定义更加困难
// 2. 内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用
// 3. 有时候不得不多次引用某个定义在许多嵌套命名空间里的实体，使用完整的命名空间会导致代码的冗长

// !! 在头文件中使用匿名空间导致违背 C++ 的唯一定义原则 (One Definition Rule (ODR))

// !! 结论:
// !! 根据下文将要提到的策略合理使用命名空间

1. 遵守 命名空间命名 中的规则
2. 在命名空间的最后注释出命名空间的名字
// .h 文件
namespace mynamespace {

// 所有声明都置于命名空间中
// 注意不要使用缩进
class MyClass {
    public:
    ...
    void Foo();
};

} // namespace mynamespace


// .cpp 文件
namespace mynamespace {

// 函数定义都置于命名空间中
void MyClass::Foo() {
    ...
}

} // namespace mynamespace


3. 不要在命名空间 std 内声明任何东西, 包括标准库的类前置声明. 在 std 命名空间声明实体是未定义的行为, 会导致如不可移植. 声明标准库下的实体, 
   需要包含对应的头文件.

4. 不应该使用 using 指示 引入整个命名空间的标识符号
// 禁止 —— 污染命名空间
using namespace foo;


5. 不要在头文件中使用 命名空间别名 除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分
// 在 .cpp 中使用别名缩短常用的命名空间
namespace baz = ::foo::bar::baz;

6. 禁止用内联命名空间

// !! 2.2. 匿名命名空间和静态变量

在 .cpp 文件中定义一个不需要被外部引用的变量时，可以将它们放在 ~~匿名命名空间~~ 或声明为 static, 但是不要在 .h 文件中这么做

// !!定义:

所有置于~~匿名命名空间~~的声明都具有~~内部链接性~~，函数和变量可以经由声明为 static 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都
不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。

// !! 结论:

推荐、鼓励在 .cpp 中对于不需要在其他地方引用的标识符使用~~内部链接性~~声明，但是不要在 .h 中使用

匿名命名空间的声明和具名的格式相同，在最后注释上 namespace :

namespace
{
    ...
}// namespace


// !! 2.3.非成员函数、静态成员函数和全局函数

使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，
类的静态方法应当和类的实例或静态数据紧密相关

// !!优点:

某些情况下, 非成员函数和静态成员函数是非常有用的, 将非成员函数放在命名空间内可避免污染全局作用域

// !! 缺点:

将非成员函数和静态成员函数作为新类的成员或许更有意义, 当它们需要访问外部资源或具有重要的依赖关系时更是如此


//!! 结论:

有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数
非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内, 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 
不如使用命名空间 


对于头文件 myproject/foo_bar.h , 应当使用:

namespace myproject {
namespace foo_bar {
void Function1();
void Function2();
}  // namespace foo_bar
}  // namespace myproject

而非:

namespace myproject {
class FooBar {
 public:
  static void Function1();
  static void Function2();
};
}  // namespace myproject

// !! 如果你必须定义非成员函数, 又只是在 .cpp 文件中使用它, 可使用匿名命名空间 或 static 链接关键字限定其作用域


// !! 2.4. 局部变量

将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化

C++ 允许在函数的任何位置声明变量。我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好，这使得代码浏览者更容易定位变量声明的位置, 
了解变量的类型和初始值。特别是，应使用初始化的方式替代声明再赋值

int i;
i = f(); // 坏——初始化和声明分离

int j = g(); // 好——初始化时声明

vector<int> v;
v.push_back(1); // 用花括号初始化更好
v.push_back(2);

vector<int> v = {1, 2}; // 好——v 一开始就初始化

// !! 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低

// 低效的实现
for (int i = 0; i < 1000000; ++i) 
{
    Foo f;                  // 构造函数和析构函数分别调用 1000000 次!
    f.DoSomething(i);
}

在循环作用域外面声明这类变量要高效的多:

Foo f;                      // 构造函数和析构函数只调用 1 次
for (int i = 0; i < 1000000; ++i) 
{
    f.DoSomething(i);
}



// !! 2.5. 静态和全局变量

禁止定义静态储存周期非原生数据类型 (POD : Plain Old Data):变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序
是未明确的，这将导致代码的不可移植。

静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug。

同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明
确行为 (unspecified behaviour)。


// !! 小结

1. 匿名命名空间说白了就是文件作用域
2. 局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」
3. 注意别在循环犯大量构造和析构的低级错误


int main(int argc, char **argv)
{

}