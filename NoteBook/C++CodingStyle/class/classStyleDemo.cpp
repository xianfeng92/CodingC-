#include <iostream>

using namespace std;

// !! 3. 类

类是 C++ 中代码的基本单元。

// !! 3.1. 构造函数的职责

// !! 总述

不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化

// !! 定义

在构造函数中可以进行各种初始化操作


// !! 优点

1. 无需考虑类是否被初始化
2. 经过构造函数完全初始化后的对象可以为 const 类型, 也能更方便地被标准容器或算法使用


// !! 缺点
1. 如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患
2. 在没有使程序崩溃 (因为并不是一个始终合适的方法) 或者使用异常 (因为已经被 禁用 了) 等方法的条件下, 构造函数很难上报错误
3. 如果执行失败, 会得到一个初始化失败的对象, 这个对象有可能进入不正常的状态, 必须使用 bool IsValid() 或类似这
   样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法
4. 构造函数的地址是无法被取得的, 因此, 由构造函数完成的工作是无法以简单的方式交给其他线程的


// !! 结论
1. 构造函数不允许调用虚函数. 如果代码允许, 直接终止程序是一个合适的处理错误的方式. 如果对象需要进行有意义的 (non-trivial) 初始化,
   考虑使用明确的 Init() 方法或使用工厂模式


// !! 3.2. 隐式类型转换

// !! 总述

不要定义隐式类型转换, 对于转换运算符和单参数构造函数, 请使用 explicit 关键字


// !! 定义

隐式类型转换允许一个某种类型 (称作 源类型) 的对象被用于需要另一种类型 (称作 目的类型) 的位置,例如, 将一个 int 类型的参数传递给
需要 double 类型的函数

除了语言所定义的隐式类型转换, 用户还可以通过在类定义中添加合适的成员定义自己需要的转换

在源类型中定义隐式类型转换, 可以通过目的类型名的类型转换运算符实现 (例如 operator bool()). 在目的类型中定义隐式类型转换, 则通过以源类
型作为其唯一参数 (或唯一无默认值的参数) 的构造函数实现.

explicit 关键字可以用于构造函数或 (在 C++11 引入) 类型转换运算符, 以保证只有当目的类型在调用点被显式写明时才能进行类型转换

例如使用 cast. 这不仅作用于隐式类型转换, 还能作用于 C++11 的列表初始化语法:

class Foo
{
    explicit Foo(int x, int y);
    //...
};

void Func(Foo f);

此时下面的代码是不允许的:

Func({42, 3.14});  // Errors

源类型({42, 3.14})   -----> 目的类型(Foo)

这一代码从技术上说并非隐式类型转换, 但是语言标准认为这是 explicit 应当限制的行为


// !! 优点
1. 有时目的类型名是一目了然的, 通过避免显式地写出类型名, 隐式类型转换可以让一个类型的可用性和表达性更强.
2. 隐式类型转换可以简单地取代函数重载
3. 在初始化对象时, 列表初始化语法是一种简洁明了的写法



// !! 缺点

1. 隐式类型转换会隐藏类型不匹配的错误. 有时, 目的类型并不符合用户的期望, 甚至用户根本没有意识到发生了类型转换.
2. 隐式类型转换会让代码难以阅读, 尤其是在有函数重载的时候, 因为这时很难判断到底是哪个函数被调用
3. 单参数构造函数有可能会被无意地用作隐式类型转换
4. 如果单参数构造函数没有加上 explicit 关键字, 读者无法判断这一函数究竟是要作为隐式类型转换, 还是作者忘了加上 explicit 标记
5. 并没有明确的方法用来判断哪个类应该提供类型转换, 这会使得代码变得含糊不清
6. 如果目的类型是隐式指定的, 那么列表初始化会出现和隐式类型转换一样的问题, 尤其是在列表中只有一个元素的时候


// !! 结论

1. 在类型定义中, 类型转换运算符和单参数构造函数都应当用 explicit 进行标记
2. 一个例外是, 拷贝和移动构造函数不应当被标记为 explicit, 因为它们并不执行类型转换
3. 不能以一个参数进行调用的构造函数不应当加上 explicit
4. 接受一个 std::initializer_list 作为参数的构造函数也应当省略 explicit, 以便支持拷贝初始化 (例如 MyType m = {1, 2};)


// !! 3.3. 可拷贝类型和可移动类型

// !! 总述

如果你的类型需要, 就让它们支持拷贝、移动. 否则, 就把隐式产生的拷贝和移动函数禁用


// !! 定义

可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值, 或在赋值时被赋予相同类型的另一对象的值, 同时不改变源对象的值
对于用户定义的类型, 拷贝操作一般通过~~拷贝构造函数与拷贝赋值~~操作符定义. string 类型就是一个可拷贝类型的例子


可移动类型允许对象在初始化时得到来自相同类型的临时对象的值, 或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的)
对于用户定义的类型, 移动操作一般是通过~~移动构造函数和移动赋值~~操作符实现的


拷贝、移动构造函数在某些情况下会被编译器隐式调用. 例如, 通过传值的方式传递对象

// !! 优点

1. 可移动及可拷贝类型的对象可以通过传值的方式进行传递或者返回, 这使得 API 更简单, 更安全也更通用. 与传指针和引用不同, 这样的传递不会造成所有权, 
生命周期, 可变性等方面的混乱

2. 移动操作允许隐式且高效地将源数据转移出右值对象. 这有时能让代码风格更加清晰.


// !! 缺点

1. 许多类型都不需要拷贝, 为它们提供拷贝操作会让人迷惑, 也显得荒谬而不合理
2. 拷贝构造函数是隐式调用的, 也就是说, 这些调用很容易被忽略


// !! 结论

如果需要就让你的类型可拷贝、可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝。
如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然。如果让类型可移动, 同时移动操作的效率高于拷贝操作, 那么就把移动的
两个操作 (移动构造函数和赋值操作) 也给出定义。如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动
的两个操作。

如果定义了拷贝、移动操作, 则要保证这些操作的默认实现是正确的。记得时刻检查默认操作的正确性, 并且在文档中说明类是可拷贝的且或可移动的：

class Foo 
{
 public:
  Foo(Foo&& other) : field_(other.field) {}
  // 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符.

 private:
  Field field_;
};

由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操作或者拷贝、移动构造函数。如果你的基类需要可复制属性, 请提供一个 
public virtual Clone() 和一个 protected 的拷贝构造函数以供派生类实现。

如果你的类不需要拷贝、移动操作, 请显式地通过在 public 域中使用 = delete 或其他手段禁用之：

// MyClass is neither copyable nor movable
MyClass(const MyClass&) = delete;
MyClass& operator=(const MyClass&) = delete;

// !! 3.4. 结构体 VS 类

// !! 总述

仅当只有数据成员时使用 struct, 其它一概使用 class

// !! 说明

在 C++ 中 struct 和 class 关键字几乎含义一样。我们为这两个关键字添加我们自己的语义理解, 以便为定义的数据类型选择合适的关键字

struct 用来定义包含数据的被动式对象, 也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能. 并且存取功能是通过直接访问位域, 
而非函数调用。如果需要更多的函数功能, class 更适合. 如果拿不准, 就用 class。

// !! 3.5. 继承

使用组合常常比使用继承更合理， 如果使用继承的话, 定义为 public 继承。

// !! 定义

当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继承主要用于两种场合: 实现继承, 子类继承父类的实现代码; 
接口继承, 子类仅继承父类的方法名称

// !! 优点

实现继承通过原封不动的复用基类代码减少了代码量。由于继承是在编译时声明,程序员和编译器都可以理解相应操作并发现错误。从编程角度而言, 
接口继承是用来强制类输出特定的 API。在类没有实现 API 中某个必须的方法时, 编译器同样会发现并报告错误。

// !! 缺点

对于实现继承, 由于子类的实现代码散布在父类和子类间之间, 要理解其实现变得更加困难。子类不能重写父类的非虚函数, 当然也就不能修改其实现。
基类也可能定义了一些数据成员, 因此还必须区分基类的实际布局。


// !! 结论

1. 所有继承必须是 public 的。如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式
2. 不要过度使用实现继承， 组合常常更合适一些
3. 必要的话, 析构函数声明为 virtual。如果你的类有虚函数, 则析构函数也应该为虚函数
4. 对于可能被子类访问的成员函数,不要过度使用 protected 关键字。注意, 数据成员都必须是 私有的
5. 对于重载的虚函数或虚析构函数, 使用 override 关键字显式地进行标记


// !! 3.6. 接口

// !! 总述

接口是指满足特定条件的类, 这些类以 Interface 为后缀 (不强制)

// !! 定义

当一个类满足以下要求时, 称之为纯接口:
1. 只有纯虚函数 (”=0”) 和静态函数 (除了下文提到的析构函数)
2. 没有非静态数据成员
3. 没有定义任何构造函数。如果有, 也不能带有参数, 并且必须为 protected
4. 如果它是一个子类, 也只能从满足上述条件并以 Interface 为后缀的类继承


接口类不能被直接实例化, 因为它声明了纯虚函数。为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数


// !! 3.8. 运算符重载

// !! 总述

除少数特定环境外, 不要重载运算符。 也不要创建用户定义字面量

// !! 定义

C++ 允许用户通过使用 operator 关键字对内建运算符进行重载定义 ,只要其中一个参数是用户定义的类型

// !! 优点

重载运算符可以让代码更简洁易懂, 也使得用户定义的类型和内建类型拥有相似的行为。重载运算符对于某些运算来说是符合语言习惯的名称 (例如 ==, <, =, <<), 
遵循这些语言约定可以让用户定义的类型更易读, 也能更好地和需要这些重载运算符的函数库进行交互操作。


// !! 缺点

1. 要提供正确、一致, 不出现异常行为的操作符运算需要花费不少精力, 而且如果达不到这些要求的话, 会导致令人迷惑的 Bug
2. 过度使用运算符会带来难以理解的代码, 尤其是在重载的操作符的语义与通常的约定不符合时
3. 函数重载有多少弊端, 运算符重载就至少有多少
4. 运算符重载会混淆视听, 让你误以为一些耗时的操作和操作内建类型一样轻巧


// !! 结论

只有在意义明显, 不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符. 例如, | 要作为位或或逻辑或来使用, 
而不是作为 shell 中的管道。

// !! 3.9. 存取控制

// !! 总述

将 所有 数据成员声明为 private, 除非是 static const 类型成员。


// !! 3.10. 声明顺序

// !! 总述

将相似的声明放在一起, 将 public 部分放在最前


// !! 总结

1. 不在构造函数中做太多逻辑相关的初始化
2. 编译器提供的默认构造函数不会对变量进行初始化,如果定义了其他构造函数, 编译器不再提供,需要编码者自行提供默认构造函数
3. 为避免隐式转换, 需将单参数构造函数声明为 explicit
4. 为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 private 且无需实现
5. 仅在作为数据集合时使用 struct
6. 组合 > 实现继承 > 接口继承 > 私有继承, 子类重载的虚函数也要声明 virtual 关键字, 虽然编译器允许不这样做
7. 避免使用多重继承, 使用时, 除一个基类含有实现外, 其他基类均为纯接口
8. 为降低复杂性, 尽量不重载操作符, 模板, 标准类中使用时提供文档说明
9. 存取函数一般内联在头文件中
10. 声明次序: public -> protected -> private
11. 函数体尽量短小, 紧凑, 功能单一


int main(int argc, char **argv)
{

}