#include<iostream>


using namespace std;

// !! 4. 函数

// !!4.1. 参数顺序

// !! 总述

函数的参数顺序为: 输入参数在先, 后跟输出参数


// !! 4.2. 编写简短函数

我们倾向于编写简短, 凝练的函数

// !! 说明

我们承认长函数有时是合理的, 因此并不硬性限制函数的长度。如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割。
即使一个长函数现在工作的非常好, 一旦有人对其修改,有可能出现新的问题,甚至导致难以发现的 bug。使函数尽量简短, 以便于他人阅读和修改代码

在处理代码时,你可能会发现复杂的长函数。不要害怕修改现有代码:如果证实这些代码使用、调试起来很困难, 或者你只需要使用其中的一小段代码, 
考虑将其分割为更加简短并易于管理的若干函数。

// !! 4.3. 引用参数

// !! 总述

所有按引用传递的参数必须加上 const

// !! 定义

在 C 语言中, 如果函数需要修改变量的值,参数必须为指针,如 int foo(int *pval)。在 C++ 中,函数还可以声明为引用参数:int foo(int &val)


// !! 优点

定义引用参数可以防止出现 (*pval)++ 这样丑陋的代码


// !! 结论

函数参数列表中, 所有引用参数都必须是 const

void Foo(const string &in, string *out);

事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 const 引用, 输出参数为指针。输入参数可以是 const 指针, 
但决不能是非 const 的引用参数。

总而言之, 大多时候输入形参往往是 const T&


// !! 4.4. 函数重载

若要使用函数重载,则必须能让读者一看调用点就胸有成竹,而不用花心思猜测调用的重载函数到底是哪一种。这一规则也适用于构造函数

// !! 定义

你可以编写一个参数类型为 const string& 的函数, 然后用另一个参数类型为 const char* 的函数对其进行重载

class MyClass {
    public:
    void Analyze(const string &text);
    void Analyze(const char *text, size_t textlen);
};

// !! 优点

通过重载参数不同的同名函数,可以令代码更加直观。模板化代码需要重载, 这同时也能为使用者带来便利

// !! 缺点

如果函数单靠不同的参数类型而重载, 读者就得十分熟悉 C++ 五花八门的匹配规则, 以了解匹配过程具体到底如何。

// !! 结论

如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用 AppendString() 和 AppendInt() 等, 而不是一口气
重载多个 Append()

// !! 4.5. 缺省参数

只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致。 缺省参数与 函数重载 遵循同样的规则。 一般情况下建议使用函数重载, 
尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下。

// !! 优点

有些函数一般情况下使用默认参数, 但有时需要又使用非默认的参数。缺省参数为这样的情形提供了便利,使程序员不需要为了极少的例外情况编写大量的函数

// !! 缺点

1. 缺省参数实际上是函数重载语义的另一种实现方式, 因此所有 不应当使用函数重载的理由 也都适用于缺省参数
2. 虚函数调用的缺省参数取决于目标对象的静态类型, 此时无法保证给定函数的所有重载声明的都是同样的缺省参数
3. 缺省参数是在每个调用点都要进行重新求值的, 这会造成生成的代码迅速膨胀


// !! 4.6. 函数返回类型后置语法

只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法

// !! 定义

C++ 现在允许两种不同的函数声明方式. 以往的写法是将返回类型置于函数名之前. 例如:

int foo(int x);

C++11 引入了这一新的形式. 现在可以在函数名前使用 auto 关键字, 在参数列表之后后置返回类型。例如:

auto foo(int x) -> int;

后置返回类型为函数作用域。

// !! 优点

后置返回类型是显式地指定 Lambda 表达式 的返回值的唯一方式。某些情况下, 编译器可以自动推导出 Lambda 表达式的返回类型, 
但并不是在所有的情况下都能实现，即使编译器能够自动推导,显式地指定返回类型也能让读者更明了

int main(int argc, char **argv)
{

}