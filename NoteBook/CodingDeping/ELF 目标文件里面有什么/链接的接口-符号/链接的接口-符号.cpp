
// !! 链接的接口——符号

链接的本质就是'把多个不同的目标文件之间相互“粘”到一起'，就像是拼图一样，你要把每一块 “目标文件” 拼接成一个完整的“程序”。

比如目标文件 B 要用到了目标文件 A 中的函数"foo"，那么我们就称'目标文件A定义 （Define） 了函数"foo"'，'目标文件 B 引用 （Reference）'
了目标文件 A 中的函数 "foo", 这两个概念也同样适用于变量。

// !! 每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。

在链接中, 目标文件之间相互拼合实际上就是'目标文件之间地址的引用'，即对函数和变量的地址的引用。我们将函数和变量统称为'符号(Symbol)'，
函数名或变量名就是'符号名(Symbol Name)'。

链接过程中很关键的一部分就是'符号的管理'，每一个目标文件都会有一个相应的'符号表（Symbol Table）'，这个表里面记录了目标文件中所用到的
所有符号。每个定义的符号有一个对应的值，叫做'符号值（Symbol Value），对于变量和函数来说，符号值就是它们的地址'。

我们将符号表中所有的符号进行分类，它们有可能是下面这些类型中的一种:

1. 定义在本目标文件的全局符号，可以被其他目标文件引用

2. 在本目标文件中引用的全局符号，却没有定义在本目标文件， 这一般叫做'外部符号（External Symbol）'

3. 段名，这种符号往往由编译器产生，它的值就是该段的起始地址。比如 SimpleSection.o 里面的".text"、".data"等

4. 局部符号, 这类符号只在编译单元内部可见

5. 行号信息, 即目标文件指令与源代码中代码行的对应关系，它是可选的

对于我们来说，'最值得关注的就是全局符号'，即上面分类中的第一类和第二类。因为'链接过程只关心全局符号的相互"粘合"'， 局部符号、段名、行号等都是
次要的，它们对于其他目标文件来说是"不可见"的，在链接过程中也是无关紧要的。

// !! 使用 nm 查看目标文件中的符号

// SimpleSection.c
int printf(const char *format, ...);

int global_init_var = 84;
int global_uninit_var;

void func1(int i)
{
    printf("%d\n", i);
}

int main()
{
    static int static_var = 85;
    static int static_var2;

    int a = 1;
    int b;

    func1(static_var+static_var2+a+b);

    return a;
    
}

 » nm SimpleSection.o                                   
0000000000000000 T func1
0000000000000000 D global_init_var
                 U _GLOBAL_OFFSET_TABLE_
0000000000000004 C global_uninit_var
0000000000000028 T main
                 U printf
0000000000000004 d static_var.1919
0000000000000000 b static_var2.1920