
// !! 符号修饰和函数签名

约在 20 世纪 70 年代以前， 编译器编译源代码产生目标文件时，符号名(Symbol name)与相应的变量和函数的名字是一样的。比如一个汇编源代码里面包含了
一个函数 foo，那么汇编器将它编译成目标文件以后，foo 在目标文件中的相对应的符号名也是 foo。

当后来 UNIX 平台和 C 语言发明时，'已经存在了相当多的使用汇编编写的库和目标文件'。这样就产生了一个问题，那就是如果一个 C 程序要使用这些库的话，
C 语言中不可以使用这些库中定义的函数和变量的名字作为符号名，否则将会跟现有的目标文件冲突

比如有个用汇编编写的库中定义了一个函数叫做 main， 那么我们在 C 语言里面就不可以再定义一个 main 函数或变量了。

为了防止类似的符号名冲突，UNIX 下的 C 语言就规定，'C 语言源代码文件中的所有全局的变量和函数经过编译以后， 相对应的符号名前加上下划线"_"'。

这种简单而原始的方法的确能够暂时减少多种语言目标文件之间的符号冲突的概率, 但还是没有从根本上解决符号冲突的问题。比如同一种语言编写的目标文件还有可能会产
生符号冲突，当程序很大时，不同的模块由多个部门（个人）开发， 它们之间的命名规范如果不严格，则有可能导致冲突。

于是像 C++ 这样的后来设计的语言开始考虑到了这个问题, '增加了名称空间（Namespace）的方法来解决多模块的符号冲突问题'。


// !! C++ 符号修饰

众所周知, 强大而又复杂的 C++ 拥有类、继承、虚机制、重载、名称空间等这些特性， 它们使得符号管理更为复杂。如: 两个相同名字的函数 func(int) 和 
func(double)，尽管函数名相同，但是参数列表不同，这是 C++ 里面函数重载的最简单的一种情况，那么编译器和链接器在链接过程中如何区分这两个函数呢? 

1. C++ 允许多个不同参数类型的函数拥有一样的名字，即所谓的函数重载

2. C++ 在语言级别支持名称空间（namespace），'允许在不同的名称空间有多个同样名字的符号'

int func(int); 

float func(float);

class C
{
    int func(int);
    class C2
    {
        int func(int);
    };
};

namespace N
{
    int func(int);
    class C
    {
        int func(int);
    };
}

这段代码中有 6 个同名函数叫 func，只不过它们的返回类型和参数及所在的名称空间不同。

// !! 我们引入一个术语叫做函数签名 （Function Signature），函数签名包含了一个函数的信息，包括函数名、它的参数类型、它所在的类和名称空间及其他信息。

函数签名用于识别不同的函数，就像签名用于识别不同的人一样，函数的名字只是函数签名的一部分。

'C++ 的源代码编译后的目标文件中所使用的符号名是相应的函数和变量的修饰后名称'。C++ 编译器和链接器都使用符号来识别和处理函数和变量，所以对于不同函数签名
的函数，即使函数名相同，编译器和链接器都认为它们是不同的函数。

GCC 的基本 C++ 名称修饰方法如下:
1. 所有的符号都以"_Z"开头
2. 对于嵌套的名字（在名称空间或在类里面的），后面紧跟"N"，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，再以"E"结尾。
   比如N::C::func经过名称修饰以后就是_ZN1N1C4funcE。对于一个函数来说，它的参数列表紧跟在"E"后面，对于int类型来说，就是字母"i"。所以整个
   N::C::func(int) 函数签名经过修饰为_ZN1N1C4funcEi。

签名和名称修饰机制不光被使用到函数上， C++ 中的全局变量和静态变量也有同样的机制。

对于全局变量来说，它跟函数一样都是一个全局可见的名称，它也遵循上面的名称修饰机制，比如一个名称空间 foo 中的全局变量 bar，它修饰后的名字
为：_ZN3foo3barE

// !! 由于不同的编译器采用不同的名字修饰方法， 必然会导致由不同编译器编译产生的目标文件无法正常相互链接，这是导致不同编译器之间不能互操作的主要原因之一