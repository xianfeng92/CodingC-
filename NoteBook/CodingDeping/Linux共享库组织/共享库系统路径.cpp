// !! 共享库系统路径

目前大多数包括 Linux 在内的开源操作系统都遵守一个叫做 FHS(File Hierarchy Standard)的标准, '这个标准规定了一个系统中的系统文件应该如何存放，包括各个目录的结
构、组织和作用'，这有利于促进各个开源操作系统之间的兼容性。

FHS 规定，'一个系统中主要有两个存放共享库的位置'，它们分别为:

1. /lib 这个位置'主要存放系统最关键和基础的共享库'，比如动态链接器、C 语言运行库、数学库等，这些库主要是那些 /bin 和 /sbin 下的程序所需要用到的库，还有系统启动时
   需要的库

2. /usr/lib 这个目录下主要保存的是一些非系统运行时所需要的关键性的共享库，'主要是一些开发时用到的共享库'，这些共享库一般不会被用户的程序或 shell 脚本直接用到。
   这个目录下面还包含了开发时可能会用到的静态库、目标文件等

3. /usr/local/lib 这个目录用来放置一些跟操作系统本身并不十分相关的库，'主要是一些第三方的应用程序的库'。GNU 的标准推荐第三方的程序应该默认将库安装到 
   /usr/local/lib 下


/usr/local/lib » ls                                                                                                                
python2.7  python3.8


// !! 所以总体来看, /lib 和 /usr/lib 是一些很常用的、成熟的，一般是系统本身所需要的库; 而 /usr/local/lib 是非系统所需的第三方程序的共享库


// !! 环境变量

Linux 系统提供了很多方法来改变动态链接器装载共享库路径的方法，通过使用这些方法，我们可以满足一些特殊的需求，比如共享库的调试和测试、应用程序级别的虚拟等。

改变共享库查找路径最简单的方法是使用 LD_LIBRARY_PATH 环境变量， 这个方法可以临时改变某个应用程序的共享库查找路径， 而不会影响系统中的其它程序。在 Linux 系统中，
LD_LIBRARY_PATH 是一个由若干个路径组成的环境变量，每个路径之间由冒号分割。 默认情况下， LD_LIBRARY_PATH 为空。如果我们为某个进程设置了 LD_LIBRARY_PATH，那么
进程在启动时，动态链接器在查找共享库时，会首先查找由 LD_LIBRARY_PATH 指定的目录。


动态链接器会按照下列顺序依次装载或查找共享对象(目标文件):

1. 由环境变量LD_LIBRARY_PATH指定的路径

2. 由路径缓存文件/etc/ld.so.cache指定的路径

3. 默认共享库目录，先 /usr/lib，然后 /lib


// !! LD_PRELOAD

LD_PRELOAD 这个文件中我们可以指定预先装载的一些共享库或目标文件。在 LD_PRELOAD 里面指定的文件会在动态链接器按照固定规则搜索共享库之前装载，它比 LD_LIBRARY_PATH
里面所指定的目录中的共享库还要优先。

无论程序是否依赖于它们，LD_PRELOAD 里面指定的共享库或目标文件都会被装载。'由于全局符号介入这个机制的存在'，LD_PRELOAD 里面指定的共享库或目标文件中的全局符号就会
覆盖后面加载的同名全局符号，这使得我们可以很方便地做到改写标准 C 库中的某个或某几个函数而不影响其它函数，对于程序的调试或测试非常有用。


与 LD_LIBRARY_PATH 一样，正常情况下应该尽量避免使用 LD_PRELOAD。系统配置文件中有一个文件是 /etc/ld.so.preload，它的作用于 LD_PRELOAD 一样。这个文件里面记
录的共享库或目标文件的效果跟 LD_PRELOAD 里面指定的一样，也会被提前装载。


// !! LD_DEBUG

LD_DEBUG 这个变量可以打开动态链接器的调试功能，当我们设置这个变量时, 动态链接器会在运行时打印出各种有用的信息，对于我们开发和调试共享库有很大的帮助。

