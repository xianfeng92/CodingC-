// !! fread 实现

Windows 下，fread 利用系统 API: ReadFile() 来实现对文件的读取的，但是从 fread 到 ReadFile 之间发生了什么？ IO 是 CRT 最复杂的部分之一。

先来看 fread 函数声明:

size_t fread(void *buffer, size_t elementSize, size_t count, FILE *stream);

size_t: unsigned int 表示数据大小的类型。

'fread 功能是尝试从文件流 stream 读取 count 个大小为 elementSize byte 的数据，存储在 buffer 里，返回实际读取的字节数'。

ReadFile 函数声明:

bool ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);

1. hFile:要读取的文件句柄，对应 fread 里面的 stream 参数
2. lpBuffer:读取文件内容的缓冲区，对应 fread 的 buffer 参数
3. nNumberOfBytesToRead:要读取多少个字节，与之对应的是两个参数的乘积，即 elementSize * count
4. lpNumberOfBytesRead:指向 DWORD 类型的指针，用于返回读取了多少个字节
5. lpOverlapped:没用的参数，可以忽略

// !! 缓冲

缓冲最常见于 I/O 系统中, 设想一下，当希望向屏幕输出数据时，由于程序调用的逻辑关系，可能多次调用 printf 函数，并且每次写入的数据只有几个字符，如果每次
写入都要进行一次系统调用，让内核向屏幕写数据，就明显过于低效，因为系统调用的开销是很大的，它要进行上下文切换、内核参数检查等。如果频繁进行系统调用，将会
严重影响程序和系统的性能。

一个显而易见的可行方案是将对控制台连续多次的写入放在一个数组里，等到数组被填满之后再一次性完成系统调用写入，实际上这就是缓冲的最基本思想。当读文件的时候，
缓冲同样存在，我们可以在 CRT 中为文件建立一个缓冲，当要读取数据的时候，首先看看文件的缓冲里有没有数据，如果有就直接从缓冲中取。如果缓冲为空，那么 CRT 
就通过操作系统一次性读取一块较大的内容填充缓冲。这样，如果每次读取文件都是一些尺寸很小的数据，那么这些读取操作大多数都直接从缓冲中获取，可以避免大量的实
际文件访问。

除了取文件有缓冲以为，写文件也存在着同样的情况，而且写文件比读文件更加复杂，因为我们调用 fwrite 向文件写入一段数据时，此时这些数据不一定被真正写入到
文件，而是有可能还存在于文件的写缓冲里面，那么此时如果系统崩溃或者进程意外退出时，有可能导致数据丢失，于是 'CRT 提供了一系列与缓冲相关的操作用来弥补缓冲
所带来的数据丢失'问题。


Linux 系统为进程预定义了 3 个流: 标准输入、标准输出、标准错误。进程启动时，会自动打开。3 个流分别对应文件描述符（int）：STDIN_FILENO、STDOUT_FILENO、
STDERR_FILENO; 对应文件指针（FILE *）：stdin、stdout、stderr；

'标准 I/O 库为标准输入、标准输出流提供了缓存'。标准错误默认没有缓冲。'提供缓冲的目的是尽可能减少 read、write 调用次数'。

// !! 标准 I/O 和文件 I/O

文件 I/O: 不带缓冲的I/O（unbuffered I/O）。不带缓冲是指函数实现时不带库缓冲区，从而每个读、写操作，都直接调用系统调用。

标准I/O：ANSI C 建立的标准 I/O 模型，API 包含在 <stdio.h>中，不依赖内核，可移植性强。'标准 I/O 库实现的缓存，统称简称库缓冲'。

3 种标准 I/O 缓冲:

1. 全缓冲----> 填满库缓冲后，才调用 write 将库缓冲内容写入内核高速缓存，由内核写入流. 冲洗（flush） 库缓冲的写操作。通常全缓冲写满以后，才会触发
   write 系统调用，而冲洗操作会主动触发 write，将所有用户控件输入 write 进'内核高速缓存', 对应系统调用fflush()

2. 行缓冲 ----> 当输入和输出遇到换行符（CRLF for Win, LF for Unix）时，标准 I/O 库执行实际的 I/O 操作（read/write）. 对行缓冲有2个限制：1）标
   准 I/O 库用来收集每行缓冲区长度固定，只要填满缓冲区，即使每写换行符，也进行 I/O 操作; 2） 任何时候，只要通过标准 I/O 库从一个不带缓冲的流，或者一
   个行缓冲的流得到数据，那么就会 flush 库的所有行缓冲输出流.


3. 不带缓冲 ----> 指的是标准I/O库不对字符进行行缓冲存储。'标准 I/O 输入、输出是默认行缓冲'

PS： 标准错误流默认不带库缓冲


ISO C 要求下列缓冲特征：

1. 当前仅当标准输入、标准输出不指向交互式设备时，它们才是全缓冲的

2. 标准错误绝不会是全缓冲的


很多系统默认实现：

1. 标准错误是不带缓冲的

2. 若是指向终端设备的流，则是行缓冲的; 否则，是全缓冲的


// !! C 标准库提供与缓冲的几个基本函数


// !! 冲洗流（库缓冲）

'fflush 函数可以强制冲洗一个流，使得库缓冲内容传送至内核（高速缓存）'。如果 stream 为 NULL，将导致所有输出流被冲洗。

#include <stdio.h>

int fflush(FILE *stream);

PS：关于写磁盘，可以参考以下几点，不过要谨慎使用，可能导致效率很低。

1. O_DIRECT选项

   如果想绕过内核高速缓存，直接访问磁盘而不使用内核缓存，可以在 open 文件的时候，加上选项 O_DIRECT。对 read、write 都有效。


2. O_SYNC 选项

   如果想把内核缓存数据直接同步到磁盘，可以 open 文件的时候，加上 O_SYNC 选项。O_SYNC 只对 write 有效。使用 O_SYNC 务必大块数据一次写，通常是
   512B至4KB/次以上，避免频繁同步磁盘，导致效率极其低下。

3. 缓存同步
   尽量保证缓存数据和写到磁盘的数据一致，有以下几种方法：

   sync() 将所有修改过的块缓存提交到队列，然后返回，并不等待实际写磁盘操作结束，并不能保证数据写入磁盘

   fsync() 将 fd 对应的文件的块缓存立即写入磁盘， 并等待写磁盘操作结束返回

// !! 设置库缓冲

1. setvbuf 精确说明所需要的缓存类型，用 mode 参数实现,_IOFBF 全缓冲; _IOLBF 行缓冲; _IONBF 不带缓冲

2. setbuf
   setbuf 使能、禁用长度为 BUFSIZ 的用户缓冲区 buf。（BUFSIZ 定义在<stdio.h>头文件中）。buf 为 NULL，代表关闭缓冲；buf 指向一个长度为 BUFSIZ 
   的缓冲区，代表该流与全缓冲关联; 如果该流与一个终端设备相关，那么有些系统可以将其设置为行缓冲










