
// !! 编译器做了什么

从最直观的角度来讲，编译器就是将高级语言翻译成机器语言的一个工具。

'回到编译器本身的职责上，编译过程一般可以分为 6 步'

1. 扫描
2. 语法分析
3. 语义分析
4. 源代码优化
5. 代码生成
6. 目标代码优化


// ! 词法分析

首先源代码程序被输入到'扫描器（Scanner）'，扫描器的任务很简单，它只是简单地进行词法分析，运用一种类似于'有限状态机（Finite State Machine）' 的算法可以
很轻松地'将源代码的字符序列分割成一系列的记号（Token）'。

词法分析产生的记号一般可以分为如下几类：关键字、标识符、字面量（包括数字、字符串等）和特殊符号（如加号、等号）。在识别记号的同时，扫描器也完成了其他工作。
比如将标识符存放到符号表，将数字、字符串常量存放到文字表等，以备后面的步骤使用。

'有一个叫 lex 的程序可以实现词法扫描， 它会按照用户之前描述好的词法规则将输入的字符串分割成一个个的 Token'。


// !! 语法分析

接下来'语法分析器（Grammar Parser）' 将对由扫描器产生的记号 (Token) 进行语法分析，从而产生'语法树（Syntax Tree）'。整个分析过程采用了上下文无关语
法（Context-free Grammar） 的分析手段。

简单来说，由语法分析器生成的语法树就是以 表达式（Expression） 为节点的树。我们知道，C 语言的一个语句是一个表达式，而复杂的语句是很多表达式的组合。

语法分析也有一个现成的工具叫做 Yacc（Yet Another Compiler Compiler），'它也可以根据用户之前给定的语法规则对输入的 Token 进行解析',从而构建一颗
语法书（Syntax Tree）


// !! 语义分析

语义分析由'语义分析器 （Semantic Analyzer）' 来完成, 语法分析仅是完成了对表达式语法层面的分析，但是它并不了解这个语句是否真正有意义。
比如 C 语言里面两个指针做乘法运算是没有意义的，但是这个语句在语法上是合法的； 比如同样一个指针和一个浮点数做乘法运算是否合法等。'编译器所能分析的语义是 
静态语义（Static Semantic）' ，所谓静态语义是指在'编译期可以确定的语义'，与之对应的动态语义（Dynamic Semantic） 就是只有在运行期才能确定的语义。

'静态语义通常包括声明和类型的匹配、类型的转换'。比如当一个浮点型的表达式赋值给一个整型的表达式时，其中隐含了一个浮点型到整型转换的过程，
语义分析过程中需要完成这个步骤。比如将一个浮点型赋值给一个指针的时候，语义分析程序会发现这个类型不匹配，编译器就会报错。

'经过语义分析阶段以后，整个语法树的表达式都被标识了类型'，如果有些类型需要做隐式转换，语义分析程序会在语法树中插入相应的转换节点。

// !! 中间语言的生成

现代的编译器有着很多层次的优化，往往在源代码级别会有一个优化过程。我们这里所描述的'源码级优化器（Source Code Optimizer）' 在不同的编译器中可能会有不同
的语义或有一些其他的差异。

源代码级优化器会在源代码级别进行优化，比如 （2 + 6） 这个表达式可以被优化成 8。

// !! 目标代码生成与优化

代码生成器（Code Generator） 中间代码转换成目标机器代码，这个过程十分依赖于目标机器，因为不同机器有着不同的字长、寄存器、整数数据类型和浮点
数数据类型等。最后目标代码优化器（Target Code Optimizer）对目标代码进行优化，比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。


