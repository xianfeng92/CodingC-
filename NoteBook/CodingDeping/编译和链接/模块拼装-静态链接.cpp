
// !! 模块拼装——静态链接

程序设计的模块化是人们一直在追求的目标, 因为当一个系统十分复杂的时候， 我们不得不将一个复杂的系统逐步分割成小的系统以达到各个突破的目的。

'一个复杂的软件也如此，人们把每个源代码模块独立地编译， 然后按照需要将它们 “组装” 起来， 这个组装模块的过程就是 链接（Linking）'。

链接的主要内容就是'把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接'。


从原理上来讲，链接器的工作就是把一些指令对其它符号地址的引用加以修正。 链接过程主要包括了地址和空间分配(Address and Storage Allocation)、
符号决议(Symbol Resolution)和重定位(Relocation)等这些步骤。

// !! 符号决议(Symbol Resolution)

符号决议有时候也被叫做符号绑定(Symbol Binding)、名称绑定(Name Binding)、名称决议(Name Resolution)，甚至还有叫做地址绑定(Address Binding)、
指令绑定(Instruction Binding)。大体上它们的意思都一样，但从细节角度来区分，它们之间还是存在一定区别的，比如'”决议”更倾向于静态链接，而”绑定”更倾向
于动态链接'，即它们所使用的范围不一样。


每个模块的源代码文件(如.c)经过编译器编译成目标文件(Object File，一般扩展名为.o), '目标文件和库(Library)一起链接形成最终可执行文件'。而最常见的库就是
运行时库(Runtime Library)，它是支持程序运行的基本函数的集合。'库其实是一组目标文件的包，就是一些最常用的代码编译成目标文件后打包存放'。

现代的编译和链接过程也并非想象中的那么复杂。比如我们在程序模块 main.c 中使用另外一个模块 func.c 中的函数 foo()。我们在 main.c 模块中每一处调用 foo 的时候
都必须确切知道 foo 这个函数的地址，但是由于每个模块都是单独编译的，在编译器编译 main.c 的时候它并不知道 foo 函数的地址，所以它暂时把这些调用 foo 的指令的目
标地址搁置，等待最后链接的时候由链接器去将这些指令的目标地址修正。如果没有链接器，须要我们手工把每个调用 foo 的指令进行修正，则填入正确的 foo 函数地址。
当 func.c 模块被重新编译，foo 函数的地址有可能改变时，那么我们在 main.c 中所有使用到foo的地址的指令将要全部重新调整。

使用链接器，你可以直接引用其它模块的函数和全局变量而无需知道它们的地址，因为链接器在链接的时候，会根据你所引用的符号 foo，自动去相应的 func.o 模块查找 foo 
的地址，然后将 main.c 模块中所有引用到foo的指令重新修正，让它们的目标地址为真正的 foo 函数的地址。这就是静态链接的最基本的过程和作用。'这个地址
修正的过程也被叫做重定位(Relocation)'， 每个要被修正的地方叫一个重定位入口(Relocation Entry)。重定位所做的就是给程序中每个这样的绝对地址引用的位置
”打补丁”，使它们指向正确的地址。

















