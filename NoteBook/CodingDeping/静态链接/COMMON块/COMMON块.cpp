
// !! COMMON 块

弱符号机制允许同一个符号的定义存在于多个目标文件中。所以可能会导致一个问题:如果一个弱符号定义在多个目标文件中，而它们的类型也不同，怎么办？

目前的链接器本身并不支持符号的类型， 即变量类型对于链接器来说是透明的，它只知道一个符号的名字，并不知道类型是否一致。

'多个符号（同名）定义类型不一致的几种情况':

1. 两个或两个以上强符号类型不一致【非法，报错】

2. 有一个强符号，其他都是弱符号，出现类型不一致

3. 两个或两个以上弱符号类型不一致

'编译器将未初始化的全局变量定义作为弱符号处理'

// !! COMMON 类型的链接规则: 原则上讲最终链接后的输出文件中, 弱符号的大小以输入文件中最大（所占空间）的那个为准

如果有一个符号为强符号， 那么最终输出结果所占空间大小与强符号相同。【如果链接过程中，有弱符号大于强符号，编译器会报警告】

'未初始化的全局变量最终还是被放在 BSS 段的'

一旦有一个未初始化的全局变量不是以 COMMON 块的形式存在， 那么它就相当于一个强符号


// !! 在目标文件中，编译器为什么不直接把'未初始化的全局变量'也当作'未初始化的局部静态变量'一样处理，为它在 BSS 段分配空间，而是将其标记为
// !!  COMMON 类型呢？

主要是因为当编译器将一个编译单元编译成目标文件时，如果该编译单元包含了弱符号，那么该弱符号最终所占空间的大小是未知的，因为有可能在其他编译单元中该符
号所占的空间比本编译单元该符号所占的空间要大。所以'编译器此时无法为该弱符号在 BSS 段分配空间，因为所需要空间的大小未知'。但是'链接器可以确定弱符号的
大小'，因为链接了所有的目标文件，弱符号的大小也确定了，所以它可以在最终输出文件的 BSS 段为其分配空间。所以总体来看未初始化全局变量最终还是被放在BSS段











