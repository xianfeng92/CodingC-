
// !! C++ 相关问题

C++ 的一些语言特性使之必须由编译器和链接器共同支持才能完成，最主要的两方面： 1. C++ 重复代码的消除； 2. 全局的析构和构造


// !! 重复代码消除

C++ 编译器在很多时候会产生重复的代码。比如模板、内联函数和虚函数表都有可能在不同的编译单元里生成相同的代码。例如，在一个单元里模板被实例化，它并不
知道在其他的单元是否有相同的实例化。

一个比较好的做法是'将每个模板的实例代码都单独地存放在一个段里， 每个段只包含一个模板实例'。比如有个模板函数是add<T>()，某个编译单元 以 int 和 float 
类型实例化了该模板函数，那么该编译单元的目标文件中就包含了两个该模板实例的段。这样，当别的编译单元也以 int 或 float 类型实例化该模板函数后，也会生成相同
的名字, 这样链接器在最终链接的时候可以区分这些相同的模板实例段，合并入最后的代码段。


'函数级链接'

函数级别链接, 就是把每一个函数都单独地放到一个段里，链接器检测到用到了哪个函数就链接相应的段，没有用到的不会被链接到最终的文件里，与前面的静态库链接差不多
其目的也是为了减小最终的文件大小


// !! 全局的构造和析构

一般的 C/C++ 程序是从 main 开始执行的，随着 main 函数的结束而结束。然而，在 main 函数之前，为了程序能够顺利通过，要先初始化进程执行环境，比如堆分配初
始化，线程子系统等。

Linux 系统下一般程序的入口是"_start"，这个函数是 Linux 系统库的一部分,在这个 "_start" 函数中进行进程初始化工作，然后在其中调用 main 函数，进入到用
户定义的主程序。在 main 函数执行完成以后， 返回到初始化部分， 它进行一些清理工作，然后结束进程。


程序的一些操作必须在 mai n函数之前执行，还有一些必须在 main 函数之后执行，因此 ELF 文件中定义了两种特殊的段:

1. .init 该段里面保存的是可执行指令，它构成了进程的初始化代码

2. .fini 该段保存着进程终止代码指令

这两个段 .init 和 .fini 的存在有着特别的目的，如果一个函数放在 .init 段，在 main 函数执行前系统就会执行它。同理，假如一个函数放到 .fini 段，在 main
函数返回后该函数会被执行。


// !! ABI（Application Binary Interface）

API（Application Programming Interface） 是'源代码级别的接口'，比如我们说的 Linux 的 POSIX 是一个 API 标准； 而 ABI 是二进制级别的接口，
ABI 的兼容程度比 API 更加严格，比如我们可以说 C++ 的对象内存分布（Object Memory Layout）是 C++ ABI 的一部分。

'ABI 的重用即二进制的指令和数据的重用'

与 ABI 相关的东西有很多，具体包括：

1. 符号修饰标准

2. 变量内存布局

3. 函数调用方式等跟可执行文件二进制兼容性相关的内容。

同时，机器的硬件平台、编程语言、编译器、链接器、操作系统等都会影响到 ABI，所以，ABI 的标准化一直是一个大问题。不同目标文件的 ABI 不同的话，就不能相互链
接起来。

// !! BFD 库

BFD 全称 Binary File Descriptor library，是 GNU 的一个项目，目的是为了处理不同的目标文件格式。





