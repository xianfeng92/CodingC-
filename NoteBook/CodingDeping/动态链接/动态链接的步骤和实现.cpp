// !! 动态链接的步骤和实现

动态链接的步骤基本上分为3步:

1. 先是启动动态链接器本身
2. 然后装载所有需要的共享对象
3. 最后是重定位和初始化

// !! 动态链接器自举

动态链接器本身也是一个共享对象, 但是事实上它有一些特殊性。

对于普通共享对象文件来说,'它的重定位工作由动态链接器来完成'; 它也可以依赖于其它共享对象, '其中的被依赖的共享对象由动态链接器负责链接和装载'。

动态链接器的特殊性

1. 首先是动态链接器本身不可以依赖于其它任何共享对象

2. 其次是动态链接器本身所需要的全局和静态变量的重定位工作由它本身完成

对于第一个条件我们可以人为地控制, 在编写动态链接器时保证不使用任何系统库、运行库; 对于第二个条件, 动态链接器必须在启动时有一段非常精巧的代码可以完成这项工作而同时又不
能用到全局和静态变量。'这种具有一定限制条件的启动代码往往被称为自举(Bootstrap)'。

动态链接器入口地址即是自举代码的入口, 当操作系统将进程控制权交给动态链接器时, 动态链接器的自举代码即开始执行。自举代码首先会找到它自己的 GOT。而 GOT 的第一个入口保存的
即是”.dynamic”段的偏移地址, 由此找到了动态链接器本身的”.dynamic”段。通过”.dynamic”中的信息, 自举代码便可以获得动态链接器本身的重定位表和符号表等, 从而得到动态链接
器本身的重定位入口, 先将它们全部重定位。从这一步开始, 动态链接器代码中才可以开始使用自己的全局变量和静态变量。实际上在动态链接器的自举代码中，除了不可以使用全局变量和
静态变量之外，甚至不能调用函数，即动态链接器本身的函数也不能调用。


// !! 装载共享对象

完成基本自举以后, 动态链接器将可执行文件和链接器本身的符号表都合并到一个符号表当中, 我们可以称它为全局符号表(Global Symbol Table)。然后链接器开始寻找可执行文件所依赖
的共享对象，”.dynamic” 段中, 有一种类型的入口是 DT_NEEDED, 它所指出的是该可执行文件(或共享对象)所依赖的共享对象。由此，链接器可以列出可执行文件所需要的所有共享对象，
并将这些共享对象的名字放入到一个装载集合中。然后链接器开始从集合里取一个所需要的共享对象的名字, 找到相应的文件后打开该文件, 读取相应的ELF文件头和”.dynamic”段，然后将它
相应的代码段和数据段映射到进程空间中。如果这个 ELF 共享对象还依赖于其它共享对象, 那么将所依赖的共享对象的名字放到装载集合中。如此循环直到所有依赖的共享对象都被装载进来
为止. 当然链接器可以有不同的装载顺序, 如果我们把依赖关系看做一个图的话, 那么这个装载过程就是一个图的遍历过程, 链接器可能会使用深度优先或者广度优先或者其它的顺序来遍历
整个图，这取决于链接器, '比较常见的算法一般都是广度优先的'。

'当一个新的共享对象被装载进来的时候, 它的符号表会被合并到全局符号表中, 所以当所有的共享对象都被装载进来的时候, 全局符号表里面将包含进程中所有的动态链接所需要的符号'。


// !! 符号的优先级

'一个共享对象里面的全局符号被另一个共享对象的同名全局符号覆盖的现象又被称为共享对象的全局符号介入 (Global Symbol Interpose)'。

关于全局符号介入这个问题，实际上 Linux 下的动态链接器是这样处理的:

// !! 当一个符号需要被加入全局符号表时, 如果相同的符号名已经存在, 则后加入的符号被忽略


// !! 重定位和初始化

当所有依赖的共享对象被装载进来以后, '链接器开始重新遍历可执行文件和每个共享对象的重定位表', 将它们的 GOT/PLT 中的每个须要重定位的位置进行修正。因为此时动态链接器已经
拥有了进程的全局符号表, 所以这个修正过程也显得比较容易, 跟前面提到的地址重定位的原理基本相同。重定位完成之后，如果某个共享对象有 ”.init” 段, 那么动态链接器会执行
”.init” 段中的代码, 用以实现共享对象特有的初始化过程. 比如最常见: 共享对象中的 C++ 的全局/静态对象的构造就需要通过 ”.init” 来初始化。相应地共享对象中还可能有
”.finit” 段, 当进程退出时会执行”.finit”段中的代码, 可以用来实现类似 C++ 全局对象析构之类的操作。如果进行的可执行文件也有”.init”段，那么动态链接器不会执行它, 因为可
执行文件中的”.init”段和”.finit”段由程序初始化部分代码负责执行。当完成了重定位和初始化之后, 所有的准备工作就宣告完成了, 所需要的共享对象也都已经装载并且链接完成了, 
这时候动态链接器就如释重负, 将进程的控制权转交给程序的入口并且开始执行。