// !! 程序的内存布局

在平坦(Flat)的内存模型中，整个内存是一个统一的地址空间，用户可以使用一个 32 位的指针访问任意内存位置。但'实际上内存仍然在不同的地址区间上有着不同的地位'，例如，
大多数操作系统都会将 4GB 的内存空间中的一部分挪给内核使用， 应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间。在用户空间里，也有许多地址区间有特
殊的地位。

一般来讲，应用程序使用的内存空间里有如下“默认”的区域：

1. 栈：'栈用于维护函数调用的上下文'， Activate Record

2. 堆：堆是用来容纳应用程序动态分配的内存区域

3. 可执行文件映像: '存储可执行文件在内存里的映像'

4. 保留区: 对内存中受到保护而禁止访问的内存区域的总称

5. 动态链接库映射区: 这个区域用于映射装载的动态链接库

   在 Linux 下，如果可执行文件依赖其他共享库，那么系统就会为它在从 0x40000000 开始的地址分配相应的空间，并将共享库载入到该空间。

// !! 栈与调用惯例

1. 什么是栈

栈保存了函数调用所需要维护的信息，被称为堆栈帧 （Stack Frame） 或活动记录 （Activate Record）。

堆栈帧包括以下内容: '函数的返回地址和参数'; '临时变量', 包括函数的非静态局部变量以及编译器自动生成的其他临时变量; '保存的上下文', 包括在函数调用前后需要
保持不变的寄存器。

在 i386 中，'一个函数的活动记录用 ebp 和 esp 这两个寄存器划定范围'。esp 寄存器始终指向栈的顶部, 同时也就指向了当前函数的活动记录的顶部。

而相对的，ebp 寄存器指向了函数活动记录的一个固定位置，ebp 寄存器又被称为帧指针（Frame Pointer）。在参数之后的数据（包括参数）即是当前函数的活动记录。'固定不
变的 ebp 可以用来定位活动记录(Activate Record)中的各个数据，它指向调用该函数前 ebp 的值; 在函数返回时，ebp 通过读取这个值恢复到调用前的值'。

函数调用的方式决定了活动记录的结构, i386 下的函数总是这样调用的:

1. 把所有或一部分参数压入栈中，如果有其他参数没有入栈，那么使用某些特定的寄存器传递

2. 把当前指令的下一条指令的地址压入栈中

3. 跳转到函数体执行


其中第 2 步和第 3 步由指令 call 一起执行。跳转到函数体之后即开始执行函数，i386 函数体的“标准”开头是这样的:

1.push ebp: 把ebp压入栈中（称为old ebp）

2.mov ebp, esp：ebp = esp（这时 ebp 指向栈顶，而此时栈顶就是 old ebp）

3.【可选】sub esp, XXX：在栈上分配 XXX 字节的临时空间

4.【可选】push XXX：如有必要，保存名为XXX寄存器（可重复多个）


把 ebp 压入栈中，是为了在函数返回的时候便于恢复以前的 ebp 值,而之所以可能要保存一些寄存器，在于编译器可能要求某些寄存器在调用前后保持不变，那么函数就可以在调用开始
时将这些寄存器的值压入栈中，在结束后再取出。不难想象，在函数返回时，所进行的“标准”结尾与“标准”开头正好相反:

1. 【可选】pop XXX：如有必要，恢复保存过的寄存器

2. mov esp,ebp: 恢复 ESP 同时回收局部变量空间

3. pop ebp：从栈中恢复保存的 ebp 的值

4. ret: 从栈中取得返回地址，并跳转到该位置


// !! 调用惯例

调用惯例指函数调用的约定，包含以下内容:

1. 函数参数的传递顺序和方式，方式指使用栈还是寄存器等，顺序指从左到右或反过来

2. 栈的维护方式, 规定由调用者还是被调函数清理栈（将压入的参数弹出）

3. 名字修饰（Name-mangling）的策略，用于链接时区分不同的调用惯例

C 语言中存在多个调用惯例，默认使用 cdecl。cdecl 的惯例内容如下:

参数传递	    出栈方	    名字修饰

从右到左压栈	调用方	     函数名前加 1 个下划线



// !! 函数返回值传递

返回值是函数与调用方交互的另一个渠道。前面的例子使用 eax 传递返回值，函数将返回值存储在 eax 中，返回后函数的调用方再读取 eax。但 eax 只有4个字节， 对于返回
5～8 字节对象的情况，几乎所有的调用惯例都是采用 eax 和 edx 联合返回的方式进行的。eax 返回低 4 字节，edx 返回高 4 字节。


// !! 堆与内存管理

由于在任意时刻，程序都可能发出申请或释放内存的请求， 内存大小从几个字节到数 GB，导致堆管理较为复杂。

// !! 什么是堆

堆是一块巨大的内存空间, 常常占据整个虚拟空间的绝大部分。在这片空间里, 程序可以请求一块连续内存，并自由地使用, 这块内存在程序主动放弃之前都会一直保持有效。
如果让内核提供系统调用来申请和释放内存，由于系统调用的开销很大，频繁的申请和释放会导致性能较差。'事实上管理堆空间分配的往往是程序的运行库, 运行库向操作系统
“批发”一块较大的堆空间，然后“零售”给程序'。当全部“售完”或程序有大量的内存需求时, 再根据实际需求向操作系统“进货”。运行库必须管理它批发来的堆空间，不能把同一块
地址出售两次，导致地址的冲突。'运行库使用堆的分配算法来管理堆空间'。

// !! Linux 进程堆管理

进程的地址空间中, 除了可执行文件、共享库和栈之外，剩余的未分配的空间都可以被用来作为堆空间。Linux 的进程堆管理提供了两种堆空间分配的方式，即两个系统调用：
brk() 和 mmap()。


brk() 的声明如下：

int brk(void* end_data_segment)

'brk() 的作用实际上就是设置进程数据段的结束地址'，即它可以扩大或者缩小数据段（Linux 下数据段和 BSS 合并在一起统称数据段）。如果将数据段的结束地址向高地址移动，
那么扩大的那部分空间作为堆空间是最常见的做法之一。


mmap() 的作用就是'向操作系统申请一段虚拟地址空间'， 这块空间可以映射到某个文件（这也是这个系统调用的最初的作用）， 当它不将地址空间映射到某个文件时，称这块空间为
匿名（Anonymous）空间, 匿名空间就可以拿来作为堆空间。

void *mmap(
   void *start, 
   size_t length, 
   int prot, 
   int flags,
   int fd, 
   off_t offset);

1. mmap 的前两个参数分别用于指定需要申请的空间的起始地址和长度，'如果起始地址设置为 0，那么 Linux 系统会自动挑选合适的起始地址'

2. prot/flags 这两个参数用于设置申请的空间的权限（可读、可写、可执行）以及映射类型（文件映射、匿名空间等）

3. 最后两个参数是用于文件映射时指定文件描述符和文件偏移

glibc 的 malloc 函数是这样处理用户的空间请求的:

1. 对于小于 128KB 的请求来说，它会在现有的堆空间里面，按照堆分配算法为它分配一块空间并返回

2. 对于大于 128KB 的请求来说，它会使用 mmap() 函数为它分配一块匿名空间，然后在这个匿名空间中为用户分配空间


直接使用 mmap 也可以轻而易举地实现 malloc 函数

void *malloc(size_t nbytes)
{
    void* ret = mmap(0, nbytes, PROT_READ | PROT_WRITE,
        MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
    if (ret == MAP_FAILED)
        return 0;
    return ret;
}

mmap() 申请的空间的起始地址和大小都必须是系统页的大小的整数倍，对于字节数很小的请求如果也使用 mmap 的话，无疑是会浪费大量的空间的，所以上述的做法仅仅是演示而已，
不具有实用性。


// !! 堆分配算法

堆空间是程序向操作系统申请的一大块地址空间, 堆分配算法用于管理堆，按照需求分配、释放其中的空间。


// !! 1. 空闲链表

空闲链表（Free List）： 利用空闲空间开头的头（header）结构，将所有空闲块连接起来形成一个链表， 当用户请求一块空间时，遍历整个列表，直到找到合适大小的块并且将它
拆分；当用户释放空间时将它合并到空闲链表中。

这样的空闲链表实现尽管简单，但在释放空间的时候，给定一个已分配块的指针，堆无法确定这个块的大小。

一个简单的解决方法是多分配 4 字节用于保存大小。这是最简单的一种分配策略，还存在很多问题。例如，一旦链表被破坏，或者记录长度的那 4 字节被破坏，整个堆就无法正常工作，
而这些数据恰恰很容易被越界读写所接触到。


// !! 2. 位图


位图（Bitmap）的核心思想是将整个堆划分为大量相同大小的块（block），当用户请求内存的时候，总是分配整数个块的空间给用户，第一块称为已分配区域的头（Head），其余的称为
已分配区域的主体（Body）

使用一个整数数组来记录块的使用情况， 由于每个块只有 “头/主体/空闲” 三种状态，因此仅仅需要两位即可表示一个块。

(HIGH) 11 00 00 10 10 10 11 00 00 00 00 00 00 00 10 11 (LOW)

其中 11 表示H（Head），10 表示主体（Body），00 表示空闲（Free）


优点：

速度快：由于整个堆的空闲信息存储在一个数组内，因此访问该数组时cache容易命中

稳定性好：为了避免用户越界读写破坏数据，只须简单地备份一下位图即可。而且即使部分数据被破坏，也不会导致整个堆无法工作

块不需要额外信息，易于管理

缺点：

分配内存的时候容易产生碎片

若堆很大，或者设定的一个块很小，那么位图将会很大，失去cache命中率高的优势，而且也会浪费一定的空间。这种情况可以使用多级位图

// !! 3. 对象池

对象池适用于分配对象的大小是较为固定的几个值的场合。对象池的思路是，假设每次分配的大小相同，把堆对空间划分为大量请求大小的块，每次分配一个块。

对象池的管理方法可以采用空闲链表，也可以采用位图，与它们的区别仅仅在于它假定了每次请求的都是一个固定的大小，因此实现起来很容易。由于每次总是只请求一个单位的内存，
因此请求得到满足的速度非常快，无须查找一个足够大的空间。



'实际应用中，堆的分配算法往往是采取多种算法复合而成'。比如对于 glibc 来说，'它对于小于 64 字节的空间申请是采用类似于对象池的方法'; 而对于大于 512 字节的空间
申请采用的是最佳适配算法；对于大于 64 字节而小于 512 字节的，它会根据情况采取上述方法中的最佳折中策略；'对于大于 128KB 的申请，它会使用 mmap 机制直接向操作系
统申请空间'