#include <iostream>
#include <string>


using namespace std;

//!! 1. 头文件
// 通常每一个 .cpp 文件都有一个对应的 .h 文件. 也有一些常见例外, 如单元测试代码和只包含 main() 函数的 .cpp 文件
// !! 正确使用头文件可令代码在可读性、文件大小和性能上大为改观

// !! 1.1. Self-contained 头文件
// 头文件应该能够自给自足（self-contained,也就是可以作为第一个头文件被引入），以 .h 结尾
// 详言之，一个头文件要有 1.2. #define 保护，统统包含它所需要的其它头文件，也不要求定义任何特别 symbols


// !! 1.2. #define 保护
// 所有头文件都应该有 #define 保护来防止头文件被多重包含, 命名格式当是: <PROJECT>_<PATH>_<FILE>_H
// 为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径


// !! 1.3. 前置声明
// 尽可能地避免使用前置声明, 使用 #include 包含需要的头文件即可

// 所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义
// 前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入
// 前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次


// !! 1.4. 内联函数
// 只有当函数只有 10 行甚至更少时才将其定义为内联函数
// 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用
// 只要内联的函数体较小, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联

// !! 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和
// !! 基类析构函数被调用. 另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失

// 有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数


// !! 1.5. #include 的路径及顺序
// 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h
// 1. C 系统文件
// 2. C++ 系统文件
// 3. 其他库的 .h 文件
// 4. 本项目内 .h 文件

// C 系统文件
#include <sys/types.h>
#include <unistd.h>

// C++ 系统文件
#include <hash_map>
#include <vector>

// 项目内的 .h 头文件
#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/public/bar.h"

// 您所依赖的符号 (symbols) 被哪些头文件所定义，您就应该包含（include）哪些头文件
// 比如你要用到 bar.h 中的某个符号, 哪怕你所包含的 foo.h 已经包含了 bar.h, 也照样得包含 bar.h, 除非 foo.h 有明确说明它会自动向你
// 提供 bar.h 中的 symbol


// !! 小结
// 1. 前置声明的类是不完全类型( incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数
// 2. 类内部的函数一般会自动内联, 所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 .cpp 文件里.这样可以保持头文件的类相当精炼，
//    也很好地贯彻了声明与定义分离的原则
// 3. 在 #include 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 .h 和本项目内的 .h 是个好习惯
int main(int argc, char **argv)
{

}