// !! 类设计者的核查表

核查表并不是任务清单。它的用途是帮助你回忆起可能会忘掉的事情，而不是来约束你。

知道这一点之后，请看下面关于定义类时要弄清楚的一些问题。这些问题都没有确切的答案，关键是要提醒你思考它们，并确认你所作的
事情是出于有意识的决定，而不是偶然事件。

1. 你的类需要一个构造函数吗？

   我们现在主要关心的是那些足够复杂的类，它们需要构造函数来隐藏它们的内部工作方式

2. 你的数据成员是私有的吗？

   通常使用公有的数据成员不是什么好事，因为类设计者无法控制何时访问这些成员.另外，使用函数而不是变量，在还允许读取访问的时
   候能够很容易地阻止写入访问。没有所谓“最好的”风格来编写访问或者改变类部件的函数，请选择一种规范，一致地使用，并用文档清楚
   地保存。
   
3. 你的类需要一个无参的构造函数吗？

   如果一个类已经有了构造函数，而你想声明该类的对象可以不必显式地初始化它们，则必须显式地写一个无参的构造函数。此外请牢记，如果一
   个类需要一个显式构造函数，则试图生成该类对象的数组是非法的

4. 是不是每个构造函数初始化所有的数据成员？

   '构造函数的用途就是用一种明确定义的状态来设置对象'。对象的状态由对象的数据成员进行反映。因此，每个构造函数都要负责为所有的数据成员
   设置经过明确定义的值。如果构造函数没有做到这一点，就很可能导致错误。

5. 类需要析构函数吗？

   不是所有有构造函数的类都需要析构函数。例如，表示复数的类即使有构造函数也可能不需要析构函数。'如果深入考虑一个类要做些什么，那么该类是
   否需要析构函数的问题就十分明显了'。应该问一问该类是否分配了资源，而这些资源又不会由成员函数自动释放，这就足够了。特别是那些构造函数里
   包含了 new 表达式的类，通常要在析构函数中加上相应的 delete 表达式，所以会需要一个析构函数

6. 类需要一个虚析构函数吗？

  '有些类需要虚析构函数只是为了声明它们的析构函数是虚的。当然，决不会用作基类的类是不需要虚析构函数的:任何虚函数只在继承的情况下才有用'。
   但是，请设想一下，你写了一个叫 B 的类，而别人从它派生了一个类 D，那么 B 何时需要一个虚析构函数？只要有人可能会对实际指向 D 类型对象的 B* 
   指针执行 delete 表达式，你就需要给 B 加上一个虚析构函数

   struct B 
   {
       string s;
   };

   struct D : B
   {
       string t;
   };

   int main()
   {
       B *bp = new D；
       delete bp;
   }

   这里，即使 B 没有虚成员函数，甚至根本没有任何成员函数，也必须有一个虚析构函数，否则 delete 会出错：

    struct B 
   {
       string s;
       virtual ~B() {}
   };

   虚析构函数通常是空的。






