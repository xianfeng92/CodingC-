
// !! 显示运行时链接

支持动态链接的系统往往都支持一种更加灵活的模块加载方式,叫做显式运行时链接(Explicit Run-time Linking)，有时候也叫做运行时加载。也就是让程序自己在运行时控制
加载指定的模块，并且可以在不需要该模块时将其卸载。

如果动态链接器可以在运行时将共享模块装载进内存并且可以进行重定位等操作， 那么这种运行时加载在理论上也是很容易实现的。而且一般的共享对象不需要进行任何修改就可以进行
运行时加载，这种共享对象往往被叫做~动态装载库(Dynamic Loading Library)~，其实本质上它跟一般的共享对象没什么区别，只是程序开发者使用它的角度不同。

这种运行时加载使得程序的模块组织变得很灵活，可以用来实现一些诸如插件、驱动等功能。当程序需要用到某个插件或者驱动的时候，才将相应的模块加载进来，而不需要从一开始就将
它们全部加载进来，从而减少了程序启动时间和内存使用。并且程序可以在运行的时候重新加载某个模块，这样使得程序本身不必重新启动而实现模块的增加、删除、更新等，这对于很多
需要长期运行的程序来说是很大的优势。


在 linux 中， 从文件格式上看动态库实际上和一般的共享对象没有什么区别。最主要的区别是

// !! 共享对象是由动态链接器在程序启动之前负责装载和链接的，这一系列步骤都是由动态链接器完成的，对于程序本身是透明的；而动态库的装载则是通过一系列由
// !! 动态链接器提供的 API 来对动态库进行操作, 这几个 API 定义在 /lib/x86_64-linux-gnu/libdl.so.2 里，它们的声明和相关常量被定义在系统标准头文件
// !! <dlfcn.h> 

// !! 打开动态库(dlopen)

/* Open the shared object FILE and map it in; return a handle that can be
   passed to `dlsym' to get symbol values from it.  */
void *dlopen (const char *__file, int __mode);

dlopen()： 此函数用来打开一个动态库，并将其加载到进程的地址空间，完成初始化过程。

1. 第一个参数是被加载动态库的路径，如果这个路径是绝对路径(以”/”开始的路径)，则该函数将会尝试直接打开该动态库；如果是相对路径，那么该函数会尝试在以一定的顺序去查找该动
   态库文件。如果我们将 __file 这个参数设置为 0，那么 dlopen 返回的将是全局符号表的句柄，也就是说我们可以在运行时找到全局符号表里面的任何一个符号，并且可以执行它们，
   这有些类似高级语言反射 (Reflection) 的特性。全局符号表包括了程序的可执行文件本身、被动态链接器加载到进程中的所有共享模块以及在运行时通过 dlopen 打开并且使用了
   RTLD_GLOBAL 方式的模块中的符号。

2. 第二个参数__mode 表示函数符号的解析方式，常量 RTLD_LAZY 表示使用延迟绑定，当函数第一次被用到时才进行绑定，即 PLT 机制；而 RTLD_NOW 表示当模块被加载时即完成
   所有的函数绑定工作， 如果有任何未定义的符号引用的绑定工作没法完成，那么 dlopen 就返回错误。

dlopen 的返回值是被加载的模块的句柄，这个句柄在后面使用 dlsym 或者 dlclose 时需要用到。如果加载模块失败，则返回NULL。如果模块已经通过dlopen被加载过了，那么返回
的是同一个句柄。另外如果被加载的模块之间有依赖关系，比如模块 A 依赖于模块 B，那么程序员需要手工加载被依赖的模块，比如先加载 B，再加载 A。

事实上 dlopen 还会在加载模块时执行模块中初始化部分的代码。动态链接器在加载模块时，会执行 ”.init” 段的代码，用以完成模块的初始化工作，dlopen 的加载过程基本跟动态链
接器一致，在完成装载、映射和重定位以后，就会执行 ”.init” 段的代码，然后返回。


// !! 查找符号（dlsym)

dlsym()：此函数基本上是运行时加载的核心部分， 我们可以通过这个函数找到所需要的符号。

1. 第一个参数是由dlopen返回的动态库的句柄

2. 第二个参数即所要查找的符号的名字， 一个以 ”\0” 结尾的 C 字符串

如果 dlsym 找到了相应的符号，则返回该符号的值； 没有找到相应的符号， 则返回 NULL。dlsym 返回的值对于不同类型的符号，意义是不同的。如果查找的符号是个函数，
那么它返回函数的地址；如果是个变量，它返回变量的值；如果这个符号是个常量，那么它返回的是该常量的值。


// !! 错误处理（dlerror）

每次我们调用 dlopen、dlsym、dlclose 以后，我们都可以调用 dlerror 函数来判断上一次调用是否成功。dlerror 的返回值类型是 char*，如果返回 NULL，则表示上一次
调用成功； 如果不是， 则返回相应的错误信息。


// !! 关闭动态库（dlclose）

dlclose()：此函数的作用跟 dlopen 刚好相反，它的作用是将一个已经加载的模块卸载。系统会维持一个加载引用计数器，每次使用 dlopen 加载某模块时，相应的计数器加一；
每次使用 dlclose 卸载某模块时，相应计数器减一。只有当计数器减到 0 时，模块才被真正地卸载掉。卸载的过程跟加载刚好相反，先执行 ”.finit” 段的代码，然后将相应的
符号从符号表中去除，取消进程空间跟模块的映射关系，然后关闭模块文件。


// !! 运行时链接的程序 Demo

// RunSoSimple.c
#include<stdio.h>
#include<dlfcn.h>
int main(int argc, char **argv)
{
    void *handle;
    double (*func)(double);
    char *error;

    handle = dlopen(argv[1], RTLD_NOW);
    if (handle == NULL)
    {
        printf("Open Library %s error: %s\n", argv[1], dlerror());
        return -1;
    }
    func = dlsym(handle, "sin");
    if ((error = dlerror()) != NULL)
    {
        printf("Symbol is not found: %s\n", error);
    }
    else
    {
        printf("%f \n", func(3.1415926 / 2));
    }
    dlclose(handle);
}


>> gcc -o RunSoSimple RunSoSimple.c -ldl
>> ./RunSoSimple /lib/x86_64-linux-gnu/libm.so.6 

1.000000 


