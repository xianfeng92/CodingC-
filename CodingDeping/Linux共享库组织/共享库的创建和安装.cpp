// !! 共享库的创建和安装


共享库的创建: 创建共享库的过程跟创建一般的共享对象的过程基本一致，最关键的是使用 GCC 的两个参数，即 -shared 和 -fPIC。-shared 表示输出结果是共享库类型的;  
-fPIC 表示使用'地址无关代码(Position Independent Code)' 技术来生产输出文件。另外还有一个参数是 -Wl ，这个参数可以将指定的参数传递给链接器，比如当我们使用
-Wl,-soname my_soname 时，GCC 会将 -soname my_soname 传递给链接器，用来指定输出共享库的 SO-NAME。如果我们不使用 -soname 来指定共享库的 SO-NAME，
那么该共享库默认就没有 SO-NAME, 即使用 ldconfig 更新 SO-NAME 的软链接时, 对该共享库也没有效果。


几个值得注意的事项:

1.不要把输出共享库中的符号和调试信息去掉, 也不要使用 GCC 的 -fomit-frame-pointer 选项，这样做虽然不会导致共享库停止运行，但是会影响调试共享库，给后面的工作带
  来很多麻烦

2. 在开发过程中, 你可能要测试新的共享库， 但是又不希望影响现有的程序正常运行, 可以用 LD_LIBRARY_PATH 指定共享库的查找路径

3. 默认情况下，链接器在产生可执行文件时, 只会将那些链接时被其它共享模块引用到的符号放到动态符号表，这样可以减少动态符号表的大小。ld 链接器提供了一个 
   -export-dynamic 的参数，这个参数表示链接器在生产可执行文件时， 将所有全局符号导出到动态符号表

// !! 清除符号信息

正常情况下编译出来的共享库或可执行文件里面带有符号信息和调试信息, 这些信息在调试时非常有用，但是对于最终发布的版本来说，这些符号信息用处并不大，并且使得文件尺寸变大。
我们可以'使用一个叫 strip 的工具清除掉共享库或可执行文件的所有符号和调试信息'( strip 是binutils的一部分)

>> strip Lib.so

去除符号和调试信息以后的文件往往比之前要小很多。除了使用 strip 工具，我们还可以使用 ld 的 -s 和 -S 参数，使得链接器生成输出文件时就不产生符号信息。-s 和 -S 的区别
是： -S 消除调试符号信息，而 -s 消除所有符号信息。我们也可以在 GCC中 通过 -Wl,-s 和 -Wl,-S 给 ld 传递这两个参数。


// !! 共享库的安装

最简单的办法就是将共享库复制到某个标准的共享库目录，如 /lib、/usr/lib 等，然后运行 ldconfig 即可。不过上述方法往往需要系统的 root 权限，如果没有，则无法往 
/lib、/usr/lib 等目录添加文件，也无法运行 ldconfig 程序。也可以通过建立相应的 SO-NAME 软链接方法，并告诉编译器和程序如何查找该共享库等，以便于编译器和程序都
能够正常运行。建立 SO-NAME 的办法也是使用 ldconfig，只不过需要指定共享库所在的目录。在编译程序时，也需要指定共享库的位置，GCC 提供了两个参数”-L”和”-l”，分别用于
指定共享库搜索目录和共享库。也可以使用 -rpath 参数。


// !! 共享库构造和析构函数

很多时候你希望共享库在被装载时能够进行一些初始化工作, 比如打开文件、网络连接等，使得共享库里面的函数接口能够正常工作。GCC 提供了一种共享库的构造函数，只要在函数声明时
加上 __attribute__((constructor)) 的属性，即指定该函数为共享库构造函数， 拥有这种属性的函数会在共享库加载时被执行，即在程序的 main 函数之前执行。

我们可以使用在函数声明时加上 __attribute__((destructor)) 的属性，这种函数会在 main() 函数执行完毕之后执行(或者是程序调用exit()时执行)。


// !! 共享库脚本

共享库还可以是符合一定格式的链接脚本文件。通过这种脚本文件，我们可以把几个现有的共享库通过一定的方式组合起来，从用户的角度看就是一个新的共享库。这里的脚本与 LD 的脚本从
语法和命令上来讲没什么区别，它们的作用也相似，即将一个或多个输入文件以一定的格式经过变换以后形成一个输出文件。我们也可以将这种共享库脚本叫做动态链接脚本，因为这个链接
过程是动态完成的，也就是运行时完成的。







