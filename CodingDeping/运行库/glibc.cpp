// !! glibc

运行库是平台相关的, 因为它与操作系统结合得非常紧密。'C 语言的运行库从某种程度上来讲是 C 语言的程序和不同操作系统平台之间的抽象层，它将不同的操作系统 API 
抽象成相同的库函数'。比如我们可以在不同的操作系统平台下使用 fread 来读取文件，而事实上 fread 在不同的操作系统平台下的实现是不同的，但作为运行库的使用者
我们不需要关心这一点。

值得注意的是，像线程操作这样的功能并不是标准的C语言运行库的一部分，但是 glibc 和 MSVCRT 都包含了线程操作的库函数。比如 glibc 有一个可选的 pthread 库中的 
pthread_create() 函数可以用来创建线程。所以 glibc 和 MSVCRT 事实上是标准 C 语言运行库的超集，它们各自对 C 标准库进行了一些扩展。

glibc 即 GNU C Library，是 GNU 旗下的C标准库。

glibc 在 /lib 目录下的 .so 文件为 libc.so.6，即第六个 libc 版本，而且在各个 Linux 发行版中，glibc 往往被称为libc6。glibc 在 Linux 平台下占据了主导地位
之后，它又被移植到了其他操作系统和其他硬件平台，诸如 FreeBSD、NetBSD 等，而且它支持数十种 CPU 及嵌入式平台。

glibc 的发布版本主要由两部分组成：

1. 一部分是'头文件'，比如 stdio.h、stdlib.h 等，它们往往位于 /usr/include;

2. 另外一部分是'库的二进制文件部分'。二进制部分主要是 C 语言标准库，它有静态和动态两个版本。动态的标准库位于 /lib/libc.so.6; 而静态标准库位于 /usr/lib/libc.a

事实上 glibc 除了C标准库之外，还有几个辅助程序运行的运行库，这几个文件可以称得上是真正的“运行库”。它们就是 /usr/lib/crt1.o、 /usr/lib/crti.o 和 
/usr/lib/crtn.o

// !! glibc 启动文件

crt1.o 里面包含的就是程序的入口函数 _start，由它负责调用 __libc_start_main 初始化 libc 并且调用 main 函数进入真正的程序主体。

实际上最初开始的时候它并不叫做 crt1.o，而是叫做 crt.o，包含了'基本的启动、退出代码'。由于当时有些链接器对链接时目标文件和库的顺序有依赖性，crt.o 这个文件必须
被放在链接器命令行中的所有输入文件中的第一个，为了强调这一点，crt.o 被更名为crt0.o，'表示它是链接时输入的第一个文件'。

后来由于 C++ 的出现和 ELF 文件的改进，出现了必须在 main() 函数之前执行的全局/静态对象构造和必须在 main() 函数之后执行的全局/静态对象析构。
为了满足类似的需求，运行库在每个目标文件中引入两个与初始化相关的段 .init 和 .finit。运行库会保证所有位于这两个段中的代码会先后于 main() 函数执行，所以
用它们来实现全局构造和析构就是很自然的事情了。链接器在进行链接时，会把所有输入目标文件中的 .init 和 .finit 按照顺序收集起来，然后将它们合并成输出文件中的 .init 
和 .finit 。但是这两个输出的段中所包含的指令还需要一些辅助的代码来帮助它们启动(比如计算GOT之类的)，于是'引入了两个目标文件分别用来帮助实现初始化函数'的 crti.o 
和 crtn.o。

为了支持新的库和可执行文件格式，crt0.o 也进行了升级，变成了 crt1.o。crt0.o 和 crt1.o 之间的区别是 crt0.o 为原始的，不支持 .init 和 .finit 的启动代码，
而 crt1.o 是改进过后，支持 .init 和 .finit 的版本。

crti.o 和 crtn.o 这两个目标文件中包含的代码实际上是 _init() 函数和 _finit() 函数的开始和结尾部分，当这两个文件和其他目标文件安装顺序链接起来以后，刚好形成两
个完整的函数 _init() 和 _finit()。


于是在最终链接完成之后，输出的目标文件中的 .init 段只包含了一个函数 _init()，这个函数的开始部分来自于 crti.o 的 .init 段，结束部分来自于 crtn.o的 .init 段

为了保证最终输出文件中 .init 和 .finit 的正确性，我们必须保证在链接时，'crti.o 必须在用户目标文件和系统库之前'，而 'crtn.o 必须在用户目标文件和系统库之后'。
链接器的输入文件顺序一般是:

ld crt1.o crti.o [user_objects] [system_libraries] crtn.o


在默认情况下，ld 链接器会将 libc、crt1.o 等这些 CRT 和启动文件与程序的模块链接起来，但是有些时候，我们可能不需要这些文件，或者希望使用自己的 libc 和 crt1.o 
等启动文件，以替代系统默认的文件，这种情况在嵌入式系统或操作系统内核编译的时候很常见。'GCC 提高了两个参数 -nostartfile 和 -nostdlib ，分别用来取消默认的启动
文件和 C 语言运行库'。



// !! GCC 平台相关目标文件

就这样，在链接时碰到过的诸多输入文件中，已经解决了 crt1.o、crti.o 和crtn.o，剩下的还有几个 crtbeginT.o、libgcc.a、libgcc_eh.a、crtend.o。
严格来讲，这几个文件实际上不属于 glibc，它们是 GCC 的一部分，它们都位于 GCC 的安装目录下。


首先是 crtbeginT.o 及 crtend.o，这两个文件是真正用于实现 C++ 全局构造和析构的目标文件。

事实上是 crti.o 和 crtn.o 中的 .init 和 .finit 提供一个在 main() 之前和之后运行代码的机制，而真正全局构造和析构则由 crtbeginT.o 和 crtend.o 来实现


由于 GCC 支持诸多平台，能够正确处理不同平台之间的差异性也是 GCC 的任务之一。比如有些 32 位平台不支持 64 位的long long类型的运算，编译器不能够直接产生相应的 CPU
指令，而是需要一些辅助的例程来帮助实现计算。libgcc.a 里面包含的就是这种类似的函数，这些函数主要包括整数运算、浮点数运算(不同的CPU对浮点数的运算方法很不相同)等，而
libgcc_eh.a 则包含了支持 C++ 的异常处理(Exception Handling)的平台相关函数。