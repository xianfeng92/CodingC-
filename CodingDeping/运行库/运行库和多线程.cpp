
// !! 运行库与多线程

// !! CRT 的多线程困扰

// !! 线程的访问权限

线程可以访问进程内存里所有数据，包括其他线程的堆栈（前提是知道其他线程的堆栈地址）。实际应用中, 线程也有自己的私有存储空间，包括:

1. 栈（虽然可以被其他线程访问，但通常仍被认为是私有数据）

2. 线程局部存储（Thread Local Storage，TLS）。某些OS为线程单独提供的私有空间，通常尺寸有限

3. 寄存器（包括 PC），寄存器是执行流的基本数据


C程序员角度，线程私有和非私有数据:

1. 线程私有 ----> 局部变量（栈）、函数参数（栈）、TLS数据（线程局部存储）

2. 线程之间共享（进程所有）-----> 全局变量、堆上的数据、函数里的静态变量、程序代码，任何线程都有权利读取并执行任何代码、打开文件，A线程打开的文件可由B线程读写


// !! 多线程运行库


Linux 下的 glibc 提供了可选线程库 pthread(POSIX Thread)，提供诸如 pthread_create(), pthread_exit() 等函数，用于线程的创建和退出。但都不属于标准运行
库，和平台相关。


// !! CRT 改进

1. 使用 TLS（线程局部存储)

对于全局变量errno，多线程运行库如何改进？

首先，让 errno 称为各个线程的私有成员。glibc 中，errno 被定义为一个宏，如：

#define errno (*__errno_location ())

函数 __errno_location 在单线程版本中，直接返回全局变量 errno 的地址; 在多线程版本中，不同线程调用 __errno_location 返回的地址则各不相同

2. 加锁

 多线程版本的运行库中，线程不安全的函数内部都会自动地进行加锁，包括 malloc、printf 等，而异常处理的错误也早解决了。因此使用多线程版本的运行库时，即使应用程序员在
 malloc/new 前后不加锁，也不会出现并发冲突。

3. 改进函数调用方式

一种改进方是：修改所有线程不安全的函数的参数列表，改成某种线程安全的版本。


// !!  线程局部存储实现