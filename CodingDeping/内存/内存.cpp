// !! 程序的内存布局

在平坦(Flat)的内存模型中，整个内存是一个统一的地址空间，用户可以使用一个 32 位的指针访问任意内存位置。但'实际上内存仍然在不同的地址区间上有着不同的地位'，例如，
大多数操作系统都会将 4GB 的内存空间中的一部分挪给内核使用， 应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间。在用户空间里，也有许多地址区间有特
殊的地位。

一般来讲，应用程序使用的内存空间里有如下“默认”的区域：

1. 栈：'栈用于维护函数调用的上下文'， Activate Record

2. 堆：堆是用来容纳应用程序动态分配的内存区域

3. 可执行文件映像: '存储可执行文件在内存里的映像'

4. 保留区: 对内存中受到保护而禁止访问的内存区域的总称

5. 动态链接库映射区: 这个区域用于映射装载的动态链接库

   在 Linux 下，如果可执行文件依赖其他共享库，那么系统就会为它在从 0x40000000 开始的地址分配相应的空间，并将共享库载入到该空间。

// !! 栈与调用惯例

1. 什么是栈

栈保存了函数调用所需要维护的信息，被称为堆栈帧 （Stack Frame） 或活动记录 （Activate Record）。

堆栈帧包括以下内容: '函数的返回地址和参数'; '临时变量', 包括函数的非静态局部变量以及编译器自动生成的其他临时变量; '保存的上下文', 包括在函数调用前后需要
保持不变的寄存器。

在 i386 中，'一个函数的活动记录用 ebp 和 esp 这两个寄存器划定范围'。esp 寄存器始终指向栈的顶部, 同时也就指向了当前函数的活动记录的顶部。

而相对的，ebp 寄存器指向了函数活动记录的一个固定位置，ebp 寄存器又被称为帧指针（Frame Pointer）。在参数之后的数据（包括参数）即是当前函数的活动记录。'固定不
变的 ebp 可以用来定位活动记录(Activate Record)中的各个数据，它指向调用该函数前 ebp 的值; 在函数返回时，ebp 通过读取这个值恢复到调用前的值'。

函数调用的方式决定了活动记录的结构, i386 下的函数总是这样调用的:

1. 把所有或一部分参数压入栈中，如果有其他参数没有入栈，那么使用某些特定的寄存器传递

2. 把当前指令的下一条指令的地址压入栈中

3. 跳转到函数体执行


其中第 2 步和第 3 步由指令 call 一起执行。跳转到函数体之后即开始执行函数，i386 函数体的“标准”开头是这样的:

1.push ebp: 把ebp压入栈中（称为old ebp）

2.mov ebp, esp：ebp = esp（这时 ebp 指向栈顶，而此时栈顶就是 old ebp）

3.【可选】sub esp, XXX：在栈上分配 XXX 字节的临时空间

4.【可选】push XXX：如有必要，保存名为XXX寄存器（可重复多个）


把 ebp 压入栈中，是为了在函数返回的时候便于恢复以前的 ebp 值,而之所以可能要保存一些寄存器，在于编译器可能要求某些寄存器在调用前后保持不变，那么函数就可以在调用开始
时将这些寄存器的值压入栈中，在结束后再取出。不难想象，在函数返回时，所进行的“标准”结尾与“标准”开头正好相反:

1. 【可选】pop XXX：如有必要，恢复保存过的寄存器

2. mov esp,ebp: 恢复 ESP 同时回收局部变量空间

3. pop ebp：从栈中恢复保存的 ebp 的值

4. ret: 从栈中取得返回地址，并跳转到该位置


// !! 调用惯例

调用惯例指函数调用的约定，包含以下内容:

1. 函数参数的传递顺序和方式，方式指使用栈还是寄存器等，顺序指从左到右或反过来

2. 栈的维护方式, 规定由调用者还是被调函数清理栈（将压入的参数弹出）

3. 名字修饰（Name-mangling）的策略，用于链接时区分不同的调用惯例

C 语言中存在多个调用惯例，默认使用 cdecl。cdecl 的惯例内容如下:

参数传递	    出栈方	    名字修饰

从右到左压栈	调用方	     函数名前加 1 个下划线



// !! 函数返回值传递

返回值是函数与调用方交互的另一个渠道。前面的例子使用 eax 传递返回值，函数将返回值存储在 eax 中，返回后函数的调用方再读取 eax。但 eax 只有4个字节， 对于返回
5～8 字节对象的情况，几乎所有的调用惯例都是采用 eax 和 edx 联合返回的方式进行的。eax 返回低 4 字节，edx 返回高 4 字节。


// !! 堆与内存管理

由于在任意时刻，程序都可能发出申请或释放内存的请求， 内存大小从几个字节到数 GB，导致堆管理较为复杂。

// !! 什么是堆

堆是一块巨大的内存空间, 常常占据整个虚拟空间的绝大部分。在这片空间里, 程序可以请求一块连续内存，并自由地使用, 这块内存在程序主动放弃之前都会一直保持有效。
如果让内核提供系统调用来申请和释放内存，由于系统调用的开销很大，频繁的申请和释放会导致性能较差。'事实上管理堆空间分配的往往是程序的运行库, 运行库向操作系统
“批发”一块较大的堆空间，然后“零售”给程序'。当全部“售完”或程序有大量的内存需求时, 再根据实际需求向操作系统“进货”。运行库必须管理它批发来的堆空间，不能把同一块
地址出售两次，导致地址的冲突。'运行库使用堆的分配算法来管理堆空间'。

// !! Linux 进程堆管理











