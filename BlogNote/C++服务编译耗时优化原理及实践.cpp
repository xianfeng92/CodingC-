

// !! 编译原理及分析

为了更好地理解编译优化方案, 先简单介绍一下编译原理, 通常我们在进行 C++ 开发时, 编译的过程主要包含下面四个步骤

1. 预处理器: 预处理之后, 得到的仅仅是真正的源代码

   a. 宏定义替换、头文件展开、条件编译展开、删除注释

   b. gcc -E选项可以得到预处理后的结果，扩展名为.i 或 .ii

   c. C/C++ 预处理不做任何语法检查，不仅是因为它不具备语法检查功能，也因为预处理命令不属于 C/C++ 语句（这也是定义宏时不要加分号的原因）, 语法检查是
      编译器要做的事情

2. 编译器

   a. 生成汇编代码, 得到汇编语言程序（把高级语言翻译为机器语言）, 该种语言程序中的每条语句都以一种'标准的文本格式确切的描述了一条低级机器语言指令'
   b. gcc -S选项可以得到编译后的汇编代码文件，扩展名为.s
   c. 汇编语言为不同高级语言的不同编译器提供了通用的输出语言

3. 汇编器: 生成目标文件

   a. gcc -c选项可以得到汇编后的结果文件，扩展名为.o
   b. .o文件是按照的二进制编码方式生成的文件

4. 链接器: 生成可执行文件或库文件

   a. 静态库: 指编译链接时，把库文件的代码全部加入到可执行文件中, 因此生成的文件比较大, 但在运行时也就不再需要库文件了, 其后缀名一般为“.a”

   b. 动态库: 在编译链接时并没有把库文件的代码加入到可执行文件中, 而是在程序执行时由运行时链接文件加载库, 这样可执行文件比较小, 动态库一般后缀名为“.so”

   c. 可执行文件: 将所有的二进制文件链接起来融合成一个可执行程序, 不管这些文件是目标二进制文件还是库二进制文件

// !! C++ 编译特点

1. 每个源文件独立编译

   C/C++ 的编译系统和其他高级语言存在很大的差异, 其他高级语言中, 编译单元是整个 Module, 即 Module 下所有源码会在同一个编译任务中执行。而在 C/C++ 中编译单元是
   以文件为单位。'每个 .c/.cc/.cxx/.cpp 源文件是一个独立的编译单元, 导致编译优化时只能基于本文件内容进行优化, 很难跨编译单元提供代码优化'。

2. 每个编译单元都需要独立解析所有包含的头文件

   如果 N 个源文件引用到了同一个头文件, 则这个头文件需要解析 N 次; 如果头文件中有模板（STL/Boost）则该模板在每个 cpp 文件中使用时都会做一次实例化, N 个源文件中的
   std::vector 会实例化 N 次.

3. 模板函数实例化
   
   在 C++ 98 语言标准中, 对于源代码中出现的每一处模板实例化, 编译器都需要去做实例化的工作.而在链接时，链接器还需要移除重复的实例化代码。显然编译器遇到一个模板定义时, 
   每次都去进行重复的实例化工作, 进行重复的编译工作。此时如果能够让编译器避免此类重复的实例化工作,  那么可以大大提高编译器的工作效率。在 C++ 0x 标准中一个新的语言特性 – 
   外部模板的引入解决了这个问题。

   在 C++ 98 中，已经有一个叫做显式实例化（Explicit Instantiation）的语言特性, 它的目的是指示编译器立即进行模板实例化操作（即强制实例化）。而外部模板语法就是在
   显式实例化指令的语法基础上进行修改得到的, '通过在显式实例化指令前添加前缀 extern 从而得到外部模板的语法'。

① 显式实例化语法: template class vector  ② 外部模板语法: extern template class vector。

一旦在一个编译单元中使用了外部模板声明, 那么编译器在编译该编译单元时, 会跳过与该外部模板声明匹配的模板实例化。

4. 虚函数

   编译器处理虚函数的方法是: 给每个对象添加一个指针, 存放了指向虚函数表的地址; 虚函数表存储了该类（包括继承自基类）的虚函数地址。如果派生类重写了虚函数的新定义, 
   该虚函数表将保存新函数的地址, 如果派生类没有重新定义虚函数, 该虚函数表将保存函数原始版本的地址。 如果派生类定义了新的虚函数, 则该函数的地址将被添加到虚函数表中。

调用虚函数时, 程序将查看存储在对象中的虚函数表地址, 转向相应的虚函数表, 使用类声明中定义的第几个虚函数, 程序就使用数组的第几个函数地址并执行该函数。

5. 编译优化

   GCC 提供了为了满足用户不同程度的的优化需要提供了近百种优化选项, 用来对编译时间、目标文件长度、执行效率这个三维模型进行不同的取舍和平衡。

优化的方法不一而足, 总体上将有以下几类:

① 精简操作指令 ② 尽量满足 CPU 的流水操作 ③ 通过对程序行为地猜测, 重新调整代码的执行顺序。 ④ 充分使用寄存器 ⑤ 对简单的调用进行展开等等

O0：不做任何优化，这是默认的编译选项

O和O1: 对程序做部分编译优化, 编译器会尝试减小生成代码的尺寸、缩短执行时间、但并不执行需要占用大量编译时间的优化

O2：是比O1更高级的选项，进行更多的优化。GCC 将执行几乎所有的不包含时间和空间折中的优化。当设置O2选项时，编译器并不进行循环展开以及函数内联优化。与O1比较而言，
    O2 优化增加了编译时间的基础上, 提高了生成代码的执行效率。
O3：在O2的基础上进行更多的优化，例如使用伪寄存器网络、普通函数的内联、以及针对循环的更多优化
Os：主要是对代码大小的优化, 通常各种优化都会打乱程序的结构, 让调试工作变得无从着手。并且会打乱执行顺序, 依赖内存操作顺序的程序需要做相关处理才能确保程序的正确性

编译优化有可能带来的问题:

① 调试问题: 正如上面所提到的, 任何级别的优化都将带来代码结构的改变。例如: 对分支的合并和消除、对公用子表达式的消除、对循环内 load/store 操作的替换和更改等，
   都将会使目标代码的执行顺序变得面目全非，导致调试信息严重不足

② 内存操作顺序改变问题: 在 O2 优化后, 编译器会对影响内存操作的执行顺序。

6. C/C++ 跨编译单元的优化只能交给链接器


// !! 编译展开分析

编译展开分析就是通过 C++ 的预编译阶段保留的 .ii 文件, 查看通过展开后的编译文件大小, 具体可以通过在 cmake 中指定编译选型 “-save-temps” 保留编译中间文件


set(CMAKE_CXX_FLAGS "-std=c++11 ${CMAKE_CXX_FLAGS} -ggdb -Og -fPIC -w -Wl,--export-dynamic -Wno-deprecated -fpermissive -save-temps")

编译耗时的最直接原因就是编译文件展开之后比较大, 通过编译展开后的文件大小和内容, 通过这个方式能够找到各个文件编译耗时的共性

// !! 头文件依赖分析

头文件依赖分析是从引用头文件数量的角度来看代码是否合理的一种分析方式, 使用一个脚本来统计头文件的依赖关系, 并且分析输出头文件依赖引用计数, 用来辅助判断头文
件依赖关系是否合理。

// !! 编译耗时结果分段统计

编译耗时分段统计是从结果上看各个文件的编译耗时以及各个编译阶段的耗时情况, 这个是直观的一个结果; 正常情况下, 是和文件展开大小以及头文件引用个数是正相关的, 
cmake 通过指定环境变量能打印出编译和链接阶段的耗时情况, 通过这个数据能直观的分析出耗时情况。

set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE "${CMAKE_COMMAND} -E time")
set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK "${CMAKE_COMMAND} -E time")


① 头文件依赖关系及个数 ② 预编译展开大小及内容 ③ 各个文件编译耗时 ④ 整体链接耗时 ⑤ 可以计算出编译并行度。