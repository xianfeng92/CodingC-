
// !! 内联--站在性能的角度

'通过避免开销大的方法调用所带来的性能提升只不过是内联所能带来的性能提升的一半，而另一半则是调用间(cross-call)优化'。

调用间(cross-call)优化面向某一方法的调用过程, 基于对上下文场景更加全面的理解，使得编译器在源代码层面及机器代码层面对方法进行优化。这种优化的一般形式为:'在编
译期间进行一部分预处理, 从而避免在运行时重复类似的过程'。

比如，下面这段简洁的代码:

float x = 90.0;
...// x 的值并没有改变
float y = sin(x);

转换成如下代码:

float x = 90.0;
...// x 的值并没有改变
float y = 1.0;

从上例可以看到，变量首先在某一方法中初始化，之后以参数的形式传递给另一个方法，这种形式的调用或许很少出现在单个方法的上下文，但可以普遍存在于调用以及被调用方法的上
下文中。

为了分析这一问题，让我们通过下面这段代码换一种上下文环境:

enum TrigFun{SIN, COS, TAN};

float calc_trig(TRIG_FUNC func, float value)
{
    switch (func)
    {
        case SIN: return sin(value);
        case COS: return cos(value);
        case TAN: return tan(value);
    }
}

TrigFun get_trig_fun()
{
    return SIN;
}

float get_float()
{
    return 90;
}

void calculator()
{
    ...
    TrigFun tf = get_trig_fun();
    float value = get_float();
    reg0 = calc_trig(tf, value);
}

如果将 get_trig_fun、get_float 和 calculator 这三个方法全部定义为内联，那么上面这部分代码段将被解释为 reg0 = 1.0 这一条语句。

'但如果没有定义为内联，那么编译器将无法进行这种简洁明了的优化，这是由于所有与优化过程密切相关的信息都无法从单个方法中获得'，因此在这种条件下，只有针对单个方法
内部的优化是可行的。

这个简单的例子向我们展示了为了达到调用间优化这一目的，在不受内联自身因素影响的基础上, 内联如何协助编译器进行代码优化。

与避免方法调用这种简单的做法相比，'调用间代码优化更可能获得巨大的性能提升'。但从另一个角度来看，避免方法调用获得的性能提升是确定的，虽然有时效果并不尽如人意，
但这种做法具有普遍性。代码优化与编译器密切相关, 高层次的优化方法将会使编译过程变得漫长，实际上有时还会打乱代码。

针对性能优化的这两种方法可以打两个比方: '内联的调用间优化就好比寓言中的兔子，而避免方法调用则好比乌龟'。

有关编译器优化机理方面的讨论已超出了本书的范围，'但我们必须指出直接量在一些最为有效的性能优化中扮演了重要角色'。上一个例子就很好地阐述了这点，三角函数 sin() 
作为直接量在编译时被解释，体现出了直接量的作用。

如果直接量和相关变量在同一方法中定义和使用, 那么优化将变得轻而易举。但如果直接量以参数形式传递，那么优化将无法进行。

让我们一起来分析下面这段代码:

int i = 100;
...// 该区域未对 i 进行修改
if(i > 10)
{
    ...// 20 条指令
}
else
{
    ...// 50 条以上指令
}

将这段代码缩减为以下形式：

int i = 100;
...// 该区域未对 i 进行修改
...// 20 条指令


我们将原来的代码大小缩减了几百字节，与此同时移除了条件测试与分支语句。这并不意味着伟大的胜利，但这种做法的效果是显而易见的。或许您已经注意到，将 i 的值设置为 100
继而去测试其大小这种做法是愚蠢的，的确如此，尤其当这一做法出现在单个方法的上下文中时，更是如此。

但在很多情况下，变量通常在某个方法中被初始化，随后被传递至另一方法中。而在很多保护性程序例程中，对输入参数进行范围检测是十分常见的。

让我们一起来分析如下包含 case 语句的程序段：

inline
bool is_hex(char c, int& value)
{
    switch (c)
    {
        case '0': value = 0;break;
        case '1': value = 1;break;
        case '2': value = 2;break;
        case '3': value = 3;break;
        case '4': value = 4;break;
        case '5': value = 5;break;
        case '6': value = 6;break;
        case '7': value = 7;break;
        case '8': value = 8;break;
        case '9': value = 9;break;
        case 'a': value = 10;break;
        case 'b': value = 11;break;
        case 'c': value = 12;break;
        case 'd': value = 13;break
        case 'e': value = 14;break;
        case 'f': value = 15;break;
        default:return false;

    }
    return true;
}

采用现有的一些跳转表机制可以使这类条件判断方法变得更加高效，这样一来，在同样代码版本下进行范围检查将更快，但是这段代码阐述了一个重要观点，我们一般不应将这样一段
例程内联。'根据编译器的先进程度不同，这段代码将会被解释成为 10～100 条指令，看上去规模庞大'。即使按照最精简的方式，该例程也不可避免产生扩展性代码。作为输入参数
的直接量，我们可以反过来分析其在内联的 is_hex() 方法中产生了哪些影响。直接量参数使得编译器将某些方法简化成赋值语句，或许将方法看做是直接量的调用不太容易，但我
们可以先根据下面这段代码想象一下双重内联对其的影响:

inline
int parse_hex(char *cp)
{
    int ret = 0;
    int temp;
    while (is_hex(cp, temp)))
    {
        ret = (ret << 4) + temp;
        ++cp;
    }
    return ret;
}

int main()
{
    ...
    char* alpha_number  = "12345678";
    ...
    int bin_number = parse_hex(alpha_number);
    ...
}

一个好的编译器将会简化对 parse_hex() 的内联调用，将其转换为针对直接量整数 0x12345678 的简单赋值过程。这种情况下，原本在运行时执行的几百条指令在内联的作用下，
被替换成了一条立即数赋值指令。除此之外，在知道了 bin_number 相关信息的基础上，内联还可以产生额外的优化。

在内联方法与直接量的优化过程中，还存在着更复杂的可能性，为了阐述这一过程，我们将直接量传递给接收单个参数的递归方法，例如斐波纳契数列发生器，一种在学习递归时常用
的传统用例。

inline
int get_fib(int x)
{
    if(x < 0) return 0;
    if( x == 1 ) return 1;
    if( x == 2 ) return 1;
    else
    {
        return get_fib(x-1) + get_fib(x - 2);
    }
}

get_fib 利用直接量作为参数，它的执行结果可以在编译期解释。

举例来讲: get_fib(10) 在编译期可由直接量整数 55 进行替换，否则它将导致 109 次方法调用。

对于内联方法的编译期优化, 大多数编译器还无法完善在这一层面上的技术，但是在不久的将来，这类优化将变得相对易于实现。而在长期来看，这类优化将与内联相互独立开来，
它将会被简化为一项例程，尽管从目前来看，其代价有些昂贵并且还需要用到调用间优化。

希望大家从前面的阅读可以体会到，'有关内联的这类优化应是编译器的职责，而不是程序员的'。我们应该认同这一观点。大多数有意义的内联都具备选择性；也就是说，内联是方
法的可选项。直接量与内联方法之间的交互是个极好的例子。一旦某个方法的关键输入参数可以由编译器在编译期解释，那么编译器将很可能做出低耗且高效的优化。可惜的是，面对
方法调用的各类形式，这些优化并不具备通用性，它们超出了 C++ 基本内联的协议范围。


// !! 何时避免内联？

既然内联具备如此多的优点，我们为何不将所有方法皆定义为内联呢？

'这个问题看似简单答案却很复杂'。

解答这个问题之前，让我们先构想一种内联的情景。

假定在编译过程中, 我们将一个方法内联，此方法包含 550 字节的源代码。进一步假设这些源代码中有 50 字节与调用的起始和结束(方法调用开销)相关。如果此方法被静态调
用 12 次(12 次调用均在程序的不同位置)，那么我们因此将程序扩充了 5450 条指令((每次内联增加的 550 条指令-50 条方法调用开销指令)*12 -550 条其他被调用版本的指
令)，每次因内联得到的性能方面提升为 10%(假设此大规模方法包含 50 个时钟周期的调用开销以及 500 个时钟周期的执行开销。这里纯粹是假设；在一些方法中，即使同样都包
含 500 条机器指令，有一些需要平均 10 个时钟周期的执行时间，而有的将可能需要将近百万个时钟周期)。

由此看来我们将代码的尺寸增加了 10 倍，而每次获得的方法调用方面的性能提升是微小的。可想而知，当程序中所有能够内联的方法都进行内联, '代码膨胀将不可估量'，这将对性
能产生巨大的二次负面影响，如缓存命中问题和页面错误, 而这些将令我们的工作得不偿失。另一方面，滥用的内联程序将执行较少的指令，但会耗费较多的时钟周期。

'因此，不能内联全部方法的原因之一，就是内联所带来的代码膨胀有时是无法接受的'。

磁盘空间和内存容量的发展日新月异，对于它们而言，可执行镜像的大小已不再是什么问题，特别是虚拟内存管理机制的出现，为程序的执行开辟了一片新的天地。然而代码的尺寸不单纯
是一个存储问题。'单个内联方法拥有着多个实例, 而每个实例都要有自身的地址空间，因此它们消耗的缓存也相互独立，这样将减少有效的缓存空间而造成命中率下降'。举例来讲，假
设我们从程序的 4 个不同的位置等概率地调用一个内联方法。第一次程序的初始化调用(执行)内联方法必然导致缓存无法命中，出现代码缓存错误。当从另一个程序位置执行内联方法
时，由于内联代码的每个实例都各不相同，缓存将再次无法命中。即使是在程序相同位置调用内联方法，内联指令也将出现在进程代码空间的不同地址中。在我们所举的例子中，有 4 
处频繁的内联调用，内联方法占用缓存的大小将是其外联时的 4 倍。而内联也会比外联多出现 4 次以上的缓存错误。之所以是 4 次以上，是因为相对于外联方法的单个实例，内联方
法多个缓存实例被清除出并且需要重新加载的可能性更大。而外联实例使用率较高，从缓存中清除的可能性要小得多。

'内联产生的方法调用和返回方面的性能提升，可能会被因为内联而导致的缓存性能锐减所抵消，在涉及大规模方法时，这类问题尤为突出'。

内联的滥用导致的缓存错误会使性能锐减。假设执行流的工作页面集合恰好填满处理器的缓存；换句话说，指令流几乎不会出现缓存错误，这是由于负责绝大部分程序执行的程序代码空
间已加载进入缓存。如果此时我们不加选择地运用内联将工作页面集合增大两倍，则增加的代码路径将频繁地产生页面错误，原因就是现有的缓存无法容纳所有需要的工作页面集合。
不断出现的缓存错误将严重影响性能，由此产生的负面影响将使得通过避免方法调用而获得的性能提升不复存在。

'综上所述，代码膨胀所带来的副作用可能是无法承受的，而这就是不能内联全部方法的第二个原因'。

内联所引发的代码膨胀现象有时会导致另一类退化特征。将某个方法内联可能会导致指数级的代码膨胀。这种现象通常会发生在相对大规模的例程互相内联的情况下。如下例所示
，A、B、C、D 为 4 个包含了 500 字节指令的方法。


int D()
{
    ...// 共 500 个字节的指令代码
}

int C()
{
    D();
    ..// 共 500 个字节的指令代码
    D();
}

int B()
{
    C();
    ...// 共 500 个字节的指令代码
    C();
}

int A()
{
    B();
    ...// 共 500 个字节的指令代码
    B();
}

int main()
{
    A();
    A();
    A();
    A();
    A();
    A();
    A();
    A();
    A();
    A();
}


A 方法调用 B 方法 2 次，B 方法调用 C 方法 2 次，C 方法调用 D 方法 2 次，main 方法调用了 A 方法 10 次。如果将 A、B、C 和 D 这 4 个方法内联，代码将增加 70KB
。在实现同等功能的情况下，代码膨胀了 37 倍。尽管上述例子很简洁，现实生活中也很难遇到相同情况，但它向我们阐明了滥用内联将会造成代码爆炸这一事实。这类代码膨胀是难以
接受的，而这就是不能内联全部方法的第三个原因。

如果回顾一下前面几页，您可能会对自己说：“嗨，避免内联的三个原因本质上是同一个。”您的想法完全正确。如果还未意识到这点，那一定是由于注意力还不够不集中，或许该来点咖
啡振奋一下了。'代码膨胀是不能内联所有方法的最主要的原因'。随着编译器效能的提升，在内联方法中，编译器解析局部静态元素的能力将进一步加强。正因如此，代码膨胀所产生
的影响将愈加显著。

这里还要介绍另外一些不能内联的原因，特别是在大规模工程及运用复杂方法的情况下不能内联的原因。内联方法不仅在实现层面会产生编译依赖，在接口层面亦然。正因如此，'对于在
程序开发阶段经常发生变动的方法，不应将其列入可内联的范畴'。

可以用一条规则来总结:'能够缩减代码大小的内联都是可取的，而任何显著增大代码大小的内联都是不可取的'。第二条有用的规则: '如果方法的实现是易变的，则不应将其内联'。


不能内联全部方法还存在另一点原因，就是有些方法本身应避免内联: 例如递归方法。

假设某方法 A 调用其自身。如果将 A 方法内联，编译器会不断循环尝试将 A 方法插入至 A 方法中，形成死循环(实际上，某些智能化程度较高的编译器能够将递归函数内联，特别
是在控制递归变量以直接量形式传递的情况下)。因此通常应避免递归方法内联。

// !! 开发阶段及编译期的内联考虑

'从逻辑上讲，内联方法应定义在其类的头文件中'。这对于使用内联方法代码体的那些调用者是必要的。不幸的是，一旦内联方法的内容有所改变，都将导致用到内联方法的相关模块
重新编译——请注意是重新编译，而不只是重新连接。对于大规模程序来说，由于每次编译都会带来额外的时间消耗，这无疑增加了程序的开发时间。

'针对内联方法的调试较为复杂，因为单个断点无法跟踪内联方法的入口和出口'。虽然会降低调试器的性能，但是利用观察点可以达到同样的目的。然而当变量名横跨调用者与被调用
者的代码边界时，跟踪变量名将很困难。


内联方法通常并不出现在程序的配置表中（配置表基于某些示例程序的模板，显示程序的执行行为）。配置表有时无法察觉对内联方法的“调用”。一旦某方法被内联，我们就应假定当
包含其的方法被执行时，则此内联方法将一并执行，尽管某些情况下并非如此。这种假定使性能度量决策的复杂程度大大增加。

正常工作的编译器不会因为内联的副作用而产生错误。相反，编译器软件极其庞杂，C++ 也是一门较为复杂的语言。因此在短期内，理想的无差错的 C++ 编译器似乎并不存在。因此
就会出现这样一种可能：内联的优化过程本身将产生错误。从内联角度来讲，这种情况的出现概率较小，这是因为编译器对于所接受的内联请求可以自由地决定其复杂度。另一方面，
由内联所引发的错误，如同大多数编译器所产生的错误一样难以发觉。


// !! 基于配置的内联

采用内联策略后，效果有时微不足道，但有时又会产生实实在在的积极效果，对于某些递归方法而言，它们都迫切需要利用展开方法调用这一手段以提高性能。然而事实上，有时我们
可能费尽心思将内联应用于程序，而这种做法使程序大小和编译时间显著增加，但由此得到的性能提升却十分微小，有时甚至会降低性能。但反过来看，我们或许可以内联某些重要的
方法，以此得到显著的性能提升。

'综上所述, 一类做法是徒劳地内联那些无意义的方法，另一类则显著提高程序速度，而造成差异的成因在于是否选择了适于内联的方法'。

'配置是寻求适合内联的方法的最佳手段, 尤其当我们拥有可以用来产生配置数据的代表性数据样本时, 配置的优势将会更加明显'。


'如果某方法的调用频率高、代码数量小而且动态变化，将其内联会获得显著的性能提升'。


对于高调用频率的方法：

1. 大规模(20 行以上的代码量)----> 重写方法，体现出快速途径并将其内联

2. 中等规模(5 ~ 20 行代码量)----> '将高频率的调用点，选择性内联'

3. 小规模(小于 5 行的代码量) ----> 内联


'请时刻谨记，二级缓存与换页问题是代码膨胀的副产品'。


举例如下:

int x::y(int a, int b)
{
    if(/*检查输入值 a 与 b*/)
    {
        ...// 将错误处理部分内联--30 行代码
    }
    ...// 实际工作 5 行代码
}

方法 x::y 大约包含了 40 行代码，规模较大。如果方法的调用频率较高，并且具有相当多的调用点，那么通过初步判断得知，将 x::y 法内联的效果并不太好。它所包含的代
码映射大小预计会超过 1KB，如果它不是一个叶节点，将其内联会造成组合性代码爆炸，这些我们先前已经有所提及。

反过来看，x::y 内部隐匿着另一个方法, 如果将其内联效果将非常好。让我们一起来分析下将 x::y 分割成两个方法后的情况:

void x::handle_input_error(int& a,  int& b)
{
    ...//30 行代码
}


inline int x::new_y(int a, int b)
{
    if(/*检查输入值 a 与 b*/)
    {
        handle_input_error(a, b);
    }
    ...// 实际工作 5 行代码---其实要是高频调用点
}

方法 new_y() 的代码大小被缩减至 10 行。尽管剩余数量并不算少, 但作为内联方法已经足够了。'而要凸显内联的高效性，其输入参数的错误率不能太高'。这种重写的做法对于
内联而言是有效的, 但是它只对小规模的方法有效，而且仅限于动态的小规模方法，对于大规模的静态方法，这种做法是无效的。

'重写这类方法，可以在不显著增加代码大小情况下令性能得到质的飞跃'。

// !! 内联规则

运用几条简洁明了的规则便可以做出内联决策。

'合适的代码大小以及性能收益往往源自于方法的唯一化与精简化'。精简化使得方法可以在不考虑使用频率的情况下内联， 唯一化使得方法在适当的使用频率下内联。


// !! 唯一化

'唯一化(singleton)方法是指方法在程序中的调用点是唯一的，而它并不代表方法在程序执行过程中只被调用一次'。

某个方法或许会出现在循环中，被成千上万次调用，但是只要其在程序中的调用点唯一，我们就称其为唯一化方法。唯一化方法具备与生俱来的内联特性。'唯一的调用点意味着我们
不需要考虑方法的大小和调用频率', 对于内联后的唯一化方法，其代码将比原先更小，运行更快。或许由此获得的性能提升并不明显，但是有一点要清楚，我们在内联方面付出的努
力并不总是能带来性能上的提升。

一般来说，唯一化方法的鉴别较为困难，方法的唯一化往往是临时的，并且与环境相关，而有时，唯一化是设计的产物。后者可以被显式内联，而对于前者，我们需要监视其唯一化特性
以避免负面效果。

'如果编译器能为我们自动识别和内联所有唯一化方法, 那就再好不过了'。

遗憾的是，为了达到这种目的，需要对程序的调用树进行全局分析。虽然全局调用树的产生方式并不烦琐，但如果程序囊括了大量的独立编译模块，全局分析的代价将会十分高昂。当然对于这种类型的分析过程，并不是在代码开发和调试阶段完成的，它的确可以作为一种有意义的维护期优化。必须提醒的是，针对大型程序的这类分析将耗费大量的处理器周期——在等待的时候可以看点书（或许你需要带一本托尔斯泰的小说）。











