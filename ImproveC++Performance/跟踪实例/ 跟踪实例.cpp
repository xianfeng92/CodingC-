
// !! 跟踪实例

'我们所使用过的每个软件产品都会包括这样或那样的跟踪功能。当代码超过几千行时，跟踪功能就显得很重要了'。调试、维护和理解大中型软件的执行流程是很关键的。
在很多情况下，会由于跟踪的实现不当，导致软件性能严重下降。'即使些许的低效也会对性能造成巨大的影响'。

许多 C++ 程序员在跟踪代码时通常的做法是，定义一个简单的 Trace 类将诊断信息打印到日志文件中。程序员可以在每个想要跟踪的函数中定义一个 Trace 对象，
在函数的入口和出口 Trace 类可以分别写一条信息。'尽管 Trace 对象将增加程序额外的执行开销，但是它能够帮助程序员找出问题而无须使用调试器'。

最理想的跟踪性能优化的方法应该能够完全消除性能开销, 即把跟踪调用嵌入在 ＃ifdef 块内：

#ifdef TRACE
Trace t("myFunction");// 构造函数以一个 函数名作为参数
t.debug("Some Information Message");
#endif // TRACE

使用这种方法的不足在于必须重新编译程序来打开或关闭跟踪。无疑您的客户根本无法这样做，除非您像免费软件那样同时将源代码公布给他们。

还有一种选择: 您可以通过与正在运行的程序通信来动态地控制跟踪。Trace 类能够在记录任何跟踪信息之前先检查跟踪状态:

void Trace::debug(string& msg)
{
    if(traceIsActive)
    {
        // 在此记录消息
    }
}

在跟踪处于活动状态时我们并不关心性能。这里假定仅仅在需要确定问题时才打开跟踪。跟踪在通常的执行中默认处于非活动状态，我们希望自己的代码此时表现出最好的性能。
为了达到这个要求，必须使跟踪的开销最小化。

下面是一条典型的跟踪语句：

t.debug("x  = " + itoa(x));// 函数 itoa(x) 把一个 int 转换为 ASCII

这条典型的跟踪语句表现出一个严重的性能问题。即使关闭了跟踪，我们仍然要创建 string 参数来传递给 debug() 函数。

这一条语句就隐含着大量计算:

1. 为“x=”创建一个临时 string 对象

2. 调用 itoa(x)

3. 从 itoa() 返回的字符指针创建一个临时的 string 对象

4. 连接上述 string 对象进而创建第三个临时的 string 对象

5. 在 debug() 调用返回后销毁全部三个 string 临时对象


因此，我们把所有的问题归咎到三个临时 string 对象上，接着在跟踪处于非活动状态时把它们全部销毁。创建和销毁这些 string 和 Trace 对象的开销至少为几百条指令。
在典型的面向对象的代码中，函数短小且调用频率很高，那么跟踪的开销很容易使性能下降一个数量级。这并不是牵强的主观猜测。事实上我们在一个实际的产品中有这种经验。
深入钻研这种糟糕透顶的经历，会带给我们很多充满教育意义的启示。我们当时要想办法在一个包含 50 万行 C++ 代码的复杂产品中添加跟踪功能。而我们的第一次尝试事与
愿违，因为性能过于糟糕。


// !! 初步跟踪的实现


我们想要让 Trace 对象记录一些事件消息，比如进入某个函数，离开某个函数，以及其他介于这两者之间的某些重要信息。

int myFunction()
{
    string name("myFunction");
    Trace t(name);
    ...
    string moreInfo("more intersting info");
    t.debug(moreInfo);
    ...
}// 跟踪析构函数，将退出事件记到一个输出流中

我们用下面的 Trace 类来实现上面的功能：

class Trace
{
public:
    Trace(const string &name);
    ~Trace();
    void debug(const string &msg);
    static bool traceIsActive;
private:
    string theFunctionName;
};

附加信息通过调用 debug() 方法记录到日志中。

inline Trace::debug(const string &msg)
{
    if(traceIsActive)
    {
        cout << msg << endl;
    }
}

一旦 Trace 类被设计、编码和测试好以后，它就被部署并快速插入到大部分代码中。'在关键执行路径的大多数函数中突然出现了 Trace 对象'。在紧接着的性能测试中，
我们震惊地发现性能陡然降为原来性能的 20%。Trace 对象的插入把性能降至原来的 1/5。这里我们讨论的是“关闭跟踪且假定性能不受影响”的情况。


// !! 到底怎么了？

基于各自不同的经历, 程序员们可能对 C++ 的性能有不同的理解。但是有几个公认的基本原则:

1. I/O 的开销是高昂的

2. 函数调用的开销是要考虑的一个因素，因此我们应该将短小的、频繁调用的函数内联

3. 复制对象的开销是高昂的。最好选择传递引用，而不是传递值

我们最初实现的 Trace 遵循这三个原则。如果关闭跟踪，而且所有方法都是内联的，所有的 string 参数也都是按引用传递的，就可避免 I/O 操作。我们严格地遵守规
则但仍然未能如愿。很显然，先前的规则中所体现的集体智慧没有击中开发高性能 C++ 所要求的专门技术的要害。

我们的经验说明，这三条原则没有涵盖影响 C++ 性能的决定性问题，即创建（和后面的销毁）预计要使用但却没有使用的不必要的对象。'Trace 实现就是一个无用对象对性
能带来破坏性影响的实例'，即便是对 Trace 对象最简单的调用，这一点也能明显体现出来。对 Trace 对象最低限度的使用就是把进入函数和离开函数记录到日志中:

int myFunction(int x)
{
    string name = "myFunction";
    Trace t(name);
    ...

}

这种最低限度的跟踪引发了一系列计算：

1. 创建一个作用域为 myFunction 的 string 型变量 name

2. 调用 Trace 的构造函数

3. Trace 的构造函数调用 string 的构造函数来创建一个成员 string

4. 在作用域的结尾，也就是函数的结尾，Trace 对象和两个 string 对象被销毁；销毁 string 型变量 name；调用 Trace 的析构函数；Trace 的析构函数为
   成员 string 调用 string 的析构函数

'在跟踪被关闭的情况下，string 的成员对象从未被使用。有时也可能会遇到 Trace 对象本身没被使用（在关闭跟踪的情况下）的情况'。这时，所有那些用于对象的创建
和销毁的计算都是纯粹的浪费。要记住，这种开销是在关闭跟踪情况下产生的。这可是我们假想的快车道。   

那么究竟代价有多大呢？ 为了找出基准度量，我们对函数 addOne() 的百万次迭代执行进行了计时:

int addOne(int x)// 版本 0
{
    return  x + 1;
}

正如您所知，addOne() 几乎不做什么，它就是一个基准点。我们试图一个一个地分离出影响性能的因素。我们在 main() 函数中调用 addOne() 100 万次，并测试执行
时间:

int main()
{
    Trace::traceIsActive = false; // 关闭跟踪
    //...
    GetSystemTime(&t1);
    for (int i = 0; i < j; i++)
    {
        y = addOne(i);
    }
    GetSystemTime(&t2);
    ... 
    return 0;
}

下一步，为了评估性能变化，我们在 addOne 中添加一个 Trace 对象并重新测量。

int addOne(int x)// 版本1，引入 Trace 对象
{
    string name = "addOne";
    Trace t(name);
    return  x + 1;
}

for 循环的开销从 55ms 猛增至 3500ms。换句话说，addOne 的速度陡然下降了 60 倍以上。'这种类型的开销对任何软件的性能都将造成严重破坏'。这样的跟踪成本显
然是我们无法接受的，但是完全取消跟踪又不可行，我们需要有某种形式的跟踪功能。因此我们不得不重新思考并提出一种更为有效的实现。

// !! 恢复计划

'这个性能恢复计划的目标是在跟踪关闭时消除没有价值的对象和计算'。我们从 addOne 创建的并传递给 Trace 构造函数的 string 参数入手。我们把函数的 name 参数
的类型从 string 对象改成简单的 char 型指:

int addOne(int x)// 版本 2，放弃字符串对象，用一个字符串指针取而代之
{
    char *name = "addOne";
    Trace t(name);
    ...
}

与此同时，为了让 Trace 的构造函数接收 char 型指针参数而不是 string 对象引用，我们必须修改这个构造函数：

inline Trace::Trace(const char *name):theFunctionName(name)// 版本 2
{
    if(traceIsActive)
    {
        cout << "Enter function" <<  name << endl;
    }
}

同样 Trace:: debug() 方法也要修改，它也要接收一个const ＊ char 而不是 string 作为输入参数。'现在不必在创建 Trace 对象之前创建 string 型对象
name 了——需要考虑的对象少了一个'。这种做法提高了性能，而且在我们的测量结果中效果很明显。执行时间从 3500ms 下降到了 2500ms。

第二步是消除包含在 Trace 对象内的 string 成员对象的无条件的创建。从性能的观点出发，我们有两种等价的解决方案。第一种是把 string 对象替换成一个简单 char
型指针。char 型指针通过简单的分配就可“创建”，没什么开销。另一种解决方案是使用复合代替聚合。我们换用 string 指针而不是把 string 子对象嵌入到 Trace
对象里面。string 指针与 string 对象相比有一个优势：我们可以把 string 的创建推迟到确定跟踪处于打开状态以后。所以我们选择使用这种解决途径。

class Trace
{
public:
    Trace(const char* name)
    {
        if(traceIsActive)
        {
            cout << "Enter function " <<  name << endl;
            theFunctionName = new string(name);
        }
    }
    ~Trace();
    void debug(const string &msg);
    static bool traceIsActive;
private:
    char *theFunctionName;
};


第三次测试中出现重大的性能改善。响应时间从 2500ms 下降到了 185ms。

到此为止，我们已经实现了目标。我们把 Trace 的开销从 3500ms 降到了 185ms。您可能仍然觉得 185ms 与根本没有跟踪逻辑时的 55ms 相比还是相当糟糕。性能下降了
3 倍多。

我们又怎能自称胜利了呢？

关键在于原来的 addOne  函数所做的工作非常少。它把输入的参数加 1 后立即返回。在 addOne 中加入的代码都会对它的执行时间产生深刻的影响。如果用4 条指令去跟踪
2 条指令，就会使执行时间增加至原来的 3 倍。相反，如果将 4 条指令添加到一条已包含 200 条指令的执行路径中，那么只会使执行时间延长 2%。如果addOne 由更多的
复杂计算组成，那么添加 Trace 后对其执行时间的影响将接近于零。

在某些方面，这与内联很相似。'内联对大块头函数的影响是无足轻重的'。只有在针对那些调用和返回开销占全部开销的绝大部分的小型函数时，内联对性能的改善才有比较大的
影响。完美适合内联的函数就恰好是非常不适合跟踪的。由此可以得出结论:'Trace 对象不应被添加到小型的、频繁执行的函数中'。


// !! 要点

1. '对象定义会触发隐形地执行构造函数和析构函数'。我们称其为“隐性执行”而不是“隐性开销”，是因为对象的构造和销毁并不总是意味产生开销。如果构造函数和析构函数
    所执行的计算是必须的，那么就要考虑使用高效的代码(内联会减少函数调用和返回的开销)。就像我们所看到的那样，构造函数和析构函数并不是总是具有如此“完美的”特
    性，而且它们能够产生可观的开销。某些情况下，构造函数(或析构函数)所执行的计算是无用的。我们还应当指出，这个问题不止是一个  C++ 语言编程的问题，更是一个
    设计问题。不过，因为 C 不支持构造函数和析构函数，所以这种现象在 C 中比较少见。

2.  正是因为通过引用传递对象还是不能保证良好的性能，所以避免对象的复制的确有利于提高性能，但是如果我们不必一开始就创建和销毁该对象的话，这种处理方式将更有利
    于性能的提升。

3. 不要把精力浪费在计算结果根本不会被使用的地方。当关闭跟踪时，string 成员的创建就是一种无用而高代价的开销

4. 别打算创造设计灵活性的世界纪录。'您的设计只需要在当前问题范围之内足够灵活就可以了'。在完成同样的简单工作时，char 指针有时可以比 string 对象更有效率

5. '内联消除了常被使用的小函数调用所产生的函数开销'。内联 Trace 的构造函数和析构函数使得消除 Trace 的开销变得更加容易




















