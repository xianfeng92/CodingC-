// !! 系统体系结构相关话题


// !! 存储器层级

所有对性能的讨论最终都会集中到存储器使用和存储器使用模式上。'通常来说, 算法复杂度最核心的方面是算法需要的存储器访问量和访问类型, 而现在的情况是计
算速度很快但访问速度很慢, 这是毫无疑问的事实'。

通常来说, 一般的计算机都至少有 5 个存储器层级, 而一些主要的存储器层级有时还包含子层级。'存储器层级从最快(访问时间最短)到最慢(访问时间最长)其排序
为: 寄存器、L1(第一级)芯片内缓存、L2(第二级)芯片外缓存、主存(半导体动态随机访问内存:DRAM,SDRAM,RAMBUS,SyncLink等等)、磁盘存储器'。一些新的处
理器拥有两级芯片内缓存, 从逻辑上看, 我们可以把它们当成一个 L1 缓存, 其本身也是由一个容量较小却速度极快的存储器和容量较大而速度稍慢的存储器组成。大
多数磁盘存储器现在都有自己的本地缓存, 带有这样的磁盘存储层级的系统由两个子系统构成:一个相对较快而容量小, 另一个相对较慢却容量巨大。


很多人仅根据访问时间和处理器速度来研究内存访问。然而, 这种观点忽视了延时和带宽的交互作用。访问时间是一个延时问题: 获取数据要多长时间? 总线宽度和脉
冲时间是带宽问题: 当数据到来时, 一次可以获取多少数据? 这与消防水带的概念类似: 打开阀门要多长时间? 每秒可以喷出多少水? 在水箱里有多少水?


延迟并不会和带宽以同样的比例改善, 或者说, 我们可以用较快的速度移动数据块, 但是, 访问内存中的单个字节的速度提升很慢。例如, 过去5年以来(1999 年左右)
处理器的速度从 90MHz 提升到 500MHz,  但主存的访问时间仅仅从 120ns 降低到 50ns(即使是最快的 8ns SDRAM, 其首次访问也要 6 个时钟周期)。这意味着
处理器的速度提升了 5 倍, 但内存只提升了 2.5 倍。与此相反, 内存带宽提升得更快, 跟上了处理器的性能发展。在过去的  5 年里, 内存带宽已经翻了一番,当
前 DRAM 的突发式存取特性显著增加了有效内存带宽。磁盘存储器的情况与此相似, 访问速度增长较慢, 而带宽却增长得快一些。


// !! 寄存器:存储器之王

'在存储器层级上的所有实体中, 寄存器延迟最短, 带宽最高, 开销最小'。

寄存器的直接寻址特性使得它们很难作为大型的存储器映射的中间层。直接寻址为访问寄存器带来了极高的速度,但也使得将数组存入寄存器以及动态索引它们(不用自
行修改代码, 这是一个很诱人的方法, 但对人们来说很困难)变得不可能。很难创建一个指针指向存放在寄存器中的变量。

保留字 register 告诉编译器, 不要把变量放在内存或者更精确地说, 不要给变量分配内存地址。这只是一种建议, 如 inline 保留字一样, 编译器可能不理会。
一些编译器会完全忽略寄存器指令。'这时只能假设这些编译器作者确信他们的寄存器分配算法会优于程序员的选择', 这种假设在某些情况下成立, 但在其他情况下往
往不是如此。


在理想的情况下, 内联应该由编译器自动完成和优化。这对于在寄存器里的变量亦然。在寄存器分配, 或者变量基于哪一个寄存器寻址等问题上, 编译器应该比程序员
做得更好。如果编译器可以充分利用优化信息, 根据这些信息对每个方法的执行路径做出合理的判断, 就可以在寄存器分配上做出更好的优化。这似乎是一些编译器作者
所努力的方向, 我们应该鼓励他们。正如前面所说的, '我们确信经过优化的编译器可以提供自动的优化过程, 同时可以将程序员从具体的、低层次的优化工作中解放出
来'。程序员应该去关心类的实现, 而不是将时间浪费在低层次的寄存器问题上。'遗憾的是, 很多编译器还是不能很好的解决寄存器优化问题, 借助程序员的帮助仍旧是
很平常的事情'。

下面 3 个方法: a、b和c, 每个都包含一个局部变量 i, 其中 a 方法的 i 应该放入寄存器, 而 b 方法的 i 则相反, c 方法的 i 放不放在寄存器中都不是一个
好的选择, 这些都依赖于我们对该方法的执行路径的理解。

int x::a(int x, int& y)
{
    int i = -x + y;
    y = i - 10;
    i = x;
    y -= i;

    return i + 10;// 
}

int x::b(int x, int& y)
{
    int i = -x;
    y = test(x);
    y = -y;
    int j = test(y);
    y = -j + 12;
    cout << j << endl;
    return i + j;
}







