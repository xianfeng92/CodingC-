
// !! 标准模板库

标准模板库(Standard Template Library，STL)是容器和通用算法的强效组合。

如果从性能角度来思考, 几个问题就会立刻跃入我们的脑海:

1. 在'渐近复杂度'方面，STL 与各种容器和算法的性能密切相关。这到底是什么意思？

2. STL 由很多容器组成。'那么当面对一个具体的计算任务时，应该使用哪种容器'？ 另外，对于特定的情况，还存在更好的选择吗？

3. 'STL 的性能如何'？如果使用自定义的容器和算法，能否做得更好？


// !! 渐近复杂度

'算法的渐近复杂度是对算法性能的近似估计'。它是算法集到特定性能标准集的映射。如果需要对包含 N 个整数的向量的所有元素求和，那么每个整数必须且仅需检查一次，
因此该算法的复杂度约为 N，我们将其称为 O(N)。

另一方面，假设需要创建一个包含 N 个元素的向量，由于某种原因，您需要将这些元素插入到该向量的前端。然而，在向量的前端每插入一个元素便会迫使所有已存在的元素移
动 1 个位置。这就导致了(1+2+3+...+N)次向量元素的移动，也即 (N/2)(N+1) 次移动。即使需要移动 (N*N/2)+(N/2) 次，但我们仍说这个算法的复杂度是 O(N*N)。

'这是因为渐近性能标准集将忽略常量倍数和低阶因子'。因而 N*N 和 7N*N 的复杂度相同：均为 O(N*N)。

由此可以看出，渐近复杂度是一种比较粗糙的近似估计。尽管它对于应用数学家们研究算法复杂度来说已经很完美了，但对于我们程序员来说还是不够的，我们仍然需要关注常量
倍数。对于我们来说，复杂度为 2N 的算法和复杂度为 4N 的算法是不同的，前者比后者足足快了一倍。

'STL 对其算法渐近复杂度的保证是一个良好的开端。它告诉我们，所使用的算法是同类算法中最好的'。然而我们仍然需要探讨一下被数学家忽略的常量倍数和低阶因子问题。当
然我们不会讨论所有容器的所有操作，我们只会讨论一些常用容器上的常见操作，下面将从插入操作开始进行论述。

// !! 插入

'如果性能关键路径中包含了往容器中插入大量元素的代码，那么应该使用哪种容器呢'？

为了弄清楚该问题，我们将对一些容器进行测试并讨论测试结果。本次插入练习将把 100 万个随机元素插入到数组、向量、列表和多重集中。

每个插入测试带有三个参数:

● 指向被测目标容器的指针
● 指向 data 数组的指针，该数组保存了要插入到目标容器中的元素
● data 数组大小




