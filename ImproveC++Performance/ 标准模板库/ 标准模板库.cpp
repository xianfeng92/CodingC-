
// !! 标准模板库

标准模板库(Standard Template Library，STL)是容器和通用算法的强效组合。

如果从性能角度来思考, 几个问题就会立刻跃入我们的脑海:

1. 在'渐近复杂度'方面，STL 与各种容器和算法的性能密切相关。这到底是什么意思？

2. STL 由很多容器组成。'那么当面对一个具体的计算任务时，应该使用哪种容器'？ 另外，对于特定的情况，还存在更好的选择吗？

3. 'STL 的性能如何'？如果使用自定义的容器和算法，能否做得更好？


// !! 渐近复杂度

'算法的渐近复杂度是对算法性能的近似估计'。它是算法集到特定性能标准集的映射。如果需要对包含 N 个整数的向量的所有元素求和，那么每个整数必须且仅需检查一次，
因此该算法的复杂度约为 N，我们将其称为 O(N)。

另一方面，假设需要创建一个包含 N 个元素的向量，由于某种原因，您需要将这些元素插入到该向量的前端。然而，在向量的前端每插入一个元素便会迫使所有已存在的元素移
动 1 个位置。这就导致了(1+2+3+...+N)次向量元素的移动，也即 (N/2)(N+1) 次移动。即使需要移动 (N*N/2)+(N/2) 次，但我们仍说这个算法的复杂度是 O(N*N)。

'这是因为渐近性能标准集将忽略常量倍数和低阶因子'。因而 N*N 和 7N*N 的复杂度相同: 均为 O(N*N)。

由此可以看出，渐近复杂度是一种比较粗糙的近似估计。尽管它对于应用数学家们研究算法复杂度来说已经很完美了，但对于我们程序员来说还是不够的，我们仍然需要关注常量
倍数。对于我们来说，复杂度为 2N 的算法和复杂度为 4N 的算法是不同的，前者比后者足足快了一倍。

'STL 对其算法渐近复杂度的保证是一个良好的开端。它告诉我们，所使用的算法是同类算法中最好的'。然而我们仍然需要探讨一下被数学家忽略的常量倍数和低阶因子问题。当
然我们不会讨论所有容器的所有操作，我们只会讨论一些常用容器上的常见操作，下面将从插入操作开始进行论述。

// !! 插入

'如果性能关键路径中包含了往容器中插入大量元素的代码，那么应该使用哪种容器呢'？

为了弄清楚该问题，我们将对一些容器进行测试并讨论测试结果。本次插入练习将把 100 万个随机元素插入到数组、向量、列表和多重集中。

每个插入测试带有三个参数:

● 指向被测目标容器的指针

● 指向 data 数组的指针，该数组保存了要插入到目标容器中的元素

● data 数组大小

'数组和向量均为占用连续内存块的顺序容器'。当无法事先确定集合大小时，向量将会更有用。向量是可以动态增长的，这样程序员就不用考虑集合的大小。

为了更好地理解向量和数组在性能上的差异，我们首先必须分清向量大小和向量容量这两个概念。向量的大小是指向量当前拥有元素的数量。向量的容量是指向量能够容纳元素数量的最
大值，超过这个值，向量就必须分配更多的内存以适应元素的增长。当往向量中插入第一个元素时，为了使向量的容量超过它的初始大小(值为 1)，典型的 STL 实现将会分配一大块
内存。后续的插入将会增加向量的大小，而容量保持不变。'如果集合持续增长，那么向量大小最终将会达到它的容量'。

下一次插入操作将会迫使向量的实现扩大自身容量。这必须包含以下几个步骤:

● 分配更大的内存块，以便为增加的元素留出空间
● 将当前集合中现存的所有元素复制到新分配的内存中。在该过程中，会为旧集合的每一个元素调用拷贝构造函数
● 销毁旧集合并释放它所占用的空间。在该过程中，会为旧集合中的每一个元素调用析构函数


这些步骤可能会引起巨额开销。因此，我们希望尽可能少地出现向量大小超过其容量的情况。尽管分配和释放内存已经足够糟糕了， 但为旧集合中的每个元素调用拷贝构造函数和析构
函数会付出更加昂贵的代价。

向量元素调用未精简化的构造函数和析构函数方法时就会发生这种情况。例如，我们用 BigInt 对象集合替换掉整数集合再次进行测试。

为了测试向量容量增长对性能的影响，我们再次对向量进行插入测试，但是这次使用 BigInt 对象代替整数元素。性能上的惊人差异清晰地反映了整数和 BigInt 对象在进行复
制和销毁操作时所产生代价的差异。如果您发现自己正处于以下这种情况: '对象的拷贝构造函数和析构函数开销相当昂贵，并且向量的容量很有可能继续增长，那么您仍可以通过保存
指针而不是对象来设法避免这种昂贵的代价'。

列表容器并未将元素存储在连续的内存空间中，所以也就无须应付容量问题和相关的性能开销问题。因此，在 BigInt 的插入测试中列表容器优于向量容器。

每个容器都有自己的优点和缺点。尽管在插入 100 万个整数的测试中向量优于列表，但是在使用 BigInt 对象的测试中列表却胜过向量。

'为了解决由向量的容量增长带来的性能难题，我们可以采用下面这种可选的解决方案'。

在很多情况下，我们可以对在特定情况下要尽可能足够大的向量容量进行估计。在您有把握做出恰当估计的情况下，我们可以执行这种方案，并预留好必要的容量。
向量中的 reserve(n) 方法可以保证向量的容量等于或者大于 n 个元素。该方案需要修改测试程序中的一行代码:

    vector<int> *vec = new vector<int>;
    vec->resize(1000000);

预留所需的容量使得性能提升了 2 倍多。

迄今为止，我们已经对数组、向量和列表的尾部进行了元素插入操作。'在集合大小事先可知的情况下，数组容器性能最佳。在集合大小未知的情况下，当插入整数时，向量容器优于列
表容器'。

如果我们需要在集合中间或者前端添加元素，那么哪种容器会表现得最好呢？ 

这可能会将之前的结果颠倒过来。接下来，我们就针对将元素插入到容器前端的任务对向量和列表的性能进行比较。我们使用了下面这两个函数

'向量容器在进行前端插入时的性能极其糟糕，因此我们不得不把集合大小限定为 10，000'。每次在向量前端插入元素时均会使所有已有元素进行移动，以便为新元素留出空间。

这种实现的复杂度为 O(N*N)，其中 N 是集合的大小。换句话说，集合大小变为原来的 10 倍将会导致执行时间变为原来的 100 倍。因为我们根本没有那么多的时间，所以我们
将测试限定为 10，000 个元素。'与之相反，对于列表容器来说，无论集合多大，在前端插入一个元素均花费相同的时间'。

最后的这个测试突出了 STL 的另一个性能优势： 'STL 的设计会阻止您做出一些相当愚蠢的事情，比如当需要在前端插入元素时却选择向量容器'。由于这个原因，STL 没有为向量
容器提供 push_front() 方法。如果真的要坚持做这种低效的事情，那么您将不得不亲自实现，就像我们在 vectorInsertFront() 代码中做的那样。


// !!  删除

删除操作的性能情况在很多方面都与插入操作很类似。很多关于插入效率的结论同样适用于删除。例如:

● 向量擅长于在尾部对元素进行插入(或删除)操作。因为这种操作与集合大小无关，所以它是一种固定时间的操作

● 除了尾部操作之外，采用向量进行其他任何位置的插入(或删除)操作都是一种极为糟糕的选择。这种插入(或删除)的代价与插入(或删除)点到向量的最后一个元素之间的距离
  成正比例。

● 双向队列在集合的前端和尾部插入(或删除)元素时效率很高(常数时间)，在其他任何位置插入（或删除）元素时效率都很低

● 列表在集合的任何位置插入(或删除)元素时效率都很高(固定时间)

作为一种全面的研究，我们测试了从向量和列表中删除 100 万个元素的情况。对于列表和向量，我们均使用了 STL 提供的 pop_back() 方法。pop_back() 方法用于删除容器
中的最后一个元素。

 » g++ --std=c++11 DeletePerforTest.cpp
--------------------------------------------------------------------------------
 » ./a.out 
vector delete cost time is 0.000337 seconds
vector delete cost time is 0.000586 seconds


正如插入操作一样，当从尾部删除元素时，向量胜过列表。那么从前端删除元素会如何呢 ？ 如果与插入操作完全类似，那么应该将向量和列表之间的性能比较结果颠倒过来，即列
表胜过向量。测试程序如下:
 » g++ --std=c++11 DeletePerforTest.cpp
--------------------------------------------------------------------------------
 » ./a.out 
vector delete cost time is 0.000336 seconds
vector delete cost time is 0.000515 seconds
Test delete front element
vector delete front cost time is 0.004341 seconds
vector delete front cost time is 1e-06 seconds

正如从前端插入元素一样，从向量前端删除元素的效率很低。在该测试中，列表的效率是向量的 100 倍。'但也请注意，为了阻止用户对向量容器进行这种低效的操作，STL 同样没
有为向量容器提供 pop_front() 方法'。


// !! 遍历

我们经常需要逐一地遍历容器中的每个元素，以此来对它们进行某种计算。我们将以 STL 的 accumulate() 函数为代表来说明容器的遍历操作。


accumulate() 函数的主要功能是从头到尾对容器进行遍历，同时将所有元素相加。

本节进行测试的容器包括数组、向量和列表。每个容器都保存着一个相同的集合, 该集合包含了 10，000 个随机整数。

以下是针对各种容器的测试程序:

 » g++ --std=c++11 TraversePerforTest.cpp
--------------------------------------------------------------------------------
 » ./a.out 
Traverse vector cost time is 0.007505 seconds
Traverse list cost time is 0.012249 seconds


'对于容器的遍历操作来说，向量和数组的性能是相同的。它们均远胜过列表'。

由此可以看出，'容器遍历的关键因素似乎为容器内存布局和系统缓存之间的交互作用'。向量和数组都把它们的集合存储在连续内存空间中。对于集合中逻辑上相邻的元素来说，它们
在物理存储器中也是相邻的。'当一个特定的元素被加载到缓存中时，会将连带几个接下来可能被访问的相邻元素跟它一起加载入缓存'(具体的个数由元素大小和缓存行大小决定)。从缓
存的角度来讲，这是一种理想的行为。而'列表容器并不是这种情况。逻辑上相邻的列表元素在物理内存中未必相邻'。此外，列表元素除了存储元素值外，还必须存储前向指针和后向指
针，这就使得列表元素比相应的向量元素大。即使是某些相邻的列表元素在内存中也被保存在相邻的位置，但由于它们比较大，也只有很少的元素才能装入缓存行。'因此，与数组和向
量的遍历相比，列表的遍历造成了过多的缓存失败'。


// !! 查找

之前的讨论为插入、删除和遍历操作总结了一些适用场合，在这些场合中，数组、向量和列表每一种都各有千秋。现在我们继续讨论另一种重要的操作, 在该操作中多重集容器将会表现
得相当出色。'这种操作就是在集合中查找某一特定元素的情况'。

下面这段代码使用 STL 的 find() 方法实现了各种容器上的查找操作:

void arrayFind(int *a, int *collection, int size)
{
    int const value = collection[size/2];
    int *p = find(&a[0], &a[size], value);
}

void vectorFind(vector<int> *a, int *collection, int size)
{
    int const value = collection[size/2];
    vector<int>::iterator it = find(a->begin(), a->end(), value);
}

void listFind(list<int> *a, int *collection, int size)
{
    int const value = collection[size/2];
    list<int>::iterator it = find(a->begin(), a->end(), value);
}

void multisetFind(multiset<int> *a, int *collection, int size)
{
    int const value = collection[size/2];
    multiset<int>::iterator it = find(a->begin(),a->end(), value);// 通用的 find() 算法
}

void multisetFind2(multiset<int> *a, int *collection, int size)
{
    int const value = collection[size/2];
    auto it = a->find(value);// 使用多重集容器提供的 find() 成员方法，应该会更加高效
}


很明显，当进行元素查找时，使用成员 find() 方法，多重集容器可以胜过其他的所有竞争对手。而多重集是有序集，这使其在插入和删除操作上遭受了一些性能上的损失。'但是，
从另一方面来看，有序特性也为多重集容器在查找方面带来了巨大的优势'。


// !! 函数对象

默认情况下，accumulate() 函数将 operator+ 操作应用到容器中所有元素，然后返回这些元素相加的累计结果。对于整数集合来说，如果提供给 accumulate() 函数的初始
值为 0，那么该函数返回的结果就是集合中所有元素的和。accumulate() 函数不仅可以进行对象相加，而且可以对容器元素进行任何操作(前提是元素支持这种操作)，然后返回
累计结果:

template<class InputIterator, class T>
T accumulate(InputIterator first, InputIterator beyondlast, T initialValue)
{
    while(first != beyondlast)
    {
        initialValue = initialValue + *first++;
    }
}

'在 C 语言程序设计中，参数化这种操作通常是通过传递函数指针来实现的'。STL 也可以这样实现，另外，它还'使用函数对象的形式为我们提供了另一种高效的可选方式'。


int mult(int x, int y)
{
    return x * y;
}

...

int a[10] = {1,2,3,4,5,6,7,8,9,10};
int product = accumulate(&a[0], &a[size], 0, mult);// 函数指针


第二种方法是将函数对象作为一个参数传递给 accumulate() 。函数对象是一个重载了 operator() 方法的类的实例。

例如：
class Mult
{
public:
    int operator()(int x, int y) const {return x*y;}
};

int a[10] = {1,2,3,4,5,6,7,8,9,10};
int product = accumulate(&a[0], &a[size], 0, Mult());// 函数对象的构造函数


因为 STL 已经提供了一个 times 模板类，所以我们实际上并不需要重新构造一个用于乘法的函数对象。

int a[10] = {1,2,3,4,5,6,7,8,9,10};
int product = accumulate(&a[0], &a[size], 0, times<int>());


我们比较了分别使用函数指针和函数对象的 accumulate() 的相对性能。'使用函数对象的版本明显优于使用函数指针的版本'。这跟预期的结果完全一致。函数指针直到运行
时才能被解析，这就使得它们无法被内联。'而函数对象是在编译时被确定的，这就使编译器可以自由地内联 operator() 函数并显著地提升效率'。


// !! 比 STL 更好？

很多人认为 STL 拥有极好的性能。人们基本上认定程序员根本不要企盼使用自定义实现来超越 STL 的性能。尽管在很大程度上我们是同意这种观点的，但我们还是想对其进行深入
研究。为了了解更多相关的知识，我们将重点讨论几处可以超越 STL 性能的地方，看看其运行方式。

在本章前面我们碰到了 accumulate() 函数，使用它对整数集合求和。现在让我们看看能否用自己定义的实现对它进行改善:

int myIntergerSum(int *a, int size)
{
    int sum =0;
    int *begin = &a[0];
    int *end = &a[size];

    for(int *p = begin; p != end; p++)
    {
        sum += *p;
    }
    return sum;
}


基于 STL 的解决方案为：

int stlIntergerSum(int *a, int size)
{
    return accumulate(&a[0], &a[size], size);
}

性能比较测试的结果表明 myIntegerSum() 和 stlIntegerSum() 的执行速度相同。我们想要超越 STL 速度的尝试很快就让我们失望了。我们可以得到一个合理的推测结果，
即这种情况是比较典型的，因而超越 STL 性能通常只能是规则中的例外情况。

STL 实现在以下几个方面形成了自己的优势：

● STL 实现使用最好的算法
● STL 实现的设计者非常有可能是领域内的专家
● 这些领域内的专家完全地致力于提供一个灵活、强大并且高效的库。这是他们的首要任务


对于我们其他的人，开发可重用的容器和通用算法充其量只能算第二目标。我们的首要任务是在期限内交付应用程序。大多数情况下，我们是没有时间和专业知识与那些 STL 的设计
者相比的。

既然我们已经尽全力打消您试图和 STL 一决高下的念头，那么我们就改变方式，介绍一些规则中可能的例外。例如，假设我们的应用程序经常需要反转一个字符序列，并且我们的字
符序列是固定长度的，比方说长度为 5 个字符。下面是一个可能的基于 STL 的解决方案：

char *a = "abcde";
reverse(&a[0], &a[5]);

另一种选择是实现我们自己的解决方案，代码如下:

char *a = "abcde";
char temp;
temp = a[4];

a[4] = a[0];
a[0] = temp;

temp = a[3];
a[3] = a[1];
a[1] = temp;

我们对该字符串反转代码循环执行100万次，然后记录下执行时间。

我们这种蛮力法的实现比 STL 实现快 4 倍，因为 STL 的 reverse() 实现没有注意到序列长度为 5 的事实。它可以处理任何序列长度，因此更为强大。我们的蛮力法并不简练，
并且极大地依赖序列的长度是 5 这个事实，因而它不能处理任何其他序列长度下的反转。'这是一个针对特定任务的相当专一的解决方案'。


虽然这个例子稍微有点牵强，但是通过它确实得出了至少三条关于 STL 性能的有用观点:

● 您需要付出很大的努力才能使自己定义的实现超过 STL 版本
● 胜过 STL 是有可能的

● '如果您打算胜过基于 STL 的解决方案，那么您最好了解一下相应领域中 STL 所忽略的问题'。否则，最好将自己的时间用在其他地方。我们可以得到一个关于超越 STL 性能的更
  为有力的结论。'即不管实现多么优秀，总会存在一些让人不是很满意的计算环境'。该实现不可能面面俱到。以列表容器为例，它支持插入、删除和 size() 成员函数，该成员函数
  返回当前存储在列表中的元素个数。当实现 size() 成员函数时，我们基本上有两种设计选项:

  1. 我们可以定义一个数据成员域跟踪当前的列表大小。对于每次插入或删除操作，这个成员将会马上被计算和更新。这种强制性的更新使得插入和删除稍微有点慢，但是 size() 
    函数却是极快(固定时间)。

  2. 只有在需要的时候才计算大小。因为不需要更新当前大小，所以插入和删除将会更快，但是 size() 操作会更慢。计算 size() 将需要一次顺序遍历来计算当前列表中元素的
     个数。

'STL 实现不得不在这两种设计选项中进行选择。无论做出什么选择，总会有一种场合的性能会很差'。对于插入和删除起决定性作用的工作，选择选项 1 较合适。另一方面，在一个大
的列表中频繁进行 size() 操作的工作，选择选项 2 较合适。由于这种原因，改善 STL 性能的可能性在理论上总是存在的。

// !! 要点

● STL 是抽象、灵活性和效率的一种罕见的结合

● 对于某种特定的应用模式，一些容器比其他的更加高效，这都要随着实际应用而定

● '除非了解一些相关领域内 STL 所忽略的问题，否则您是不可能超过 STL 实现的'

● 不过，在一些特定的情况下，还是有可能超越 STL 实现的性能的





